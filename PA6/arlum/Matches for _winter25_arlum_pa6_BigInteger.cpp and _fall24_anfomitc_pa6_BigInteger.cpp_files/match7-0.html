
<!-- saved from url=(0062)http://moss.stanford.edu/results/3/4374093143652/match7-0.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/arlum/pa6/BigInteger.cpp</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter25/arlum/pa6/BigInteger.cpp<p></p><pre>//-----------------------------------------------------------------------------
// Alexandra Lum
// arlum
// 2025 Winter CSE101 PA6
// BigInteger.cpp
// Implementation file for BigInteger
//-----------------------------------------------------------------------------

#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include "BigInteger.h"

// original power and base 
<a name="6"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/3/4374093143652/match7-1.html#6" target="1"><img src="./tm_1_3.gif" alt="other" border="0" align="left"></a>

const int power = 9;
const long base = 1000000000;


// Class Constructors &amp; Destructors ----------------------------------------

// BigInteger()
// Constructor that creates a new BigInteger in the zero state: 
// signum=0, digits=().
BigInteger::BigInteger() {
    signum = 0;
}

// BigInteger()
// Constructor that creates a new BigInteger from the long value x.
BigInteger::BigInteger(long x) {
    if (x==0) {
        signum = 0;
        return;
    }
    if (x &lt; 0) {
        signum = -1;
        x = -x;
    } else {
        signum = +1;
</font>    }

    // Extract digits and insert them into the digits list
    while (x &gt; 0) {
        digits.insertAfter(x % base); // Insert least significant digit
        x /= base; // Move to the next most significant digit
    }
}

// BigInteger()
// Constructor that creates a new BigInteger from the string s.
// Pre: s is a non-empty string consisting of (at least one) base 10 digit
// {0,1,2,3,4,5,6,7,8,9}, and an optional sign {+,-} prefix.
<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/3/4374093143652/match7-1.html#0" target="1"><img src="./tm_0_28.gif" alt="other" border="0" align="left"></a>

BigInteger::BigInteger(std::string s) {
    if (s.length()==0) {
        throw std::invalid_argument("BigInteger: Constructor: empty string");
    }

    if (s[0] == '-') {
        signum = -1;
        s = s.substr(1, s.length()-1);
    } else if (s[0] == '+') {
        signum = +1;
        s = s.substr(1, s.length()-1);
    } else {
        signum = +1;
    }

    if (s.length()==0) {
        throw std::invalid_argument("BigInteger: Constructor: non_numeric string");
    }

    if (all_of(s.begin(), s.end(), ::isdigit) == false) {
        throw std::invalid_argument("BigInteger: Constructor: non-numeric string");
    }

    if (s.find_first_not_of("0") == std::string::npos) {
        signum = 0; 
        return; 
    }

    size_t position = s.find_first_not_of('0');
    s = s.substr(position);

    int pos; 
    for (pos = s.length() - power; pos &gt;= 0; pos -= power) {
        std::string str = s.substr(pos, power);
        long l = std::stol(str);
        digits.insertAfter(l);
    }

    if (pos &gt; -power) {
        std::string str = s.substr(0, pos + power);
        long l = std::stol(str);
        digits.insertAfter(l);
    }
}

// BigInteger()
// Constructor that creates a copy of N.
BigInteger::BigInteger(const BigInteger&amp; N) {
    signum = N.signum;
    digits = List (N.digits);
}

// Optional Destuctor
// ~BigInteger()
// ~BigInteger();


// Access functions --------------------------------------------------------

// sign()
// Returns -1, 1 or 0 according to whether this BigInteger is positive, 
// negative or 0, respectively.
int BigInteger::sign() const {
    return signum;
}

// compare()
// Returns -1, 1 or 0 according to whether this BigInteger is less than N,
// greater than N or equal to N, respectively.
int BigInteger::compare(const BigInteger&amp; N) const {
    if (sign() &lt; N.sign()) return -1; 
    if (sign() == 0 &amp;&amp; N.sign() == 0) return 0; 
    if (sign() &gt; N.sign()) return 1; 

    int result = 0;
    if (digits.length() &lt; (N.digits).length()) {
        result = -1;
    } else if (digits.length() &gt; (N.digits).length()) {
        result = +1;
    } else {
        List A(digits);
        List B(N.digits);

        A.moveFront();  // compare A and B starting from the largest place values
        B.moveFront();

        while (A.position() &lt; A.length()) {
            // printf("compare 1\n");
            long dataA = A.moveNext();
            // printf("compare 2\n");
            long dataB = B.moveNext();

            if (dataA &lt; dataB) {
                result = -1;
                break;
            } else if (dataA &gt; dataB) {
                result = +1;
</font>                break;
            }
        }
    }
<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/3/4374093143652/match7-1.html#4" target="1"><img src="./tm_4_5.gif" alt="other" border="0" align="left"></a>

    return result * sign();
}


// Manipulation procedures -------------------------------------------------

// makeZero()
// Re-sets this BigInteger to the zero state.
void BigInteger::makeZero() {
    signum = 0;
    digits.clear();
}

// negate()
// If this BigInteger is zero, does nothing, otherwise reverses the sign of 
// this BigInteger positive &lt;--&gt; negative. 
void BigInteger::negate() {
    signum *= -1;
}


// BigInteger Arithmetic operations ----------------------------------------


// add()
// Returns a BigInteger representing the sum of this and N.
BigInteger BigInteger::add(const BigInteger&amp; N) const {
    if (sign() == 0) return BigInteger (N);         // 0 cases
    if (N.sign() == 0) return BigInteger (*this);

    BigInteger copythis(*this);
    BigInteger copyN(N);

    (copythis.digits).moveBack(); 
    (copyN.digits).moveBack(); 

    long carry = 0;
</font>    BigInteger result;
    long A, B, value;

    while(1) {
<a name="7"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/3/4374093143652/match7-1.html#7" target="1"><img src="./tm_2_2.gif" alt="other" border="0" align="left"></a>

        A = 0;
        B = 0;
        if ((copythis.digits).position() &gt; 0) {
            A = (copythis.digits).movePrev();
        }
        if ((copyN.digits).position() &gt; 0) {
            B = (copyN.digits).movePrev();
</font>        }

<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/3/4374093143652/match7-1.html#3" target="1"><img src="./tm_3_7.gif" alt="other" border="0" align="left"></a>

        value = (A * copythis.signum) + (B * copyN.signum) + carry;
        carry = value / base;
        value = value % base;

        // printf("carry: %ld, value: %ld\n", carry, value);
        // printf("A: %ld, B: %ld\n", A, B);

        if (value &gt; 0) {
            result.signum = 1;
        } else if (value &lt; 0) {
            result.signum = -1;
            value = -value;
        }

        if ((copythis.digits).position() == 0 &amp;&amp; (copyN.digits).position() == 0 &amp;&amp; carry == 0 &amp;&amp; value == 0) {
            break;
        }

        (result.digits).insertAfter(value);
    }

    // check if result is 0
    bool zero = true;
    (result.digits).moveFront();
    while (zero &amp;&amp; (result.digits).position() &lt; (result.digits).length()) {
</font>        // printf("add\n");
        if ((result.digits).moveNext() != 0) {
            zero = false;
            break;
        }
    }
    if (zero) {
<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/3/4374093143652/match7-1.html#1" target="1"><img src="./tm_1_12.gif" alt="other" border="0" align="left"></a>

        result.makeZero();
    }

    (result.digits).moveFront();
    return result;
}

// sub()
// Returns a BigInteger representing the difference of this and N.
BigInteger BigInteger::sub(const BigInteger&amp; N) const {
    BigInteger copy(N);
    copy.negate();
    return add(copy);
}


// scalarMultList()
// helper function for mult()
List scalarMultList(List&amp; L, ListElement m) {
    L.moveBack(); 
    int carry = 0; 
    long A; 
    List result; 

    while(true) {
        A = 0; 
        if ((L).position() &gt; 0) A = (L).movePrev();

        long value = (A * m) + carry;   // addition operation with signs and carry 
        carry = value / base;           // update carry 
        value = value % base;           // update the value 

        if (L.position() == 0 &amp;&amp; carry == 0 &amp;&amp; value == 0) {
            break; 
        }
        (result).insertAfter(value);    // add value to results digits 
    }
    return result; 
}


// mult()
// Returns a BigInteger representing the product of this and N. 
BigInteger BigInteger::mult(const BigInteger&amp; N) const {
    if (N.signum == 0 || signum == 0) {  // zero case
        return BigInteger();
    }

    if (*this == BigInteger("1")) {  // one cases
        return BigInteger(N);
    }
    if (N == BigInteger("1")) {
        return BigInteger(*this);
    }

    BigInteger A(*this);
    BigInteger B(N);
    BigInteger result;
    int shift = 0;
</font>
    (B.digits).moveBack();

    while ((B.digits).position() &gt; 0) {
        BigInteger temp;
<a name="5"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/3/4374093143652/match7-1.html#5" target="1"><img src="./tm_0_3.gif" alt="other" border="0" align="left"></a>

        temp.signum = 1;

        temp.digits = scalarMultList(A.digits, (B.digits).movePrev());

        (temp.digits).moveBack();
        for(int i = 0; i &lt; shift; i++) {
            (temp.digits).insertBefore(0);
        }

        result += temp;
        shift++;
</font>    }
<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/3/4374093143652/match7-1.html#2" target="1"><img src="./tm_2_8.gif" alt="other" border="0" align="left"></a>

    result.signum = A.signum * B.signum;
    return result;
}


// Other Functions ---------------------------------------------------------

// to_string()
// Returns a string representation of this BigInteger consisting of its
// base 10 digits. If this BigInteger is negative, the returned string 
// will begin with a negative sign '-'. If this BigInteger is zero, the
// returned string will consist of the character '0' only.
std::string BigInteger::to_string() {
    std::string result = "";

    if (signum == 0) {   // 0 case
        result += "0";
        return result;
    }

    if (signum == -1) {  // leading negative
        result += "-";
    }
    char buffer[10];
    digits.moveFront();
    // printf("to_string 1\n");
    // printf("list length: %d     signum: %d\n", digits.length(), signum);
    long value = digits.moveNext();
    result += std::to_string(value);
    while (digits.position() &lt; digits.length()) {
        // printf("to_string 2\n");
        value = digits.moveNext();
        sprintf(buffer, "%09ld", value);
        result += buffer;
    }

    return result;
}


// Overriden Operators -----------------------------------------------------

// operator&lt;&lt;()
// Inserts string representation of N into stream.
std::ostream&amp; operator&lt;&lt;( std::ostream&amp; stream, BigInteger N ) {
    return stream &lt;&lt; N.to_string();
</font>}

// operator==()
// Returns true if and only if A equals B. 
bool operator==( const BigInteger&amp; A, const BigInteger&amp; B ) {
    return A.compare(B) == 0; 
}

// operator&lt;()
// Returns true if and only if A is less than B. 
bool operator&lt;( const BigInteger&amp; A, const BigInteger&amp; B ) {
    return A.compare(B) == -1; 
}

// operator&lt;=()
// Returns true if and only if A is less than or equal to B. 
bool operator&lt;=( const BigInteger&amp; A, const BigInteger&amp; B ) {
    return A.compare(B) &lt;= 0; 
}

// operator&gt;()
// Returns true if and only if A is greater than B. 
bool operator&gt;( const BigInteger&amp; A, const BigInteger&amp; B ) {
    return A.compare(B) == 1; 
}

// operator&gt;=()
// Returns true if and only if A is greater than or equal to B. 
bool operator&gt;=( const BigInteger&amp; A, const BigInteger&amp; B ) {
    return A.compare(B) &gt;= 0; 
}

// operator+()
// Returns the sum A+B. 
BigInteger operator+( const BigInteger&amp; A, const BigInteger&amp; B ) {
    return A.add(B); 
}

// operator+=()
// Overwrites A with the sum A+B. 
BigInteger operator+=( BigInteger&amp; A, const BigInteger&amp; B ) {
    A = A.add(B);
    return A; 
}

// operator-()
// Returns the difference A-B. 
BigInteger operator-( const BigInteger&amp; A, const BigInteger&amp; B ) {
    return A.sub(B); 
}

// operator-=()
// Overwrites A with the difference A-B. 
BigInteger operator-=( BigInteger&amp; A, const BigInteger&amp; B ) {
    A = A.sub(B); 
    return A; 
}

// operator*()
// Returns the product A*B. 
BigInteger operator*( const BigInteger&amp; A, const BigInteger&amp; B ) {
    return A.mult(B); 
}

// operator*=()
// Overwrites A with the product A*B. 
BigInteger operator*=( BigInteger&amp; A, const BigInteger&amp; B ) {
    A = A.mult(B); 
    return A; 
}
</pre>



</body></html>