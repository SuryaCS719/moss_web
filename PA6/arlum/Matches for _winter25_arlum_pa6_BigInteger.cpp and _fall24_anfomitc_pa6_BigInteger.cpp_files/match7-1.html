
<!-- saved from url=(0062)http://moss.stanford.edu/results/3/4374093143652/match7-1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/arlum/pa6/BigInteger.cpp</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/fall24/anfomitc/pa6/BigInteger.cpp<p></p><pre>

/***
* Anna Fomitchev
* anfomitc
* 2024 Fall CSE101 PA6
* BigInteger.cpp
* creates all of the actual code of the functions, constructors, and operations for the BigInteger ADT. 
***/ 

#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include "BigInteger.h"



// original power and base 
<a name="6"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/3/4374093143652/match7-0.html#6" target="0"><img src="./tm_1_3.gif" alt="other" border="0" align="left"></a>

const int power = 9;
const long base = 1000000000;

// const int power = 1;
// const long base = 10;

// Class Constructors &amp; Destructors ----------------------------------------

// BigInteger()
// Constructor that creates a new BigInteger in the zero state: 
// signum=0, digits=().
BigInteger::BigInteger() {
    // BigInteger Fields 
   signum = 0;
}

// BigInteger()
// Constructor that creates a new BigInteger from the long value x.
BigInteger::BigInteger(long x) {
    // check for signs
    if (x==0) {
        signum = 0; 
        return; 
    }
    if (x&lt;0) {
        signum = -1;
        // negate x 
        x = -x;
    }
    else signum = +1; 
</font>


}

// BigInteger()
// Constructor that creates a new BigInteger from the string s.
// Pre: s is a non-empty string consisting of (at least one) base 10 digit
// {0,1,2,3,4,5,6,7,8,9}, and an optional sign {+,-} prefix.
<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/3/4374093143652/match7-0.html#0" target="0"><img src="./tm_0_29.gif" alt="other" border="0" align="left"></a>

BigInteger::BigInteger(std::string s) {
    // precondition 
    if (s.length()==0) {
        throw std::invalid_argument("BigInteger: Constructor: empty string");
    }
    
    
    if (s[0] == '-') {
        signum = -1; 
        s = s.substr(1,s.length()-1);
    } 
    else if (s[0] == '+') {
        signum = +1;
        s = s.substr(1,s.length()-1);
    }
    else signum = +1;

    if (s.length()==0) {
        throw std::invalid_argument("BigInteger: Constructor: empty string");
    }
    // check if all chars in string are digits 
    if (all_of(s.begin(), s.end(), ::isdigit) == false) {
        throw std::invalid_argument("BigInteger: Constructor: non-numeric string");
    }

    // check if all are 0s, will be true if all 0s
    if (s.find_first_not_of("0") == std::string::npos) {
        signum = 0; 
        return; 
    }

    // remove leading zeros 
    size_t position = s.find_first_not_of('0');
    s = s.substr(position);
    // // remove leading zeros 
    // int i; 
    // for (i = 0; s[0] == '0';i++); 
    // s = s.substr(1,s.length()-i);
    
    
    
    int pos; 
    // loop through string backwards 
    for (pos = s.length()-power; pos &gt;= 0; pos-=power) {
        // parse string
        std::string str = s.substr(pos,power);
        
        // convert string to long 
        long l = std::stol(str);

        // add to digits 
        digits.insertAfter(l);
    }

    // left overs 
    if (pos &gt; -power) {
        std::string str = s.substr(0, pos+power);
        long l = std::stol(str);
        digits.insertAfter(l);
    }

    
}


// BigInteger()
// Constructor that creates a copy of N.
BigInteger::BigInteger(const BigInteger&amp; N) {
    signum = N.sign(); 
    digits = List (N.digits);  
}


// Access functions --------------------------------------------------------

// sign()
// Returns -1, 1 or 0 according to whether this BigInteger is positive, 
// negative or 0, respectively.
int BigInteger::sign() const {
    return signum; 
}

// compare()
// Returns -1, 1 or 0 according to whether this BigInteger is less than N,
// greater than N or equal to N, respectively.
int BigInteger::compare(const BigInteger&amp; N) const {
    // compare by signums first to save time 
    if (sign()&lt; N.sign()) return -1; 
    if (sign() == 0 &amp;&amp; N.sign() == 0) return 0; 
    if (sign() &gt; N.sign()) return 1; 

    int result = 0; 
    // now compare the lenghts of digits 
    if (digits.length() &lt; (N.digits).length()) result = -1; 
    else if (digits.length() &gt; (N.digits).length()) result = +1; 
    else {
        // make copies of the digits lists 
        List A(digits); 
        List B(N.digits); 

        A.moveFront(); 
        B.moveFront(); 

        while (A.position() &lt; A.length()) {
            long dataA = A.moveNext(); 
            long dataB = B.moveNext(); 

            if (dataA &lt; dataB) {
                result = -1;
                break; 
            }
            else if (dataA &gt; dataB) {
                result = 1; 
</font>                break; 
            }
        }
    }
    
<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/3/4374093143652/match7-0.html#4" target="0"><img src="./tm_4_5.gif" alt="other" border="0" align="left"></a>

    return result * sign(); 
}



// Manipulation procedures -------------------------------------------------

// makeZero()
// Re-sets this BigInteger to the zero state.
void BigInteger::makeZero() {
    signum = 0; 
    digits.clear();
}

// negate()
// If this BigInteger is zero, does nothing, otherwise reverses the sign of 
// this BigInteger positive &lt;--&gt; negative. 
void BigInteger::negate() {
    signum *= -1; 
}



// BigInteger Arithmetic operations ----------------------------------------
// add()
// Returns a BigInteger representing the sum of this and N.
BigInteger BigInteger::add(const BigInteger&amp; N) const {
    // handle 0 cases 
    if (sign() == 0) return BigInteger (N);
    if (N.sign() == 0) return BigInteger (*this);

    // make copies 
    BigInteger copythis(*this); 
    BigInteger copyN(N); 

    // start from right 
    (copythis.digits).moveBack(); 
    (copyN.digits).moveBack(); 

    long carry = 0; 
</font>    BigInteger result; 
    long A = 0; 
    long B = 0; 

    while(true) {
<a name="7"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/3/4374093143652/match7-0.html#7" target="0"><img src="./tm_2_2.gif" alt="other" border="0" align="left"></a>

        A = 0; 
        B = 0; 

        // check if there is anything in the lists left to move
        if ((copythis.digits).position() &gt; 0) A = (copythis.digits).movePrev(); 
        if ((copyN.digits).position() &gt; 0) B = (copyN.digits).movePrev(); 
</font>        
        
        // addition operation with signs and carry 
<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/3/4374093143652/match7-0.html#3" target="0"><img src="./tm_3_7.gif" alt="other" border="0" align="left"></a>

        long value = (A * copythis.signum) + (B * copyN.signum) + carry; 

        // update carry 
        carry = value / base; 

        // update the value 
        value = value % base; 
        //printf("carry: %ld, value: %ld\n",carry, value);
        // change the signum 
        if (value &gt; 0) {result.signum = 1;}
        else if (value &lt; 0) {
            result.signum = -1; 
            // remove the negative 
            value = -value;
        }

        // break condition 
        if ((copythis.digits).position() == 0 &amp;&amp; (copyN.digits).position() == 0 &amp;&amp; carry == 0 &amp;&amp; value == 0) break; 

        // add value to results digits 
        (result.digits).insertAfter(value); 
    }


    // check if result is 0 
    bool iszero = true; 
    (result.digits).moveFront(); 
    while (iszero == true &amp;&amp; (result.digits).position() &lt; (result.digits).length()) {
</font>        if ((result.digits).moveNext() != 0) iszero = false; 
    }

<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/3/4374093143652/match7-0.html#1" target="0"><img src="./tm_1_12.gif" alt="other" border="0" align="left"></a>

    if (iszero == true) result.makeZero();

    // reset result and return 
    (result.digits).moveFront(); 
    return result; 

}

// sub()
// Returns a BigInteger representing the difference of this and N.
BigInteger BigInteger::sub(const BigInteger&amp; N) const {
    // negate second value and add 
    BigInteger copyN(N); 
    copyN.negate(); 
    return add(copyN);
}


// helper functions for mult 
// scalarMultList()
// Multiplies L (considered as a vector) by m. Used by mult().
List scalarMultList(List&amp; L, ListElement m) {
    L.moveBack(); 
    int carry = 0; 
    long A; 
    List result; 

    while(true) {
        A = 0; 
        if ((L).position() &gt; 0) A = (L).movePrev();

        // addition operation with signs and carry 
        long value = (A * m) + carry; 

        // update carry 
        carry = value / base; 

        // update the value 
        value = value % base; 

        //printf("carry: %ld, value: %ld\n",carry, value);

        // break condition 
        if (L.position() == 0 &amp;&amp; carry == 0 &amp;&amp; value == 0) break; 

        // add value to results digits 
        (result).insertAfter(value); 
    }

    return result; 
}

// mult()
// Returns a BigInteger representing the product of this and N. 
BigInteger BigInteger::mult(const BigInteger&amp; N) const {
    // special cases in multiplying 
    // one or both are 0 we return 0 
    if (N.signum == 0 || signum == 0) return BigInteger(); 

    // one is 1 
    if (*this == BigInteger("1")) return BigInteger(N); 
    if (N == BigInteger("1")) return BigInteger(*this); 

    BigInteger A(*this); 
    BigInteger B(N);  
    BigInteger result; 
    int shift = 0; 
</font>

    for((B.digits).moveBack(); (B.digits).position() &gt; 0; shift++) {
        
        BigInteger temp;
<a name="5"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/3/4374093143652/match7-0.html#5" target="0"><img src="./tm_0_3.gif" alt="other" border="0" align="left"></a>

        temp.signum = 1; 
        
        // scalar mult
        temp.digits = scalarMultList(A.digits, (B.digits).movePrev()); 
        
        // shift 
        (temp.digits).moveBack(); 
        for (int i = 0; i &lt; shift; i++) {
            (temp.digits).insertBefore(0);
        }

        // add to result 
        result += temp; 
    }

    // handle sign 
    result.signum = A.signum * B.signum; 
</font><a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/3/4374093143652/match7-0.html#2" target="0"><img src="./tm_2_8.gif" alt="other" border="0" align="left"></a>

    return result; 


}

// Other Functions ---------------------------------------------------------

// to_string()
// Returns a string representation of this BigInteger consisting of its
// base 10 digits. If this BigInteger is negative, the returned string 
// will begin with a negative sign '-'. If this BigInteger is zero, the
// returned string will consist of the character '0' only.
std::string BigInteger::to_string() {
    std::string result = "";
    
    // 0 case 
    if (signum == 0) {
        result += "0";
        return result; 
    }

    // -1 signum case 
    if (signum == -1) {
        result += "-";
    }
    char buffer [10];
    digits.moveFront(); 
    long data = digits.moveNext(); 
    result += std::to_string(data);
    for (; digits.position() &lt; digits.length();) {
        data = digits.moveNext(); 
        sprintf(buffer, "%09ld", data); 
        result += buffer; 
        //result += std::to_string(data);
    }

    return result;

    
    
    
    // std::stringstream ss;
    
    // // 0 case 
    // if (signum == 0) {
    //     return "0"; 
    // }

    // // -1 signum case 
    // if (signum == -1) {
    //     ss &lt;&lt; "-";
    // }

    // // Traverse through the digits list
    // digits.moveFront();
    // for (int i = 0; i &lt; digits.length(); i++) {
    //     long data = digits.moveNext();
        
    //     if (i == 0) {
    //         // First segment: no leading zero padding
    //         ss &lt;&lt; std::to_string(data);
    //     } else {
    //         // Subsequent segments: pad with leading zeros to DIGIT_LENGTH
    //         ss &lt;&lt; std::setw(digits.length()) &lt;&lt; std::setfill('0') &lt;&lt; std::to_string(data);
    //     }
    // }

    // return ss.str();






    // bool leadingzero = true; 
    // for (digits.moveFront(); digits.position() &lt; digits.length();) {
    //     long data = digits.moveNext(); 
        
    //     // remove leading zeros 
    //     std::string segment = std::to_string(data); 
    //     if (leadingzero) {
    //         segment.erase(0, segment.find_first_not_of('0'));
    //         leadingzero = false; 
    //     }

    //     result += segment; 
    // }
    // return result; 
}



// operator&lt;&lt;()
// Inserts string representation of N into stream.
std::ostream&amp; operator&lt;&lt;( std::ostream&amp; stream, BigInteger N ) {
    return stream &lt;&lt; N.to_string();
</font>}

// operator==()
// Returns true if and only if A equals B. 
bool operator==( const BigInteger&amp; A, const BigInteger&amp; B ) {
    return A.compare(B) == 0; 
}

// operator&lt;()
// Returns true if and only if A is less than B. 
bool operator&lt;( const BigInteger&amp; A, const BigInteger&amp; B ) {
    return A.compare(B) == -1; 
}

// operator&lt;=()
// Returns true if and only if A is less than or equal to B. 
bool operator&lt;=( const BigInteger&amp; A, const BigInteger&amp; B ) {
    return A.compare(B) &lt;= 0; 
}

// operator&gt;()
// Returns true if and only if A is greater than B. 
bool operator&gt;( const BigInteger&amp; A, const BigInteger&amp; B ) {
    return A.compare(B) == 1; 
}

// operator&gt;=()
// Returns true if and only if A is greater than or equal to B. 
bool operator&gt;=( const BigInteger&amp; A, const BigInteger&amp; B ) {
    return A.compare(B) &gt;= 0; 
}

// operator+()
// Returns the sum A+B. 
BigInteger operator+( const BigInteger&amp; A, const BigInteger&amp; B ) {
    return A.add(B); 
}

// operator+=()
// Overwrites A with the sum A+B. 
BigInteger operator+=( BigInteger&amp; A, const BigInteger&amp; B ) {
    A = A.add(B);
    return A; 
}

// operator-()
// Returns the difference A-B. 
BigInteger operator-( const BigInteger&amp; A, const BigInteger&amp; B ) {
    return A.sub(B); 
}

// operator-=()
// Overwrites A with the difference A-B. 
BigInteger operator-=( BigInteger&amp; A, const BigInteger&amp; B ) {
    A = A.sub(B); 
    return A; 
}

// operator*()
// Returns the product A*B. 
BigInteger operator*( const BigInteger&amp; A, const BigInteger&amp; B ) {
    return A.mult(B); 
}

// operator*=()
// Overwrites A with the product A*B. 
BigInteger operator*=( BigInteger&amp; A, const BigInteger&amp; B ) {
    A = A.mult(B); 
    return A; 
}
</pre>



</body></html>