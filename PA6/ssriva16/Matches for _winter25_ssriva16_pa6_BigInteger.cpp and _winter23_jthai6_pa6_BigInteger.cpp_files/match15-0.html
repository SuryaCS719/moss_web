
<!-- saved from url=(0063)http://moss.stanford.edu/results/2/9385355196810/match15-0.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/ssriva16/pa6/BigInteger.cpp</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter25/ssriva16/pa6/BigInteger.cpp<p></p><pre>// Sara Srivastava, ssriva16, pa6

#include "BigInteger.h"
#include &lt;stdexcept&gt;
#include &lt;ctype.h&gt;

#define BASE 1000000000
#define DIGIT_SIZE 9

using namespace std;

// Constructors &amp; Destructors ----- 
BigInteger::BigInteger() {
    signum = 0;
    digits = List();
}

BigInteger::BigInteger(long num) {
    if (num == 0) {
        signum = 0;
        digits = List();
    } else if (num &lt; 0) {
        signum = -1;
        num = -num;
    } else {
        signum = 1;
    }

    digits = List();
    while (num &gt; 0) {
        digits.insertAfter(num % BASE);
        num /= BASE;
    }
}

BigInteger::BigInteger(string str) {
    if (str.empty()) {
        throw invalid_argument("BigInteger: Constructor: empty string");
    }

<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/2/9385355196810/match15-1.html#3" target="1"><img src="./tm_3_4.gif" alt="other" border="0" align="left"></a>

    if (str[0] == '+') {
        signum = 1;
        str = str.substr(1, str.length());
    } else if (str[0] == '-') {
        signum = -1;
        str = str.substr(1, str.length());
    } else {
        signum = 1;
    }

    for (char const &amp;ch : str) {
        if (!isdigit(ch)) {
            throw invalid_argument("BigInteger: Constructor: non-numeric string");
</font>        }
    }

    bool finished = false;
    for (int i = str.length() - DIGIT_SIZE; ; i -= DIGIT_SIZE) {
        if (i &lt; 0) {
            digits.insertAfter(stol(str.substr(0, i + DIGIT_SIZE)));
            finished = true;
        } else if (i == 0) {
            digits.insertAfter(stol(str.substr(i, DIGIT_SIZE)));
            finished = true;
        } else {
            digits.insertAfter(stol(str.substr(i, DIGIT_SIZE)));
        }
        if (finished) {
            break;
        }
    }
}

BigInteger::BigInteger(const BigInteger&amp; other) {
    this-&gt;signum = other.signum;
<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/2/9385355196810/match15-1.html#2" target="1"><img src="./tm_2_6.gif" alt="other" border="0" align="left"></a>

    this-&gt;digits = other.digits;
}

// Access Functions ----- 
int BigInteger::sign() const {
    return this-&gt;signum;
}

int BigInteger::compare(const BigInteger&amp; other) const {
    if (this-&gt;signum &gt; other.signum) {
        return 1;
    } else if (this-&gt;signum &lt; other.signum) {
        return -1;
    } else if (this-&gt;signum == 0 &amp;&amp; other.signum == 0) {
        return 0;
    }

    List aList = this-&gt;digits;
    List bList = other.digits;

    if (this-&gt;signum == 1 &amp;&amp; other.signum == 1) {
        if (aList.length() != bList.length()) {
</font><a name="5"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/2/9385355196810/match15-1.html#5" target="1"><img src="./tm_0_3.gif" alt="other" border="0" align="left"></a>

            return (aList.length() &gt; bList.length()) ? 1 : -1;
        }
        aList.moveFront();
        bList.moveFront();
        for (; aList.position() &lt; aList.length(); aList.moveNext(), bList.moveNext()) {
            if (aList.peekNext() &gt; bList.peekNext()) {
                return 1;
            } else if (aList.peekNext() &lt; bList.peekNext()) {
                return -1;
</font>            }
        }
        return 0;
    } else if (this-&gt;signum == -1 &amp;&amp; other.signum == -1) {
        if (aList.length() != bList.length()) {
<a name="6"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/2/9385355196810/match15-1.html#6" target="1"><img src="./tm_1_3.gif" alt="other" border="0" align="left"></a>

            return (aList.length() &gt; bList.length()) ? -1 : 1;
        }
        aList.moveFront();
        bList.moveFront();
        for (; aList.position() &lt; aList.length(); aList.moveNext(), bList.moveNext()) {
            if (aList.peekNext() &gt; bList.peekNext()) {
                return -1;
            } else if (aList.peekNext() &lt; bList.peekNext()) {
</font>                return 1;
            }
        }
        return 0;
    }
<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/2/9385355196810/match15-1.html#0" target="1"><img src="./tm_0_22.gif" alt="other" border="0" align="left"></a>

    return 0;
}

// Manipulation Procedures ----- 
void BigInteger::makeZero() {
    signum = 0;
    digits.clear();
}

void BigInteger::negate() {
    signum *= -1;
}

// Helper Functions ----- 
void negateList(List&amp; lst) {
    lst.moveFront();
    while (lst.position() &lt; lst.length()) {
        lst.setAfter(-1 * lst.peekNext());
        lst.moveNext();
    }
}

void sumList(List&amp; result, List a, List b, int sign) {
    result.clear();
    b.moveFront();
    while (b.position() &lt; b.length()) {
        b.setAfter(sign * b.peekNext());
        b.moveNext();
    }

    a.moveBack();
    b.moveBack();
    while (a.position() &gt; 0 &amp;&amp; b.position() &gt; 0) {
        result.insertAfter(a.peekPrev() + b.peekPrev());
        a.movePrev();
        b.movePrev();
    }
    while (a.position() &gt; 0) {
        result.insertAfter(a.peekPrev());
        a.movePrev();
    }
    while (b.position() &gt; 0) {
        result.insertAfter(b.peekPrev());
        b.movePrev();
    }

    result.moveFront();
    while (result.front() == 0 &amp;&amp; result.length() &gt; 1) {
        result.eraseAfter();
    }
}

int normalizeList(List&amp; lst) {
    if (lst.front() == 0) {
        return 0;
    }

    int sign = 1;
    if (lst.front() &lt; 0) {
        negateList(lst);
        sign = -1;
    }

    lst.moveBack();
    ListElement elem = 0;
    int carry = 0;
    while (lst.position() &gt; 0) {
        elem = lst.peekPrev();
        if (elem &lt; 0) {
            elem += BASE + carry;
            lst.setBefore(elem);
            carry = -1;
        } else {
            elem += carry;
            carry = 0;
            if (elem &gt;= BASE) {
                carry = elem / BASE;
                elem = elem % BASE;
            }
            lst.setBefore(elem);
        }
        lst.movePrev();
    }
    if (carry != 0) {
        lst.moveFront();
        lst.insertAfter(carry);
    }
    return sign;
}

void shiftList(List&amp; lst, int p) {
    lst.moveBack();
    for (int i = 0; i &lt; p; i++) {
</font>        lst.insertAfter(0);
    }
}

<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/2/9385355196810/match15-1.html#4" target="1"><img src="./tm_4_3.gif" alt="other" border="0" align="left"></a>

void scalarMultList(List&amp; lst, ListElement elem) {
    lst.moveFront();
    while (lst.position() &lt; lst.length()) {
        lst.setAfter(lst.peekNext() * elem);
        lst.moveNext();
    }
}

// BigInteger Arithmetic Operations ----- 
BigInteger BigInteger::add(const BigInteger&amp; other) const {
    BigInteger sumResult;
    List sum;
    List a = this-&gt;digits;
    List b = other.digits;
</font>
<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/2/9385355196810/match15-1.html#1" target="1"><img src="./tm_1_10.gif" alt="other" border="0" align="left"></a>

    if (this-&gt;signum &lt; 0) {
        negateList(a);
    }
    if (other.signum &lt; 0) {
        negateList(b);
    }
    sumList(sum, a, b, 1);
    sumResult.signum = normalizeList(sum);
    sumResult.digits = sum;

    return sumResult;
}

BigInteger BigInteger::sub(const BigInteger&amp; other) const {
    BigInteger difference;
    BigInteger negOther = other;
    negateList(negOther.digits);
    difference = this-&gt;add(negOther);

    return difference;
}

BigInteger BigInteger::mult(const BigInteger&amp; other) const {
    BigInteger product;
    if (this-&gt;signum == 0 || other.signum == 0) {
        return product;
    }
    List result;
    result.insertAfter(0);
    List multiplier;
    List copyOther = other.digits;

    copyOther.moveBack();
    int shift = 0;
    while (copyOther.position() &gt; 0) {
        multiplier = this-&gt;digits;
        scalarMultList(multiplier, copyOther.peekPrev());
        shiftList(multiplier, shift);

        List tempProduct = result;
        sumList(result, tempProduct, multiplier, 1);
        normalizeList(result);
</font>
        copyOther.movePrev();
        shift++;
    }

<a name="7"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/2/9385355196810/match15-1.html#7" target="1"><img src="./tm_2_2.gif" alt="other" border="0" align="left"></a>

    product.digits = result;
    if (this-&gt;signum == other.signum) {
        product.signum = 1;
    } else {
        product.signum = -1;
    }

    return product;
}

// Other Functions ----- 
std::string BigInteger::to_string() {
</font>    string out = "";
    if (this-&gt;signum == 0) {
        return "0";
    } else if (signum == -1) {
        out += "-";
    }

    digits.moveFront();
    while (digits.front() == 0 &amp;&amp; digits.length() &gt; 1) {
        digits.eraseAfter();
    }

    for (digits.moveFront(); digits.position() &lt; digits.length(); digits.moveNext()) {
        string part = std::to_string(digits.peekNext());
        string zeros = "";
        while ((int)(zeros.length() + part.length()) &lt; DIGIT_SIZE &amp;&amp; digits.position() != 0) {
            zeros += '0';
        }
        out += (zeros + part);
    }

    return out;
}

// Overriden Operators ----- 
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, BigInteger number) {
    return stream &lt;&lt; number.to_string();
}

bool operator==(const BigInteger&amp; a, const BigInteger&amp; b) {
    return a.compare(b) == 0;
}

bool operator&lt;(const BigInteger&amp; a, const BigInteger&amp; b) {
    return a.compare(b) == -1;
}

bool operator&lt;=(const BigInteger&amp; a, const BigInteger&amp; b) {
    return a.compare(b) &lt;= 0;
}

bool operator&gt;(const BigInteger&amp; a, const BigInteger&amp; b) {
    return a.compare(b) == 1;
}

bool operator&gt;=(const BigInteger&amp; a, const BigInteger&amp; b) {
    return a.compare(b) &gt;= 0;
}

BigInteger operator+(const BigInteger&amp; a, const BigInteger&amp; b) {
    return a.add(b);
}

BigInteger operator+=(BigInteger&amp; a, const BigInteger&amp; b) {
    a = a.add(b);
    return a;
}

BigInteger operator-(const BigInteger&amp; a, const BigInteger&amp; b) {
    return a.sub(b);
}

BigInteger operator-=(BigInteger&amp; a, const BigInteger&amp; b) {
    a = a.sub(b);
    return a;
}

BigInteger operator*(const BigInteger&amp; a, const BigInteger&amp; b) {
    return a.mult(b);
}

BigInteger operator*=(BigInteger&amp; a, const BigInteger&amp; b) {
    a = a.mult(b);
    return a;
}

</pre>



</body></html>