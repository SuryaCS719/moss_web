
<!-- saved from url=(0063)http://moss.stanford.edu/results/1/8507876627586/match14-1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/ssriva16/pa6/BigInteger.cpp</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter24/jgracey/pa6/BigInteger.cpp<p></p><pre>// Name: Jacqueline Gracey
// Student ID: jgracey
// Assignment: PA6

#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;ctype.h&gt;
#include "BigInteger.h"

const long BASE = 1000000000;
const int POWER = 9;

using namespace std;

   // Class Constructors &amp; Destructors ----------------------------------------

   // BigInteger()
   // Constructor that creates a new BigInteger in the zero state: 
   // signum=0, digits=().
BigInteger::BigInteger(){
    signum = 0;
    digits = List();
}

   // BigInteger()
   // Constructor that creates a new BigInteger from the long value x.
BigInteger::BigInteger(long x){
    if(x == 0){
        BigInteger();
    }
    else if(x &lt; 0){
        signum = -1;
    }
    else{
        signum = 1;
    }
    digits = List();
    digits.insertAfter(x);
}

   // BigInteger()
   // Constructor that creates a new BigInteger from the string s.
   // Pre: s is a non-empty string consisting of (at least one) base 10 digit
   // {0,1,2,3,4,5,6,7,8,9}, and an optional sign {+,-} prefix.
BigInteger::BigInteger(std::string s){
    if (s.empty()) {
        throw std::invalid_argument("BigInteger: Constructor: empty string");
    }

        // Check for sign
    if (s[0] == '+' || s[0] == '-') {
        (s[0] == '+')? signum = 1 : signum = -1;
        s = s.substr(1); // Remove sign character
    } else {
        signum = 1; // Default positive
    }

    // Check if all characters are digits
    for (char c : s) {
        if (!std::isdigit(c)) {
            throw std::invalid_argument("BigInteger: Constructor: non-numeric string");
        }
    }
    
<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/1/8507876627586/match14-0.html#1" target="0"><img src="./tm_1_6.gif" alt="other" border="0" align="left"></a>

    bool temp = false;
    for (int i = s.length() - POWER; ; i -= POWER) {
        if (i &lt; 0) {
            digits.insertAfter(stol(s.substr(0, i + POWER)));
            temp = true;
        }
        else if (i == 0) {
            digits.insertAfter(stol(s.substr(i, POWER)));
            temp = true;
        }
        else {
            digits.insertAfter(stol(s.substr(i, POWER)));
        }
        if (temp) {
            break;
        }
    }
}

   // BigInteger()
   // Constructor that creates a copy of N.
BigInteger::BigInteger(const BigInteger&amp; N){
    this-&gt;signum = N.signum;
    this-&gt;digits = N.digits;
}

   // Access functions --------------------------------------------------------

   // sign()
   // Returns -1, 1 or 0 according to whether this BigInteger is positive, 
   // negative or 0, respectively.
int BigInteger::sign() const{
</font><a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/1/8507876627586/match14-0.html#2" target="0"><img src="./tm_2_5.gif" alt="other" border="0" align="left"></a>

    return signum;
}

   // compare()
   // Returns -1, 1 or 0 according to whether this BigInteger is less than N,
   // greater than N or equal to N, respectively.
int BigInteger::compare(const BigInteger&amp; N) const{
    // simple case, compare signs
    if (this-&gt;signum &gt; N.signum) {
        return 1;
    }
    else if (this-&gt;signum &lt; N.signum) {
        return -1;
    }
    else if (this-&gt;signum == 0 &amp;&amp; N.signum == 0) {
        return 0;
    }
    
    // same sign, do checks
    List A = this-&gt;digits;
    List B = N.digits;

    // both positive
    if (this-&gt;signum == 1 &amp;&amp; N.signum == 1) {
        // longer list is larger
        if (A.length() != B.length()) {
</font>            if (A.length() &gt; B.length()) {                
                return 1;
            }
            else {
                return -1;
            }
        }    
        A.moveFront();
<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/1/8507876627586/match14-0.html#4" target="0"><img src="./tm_4_4.gif" alt="other" border="0" align="left"></a>

        B.moveFront();
        // same length, compare digits
        for ( ; A.position() &lt; A.length(); A.moveNext(), B.moveNext()) {
            if (A.peekNext() &gt; B.peekNext()) {
                return 1;
            }
            else if (A.peekNext() &lt; B.peekNext()) {
                return -1;
            }
        }
        return 0;
    }    
    // both negative
    else if (this-&gt;signum == -1 &amp;&amp; N.signum == -1) {
        // shorter list is larger
        if (A.length() != B.length()) {
</font>            if (A.length() &gt; B.length()) {
                return -1;
            }
            else {
                return 1;
            }
        }       
        A.moveFront();
<a name="5"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/1/8507876627586/match14-0.html#5" target="0"><img src="./tm_0_4.gif" alt="other" border="0" align="left"></a>

        B.moveFront();
        // compare digits
        for ( ; A.position() &lt; A.length(); A.moveNext(), B.moveNext()) {
            if (A.peekNext() &gt; B.peekNext()) {
                return -1;
            }
            else if (A.peekNext() &lt; B.peekNext()) {
                return 1;
            }
        }
        return 0;
    }
    return 0;
}

   // Manipulation procedures -------------------------------------------------

   // makeZero()
   // Re-sets this BigInteger to the zero state.
void BigInteger::makeZero(){
    signum = 0;
    digits.clear();
}

   // negate()
   // If this BigInteger is zero, does nothing, otherwise reverses the sign of 
   // this BigInteger positive &lt;--&gt; negative. 
void BigInteger::negate(){
</font>    if(signum == 0){
        return;
    }
    else if(signum == 1){
        signum = -1;
        return;
    }
    else{
        signum = 1;
        return;
    }
}

// Helper functions:
<a name="6"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/1/8507876627586/match14-0.html#6" target="0"><img src="./tm_1_4.gif" alt="other" border="0" align="left"></a>

void sumList(List&amp; S, List A, List B, int sign) {
    S.clear();
    B.moveFront();
    while (B.position() &lt; B.length()) {
        B.setAfter(sign * B.peekNext());
        B.moveNext();
    }
    
    A.moveBack();
    B.moveBack();
    while (A.position() &gt; 0 &amp;&amp; B.position() &gt; 0) {
</font>        S.insertAfter(A.peekPrev() + B.peekPrev());
        A.movePrev();
        B.movePrev();
    }
    while (A.position() &gt; 0) {
        S.insertAfter(A.peekPrev());
<a name="8"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/1/8507876627586/match14-0.html#8" target="0"><img src="./tm_3_2.gif" alt="other" border="0" align="left"></a>

        A.movePrev();
    }
    while(B.position() &gt; 0) {
        S.insertAfter(B.peekPrev());
        B.movePrev();
    }

    S.moveFront();
    while (S.front() == 0 &amp;&amp; S.length() &gt; 1) {
</font>        S.eraseAfter();
    }
}

void negateList(List&amp; L) {
    L.moveFront();
    while (L.position() &lt; L.length()) {
        L.setAfter(-1 * L.peekNext());
        L.moveNext();
    }
}

void shiftList(List&amp; L, int p) {
    L.moveBack();
    for (int i = 0; i &lt; p; i++) {
        L.insertAfter(0);
    }
}

//Normalize list for Arithmetic functions
int normalizeList(List&amp; L) {
<a name="7"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/1/8507876627586/match14-0.html#7" target="0"><img src="./tm_2_3.gif" alt="other" border="0" align="left"></a>

    if (L.front() == 0) {
        return 0;
    }

    int sign = 1;
    if (L.front() &lt; 0) {
        negateList(L);
        sign = -1;
    }

    L.moveBack();
    ListElement E = 0;
    int carry = 0;
    while (L.position() &gt; 0) {
        E = L.peekPrev();
        if (E &lt; 0) {
            E += BASE + carry;
</font>            L.setBefore(E);
            carry = -1;
        }
        else {
            E += carry;
            carry = 0;
            if (E &gt;= BASE) {
                carry = E / BASE;
<a name="9"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/1/8507876627586/match14-0.html#9" target="0"><img src="./tm_4_1.gif" alt="other" border="0" align="left"></a>

                E = E % BASE;
            }
            L.setBefore(E);
        }
        L.movePrev();
    }
    if (carry != 0) {
        L.moveFront();
        L.insertAfter(carry);
    }
    return sign;
}

// Multiply List by a scalar
void scalarMultList(List&amp; L, ListElement E) {
</font><a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/1/8507876627586/match14-0.html#3" target="0"><img src="./tm_3_5.gif" alt="other" border="0" align="left"></a>

    L.moveFront();
    while (L.position() &lt; L.length()) {
        L.setAfter(L.peekNext() * E);
        L.moveNext();
    }
}


   // BigInteger Arithmetic operations ----------------------------------------

   // add()
   // Returns a BigInteger representing the sum of this and N.
BigInteger BigInteger::add(const BigInteger&amp; N) const{
    BigInteger S;
    List sum;
    List A = this-&gt;digits;
    List B = N.digits;

    if (this-&gt;signum &lt; 0) {
        negateList(A);
    }
    if (N.signum &lt; 0) {
        negateList(B);
    }
    sumList(sum, A, B, 1);
    S.signum = normalizeList(sum);
</font>    S.digits = sum;

    return S;
}

  // Returns a BigInteger representing the difference of this and N.
BigInteger BigInteger::sub(const BigInteger&amp; N) const{
    BigInteger D;
<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/1/8507876627586/match14-0.html#0" target="0"><img src="./tm_0_15.gif" alt="other" border="0" align="left"></a>

    BigInteger sub = N;

    negateList(sub.digits);
    D = this-&gt;add(sub);
    
    return D;
}

 // mult()
// Returns a BigInteger representing the product of this and N. 
BigInteger BigInteger::mult(const BigInteger&amp; N) const{
    BigInteger biProduct;
    if (this-&gt;signum == 0 || N.signum == 0){
        return biProduct;
    }
    List product;
    product.insertAfter(0);
    List L;
    List L2 = N.digits;

    L2.moveBack();
    int shift = 0;
    while (L2.position() &gt; 0) {
        L = this-&gt;digits;
        scalarMultList(L, L2.peekPrev());
        shiftList(L, shift);
        
        List productCopy = product;
        sumList(product, productCopy, L, 1);
        normalizeList(product);

        L2.movePrev();
        shift++;
    }

    biProduct.digits = product;
    if (this-&gt;signum == N.signum) {
        biProduct.signum = 1;
    }
    else {
        biProduct.signum = -1;
    }

    return biProduct;
}

// Other Functions

// to_string()
   // Returns a string representation of this BigInteger consisting of its
   // base 10 digits. If this BigInteger is negative, the returned string 
   // will begin with a negative sign '-'. If this BigInteger is zero, the
   // returned string will consist of the character '0' only.
std::string BigInteger::to_string() {
    string out = "";
    if (this-&gt;signum == 0) {
        return "0";
    }
    else if (signum == -1) {
        out += "-";
    }

    digits.moveFront();
    while (digits.front() == 0 &amp;&amp; digits.length() &gt; 1) {
        digits.eraseAfter();
    }

    for (digits.moveFront(); digits.position() &lt; digits.length(); digits.moveNext()) {
        string A = std::to_string(digits.peekNext());
        string B = "";
        while ((int)(B.length() + A.length()) &lt; POWER &amp;&amp; digits.position() != 0) {
            B += '0';
</font>        }
        out += (B + A);
    }

    return out;
}


// Overriden Operators
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, BigInteger N) {
    return stream &lt;&lt; N.BigInteger::to_string();
}

bool operator==(const BigInteger&amp; A, const BigInteger&amp; B) {
    if (A.compare(B) == 0) {
        return true;
    }
    return false;
}

bool operator&lt;(const BigInteger&amp; A, const BigInteger&amp; B) {
    if (A.compare(B) == -1) {
        return true;
    }
    return false;
}

bool operator&lt;=(const BigInteger&amp; A, const BigInteger&amp; B) {
    if (A.compare(B) &lt;= 0) {
        return true;
    }
    return false;
}

bool operator&gt;(const BigInteger&amp; A, const BigInteger&amp; B) {
    if (A.compare(B) == 1) {
        return true;
    }
    return false;
}

bool operator&gt;=(const BigInteger&amp; A, const BigInteger&amp; B) {
    if (A.compare(B) &gt;= 0) {
        return true;
    }
    return false;
}

BigInteger operator+(const BigInteger&amp; A, const BigInteger&amp; B) {
    return A.BigInteger::add(B);
}

BigInteger operator+=(BigInteger&amp; A, const BigInteger&amp; B) {
    A = A.BigInteger::add(B);
    return A;
}

BigInteger operator-(const BigInteger&amp; A, const BigInteger&amp; B) {
    return A.BigInteger::sub(B);
}

BigInteger operator-=(BigInteger&amp; A, const BigInteger&amp; B) {
    A = A.BigInteger::sub(B);
    return A;
}

BigInteger operator*(const BigInteger&amp; A, const BigInteger&amp; B) {
    return A.BigInteger::mult(B);
}

BigInteger operator*=(BigInteger&amp; A, const BigInteger&amp; B) {
    A = A.BigInteger::mult(B);
    return A;
}</pre>



</body></html>