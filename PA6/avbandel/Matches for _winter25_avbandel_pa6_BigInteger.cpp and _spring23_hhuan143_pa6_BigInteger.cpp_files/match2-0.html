
<!-- saved from url=(0062)http://moss.stanford.edu/results/9/2568948074217/match2-0.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/avbandel/pa6/BigInteger.cpp</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter25/avbandel/pa6/BigInteger.cpp<p></p><pre>/*
 * Bayo Bandele
 * avbandel
 * 2025 Winter CSE101 PA#6
 * BigInteger.cpp
 * runs the BigInteger ADT for doing operations on large integers.
 */

#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;stdlib.h&gt;
#include "BigInteger.h"
#include "List.h"
#include &lt;ctype.h&gt;
#include &lt;algorithm&gt;

using namespace std;

<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/9/2568948074217/match2-1.html#3" target="1"><img src="./tm_3_2.gif" alt="other" border="0" align="left"></a>

const long base = 1000000000; // Base for the BigInteger representation
const int power = 9;          // Power of 10 for the base

// Default constructor initializes BigInteger to zero state
BigInteger::BigInteger() {
signum = 0;
List digits;
// std::cout &lt;&lt; "Default constructor called. signum = " &lt;&lt; signum &lt;&lt; std::endl;
}

// Constructor from a long integer
BigInteger::BigInteger(long x) {
if (x &gt; 0) {
signum = 1;
} else if (x &lt; 0) {
signum = -1;
x = abs(x); // No need for std::abs now
</font>} else {
signum = 0;
digits.insertBefore(0);
// std::cout &lt;&lt; "Zero initialization. signum = " &lt;&lt; signum &lt;&lt; std::endl;
return;
}

string str = std::to_string(x); // No need for std::to_string now
while (true) {
if (str.length() &lt;= power) {
digits.insertAfter(stol(str) % base); 
// std::cout &lt;&lt; "Inserted last chunk: " &lt;&lt; stol(str) % base &lt;&lt; std::endl;
return;
} else {
digits.insertAfter(stol(str) % base);
// std::cout &lt;&lt; "Inserted chunk: " &lt;&lt; stol(str) % base &lt;&lt; std::endl;
str = str.substr(0, (str.length() - power));
}
}
}

// Constructor from a string
BigInteger::BigInteger(string s) {
<a name="5"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/9/2568948074217/match2-1.html#5" target="1"><img src="./tm_0_2.gif" alt="other" border="0" align="left"></a>

if (s[0] == '-' || s[0] == '+') {
for (unsigned int i = 1; i &lt; s.length(); i++) {
if (!isdigit(s[i])) {
throw invalid_argument("BigInteger: Constructor: non-numeric string");
</font>}
}
if (s[0] == '-') {
signum = -1;
} else {
signum = 1;
}
reverse(s.begin() + 1, s.end());
string temp = "";
<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/9/2568948074217/match2-1.html#4" target="1"><img src="./tm_4_2.gif" alt="other" border="0" align="left"></a>

for (unsigned int i = 1; i &lt; s.length(); i++) {
temp += s[i];
if (i % power == 0) {
reverse(temp.begin(), temp.end());
digits.insertBefore(stol(temp));
</font><a name="6"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/9/2568948074217/match2-1.html#6" target="1"><img src="./tm_1_1.gif" alt="other" border="0" align="left"></a>

digits.moveFront();
// std::cout &lt;&lt; "Inserted chunk from string: " &lt;&lt; stol(temp) &lt;&lt; std::endl;
temp = "";
} else if (i == s.length() - 1) {
reverse(temp.begin(), temp.end());
digits.insertBefore(stol(temp));
</font>// std::cout &lt;&lt; "Inserted last chunk from string: " &lt;&lt; stol(temp) &lt;&lt; std::endl;
temp = "";
}
}
} else {
for (unsigned int i = 0; i &lt; s.length(); i++) {
if (!isdigit(s[i])) {
throw invalid_argument("BigInteger: Constructor: non-numeric string");
}
}
reverse(s.begin(), s.end());
string temp = "";
<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/9/2568948074217/match2-1.html#2" target="1"><img src="./tm_2_2.gif" alt="other" border="0" align="left"></a>

for (unsigned int i = 0; i &lt; s.length(); i++) {
temp += s[i];
if ((i + 1) % power == 0) {
reverse(temp.begin(), temp.end());
digits.insertBefore(stol(temp));
</font><a name="7"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/9/2568948074217/match2-1.html#7" target="1"><img src="./tm_2_1.gif" alt="other" border="0" align="left"></a>

digits.moveFront();
// : Inserted chunk from string
// std::cout &lt;&lt; "Inserted chunk from string: " &lt;&lt; stol(temp) &lt;&lt; std::endl;
temp = "";
} else if (i == s.length() - 1) {
reverse(temp.begin(), temp.end());
digits.insertBefore(stol(temp));
</font>// : Inserted last chunk from string
// std::cout &lt;&lt; "Inserted last chunk from string: " &lt;&lt; stol(temp) &lt;&lt; std::endl;
<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/9/2568948074217/match2-1.html#0" target="1"><img src="./tm_0_56.gif" alt="other" border="0" align="left"></a>

temp = "";
}
}
signum = 1;
}

digits.moveFront();
while (digits.position() &lt; digits.length()) {
if (digits.position() == digits.length() - 1) {
if (digits.peekNext() == 0) {
signum = 0;
digits.insertBefore(0);
// : Zero state detected
// std::cout &lt;&lt; "Zero state detected. signum = " &lt;&lt; signum &lt;&lt; std::endl;
}
}
if (digits.moveNext() == 0) {
digits.eraseBefore();
// : Erased leading zero
// std::cout &lt;&lt; "Erased leading zero" &lt;&lt; std::endl;
} else {
break;
}
}
}

// Copy constructor
BigInteger::BigInteger(const BigInteger&amp; N) {
this-&gt;signum = N.signum;
this-&gt;digits = N.digits;
// : Copy constructor called
// std::cout &lt;&lt; "Copy constructor called. signum = " &lt;&lt; signum &lt;&lt; std::endl;
}

// Access functions

// Returns the sign of the BigInteger
int BigInteger::sign() const {
// : sign() called
// std::cout &lt;&lt; "sign() called. signum = " &lt;&lt; signum &lt;&lt; std::endl;
return signum;
}

// Compares two BigIntegers
int BigInteger::compare(const BigInteger&amp; N) const {
List A = this-&gt;digits;
List B = N.digits;

if (this-&gt;signum != N.signum) {
if (this-&gt;signum &gt; N.signum) {
// : compare() result
// std::cout &lt;&lt; "compare() result: 1" &lt;&lt; std::endl;
return 1;
} else {
// : compare() result
// std::cout &lt;&lt; "compare() result: -1" &lt;&lt; std::endl;
return -1;
}
} else {
if (this-&gt;signum == 0) {
// : compare() result
// std::cout &lt;&lt; "compare() result: 0" &lt;&lt; std::endl;
return 0;
} else if (this-&gt;signum == 1) {
if (A.length() &gt; B.length()) {
// : compare() result
// std::cout &lt;&lt; "compare() result: 1" &lt;&lt; std::endl;
return 1;
} else if (A.length() &lt; B.length()) {
// : compare() result
// std::cout &lt;&lt; "compare() result: -1" &lt;&lt; std::endl;
return -1;
} else {
A.moveFront();
B.moveFront();
while (A.position() &lt; A.length()) {
if (A.peekNext() &gt; B.peekNext()) {
// : compare() result
// std::cout &lt;&lt; "compare() result: 1" &lt;&lt; std::endl;
return 1;
} else if (A.peekNext() &lt; B.peekNext()) {
// : compare() result
// std::cout &lt;&lt; "compare() result: -1" &lt;&lt; std::endl;
return -1;
} else {
A.moveNext();
B.moveNext();
}
}
// : compare() result
// std::cout &lt;&lt; "compare() result: 0" &lt;&lt; std::endl;
return 0;
}
} else {
if (A.length() &gt; B.length()) {
// : compare() result
// std::cout &lt;&lt; "compare() result: -1" &lt;&lt; std::endl;
return -1;
} else if (A.length() &lt; B.length()) {
// : compare() result
// std::cout &lt;&lt; "compare() result: 1" &lt;&lt; std::endl;
return 1;
} else {
A.moveFront();
B.moveFront();
while (A.position() &lt; A.length()) {
if (A.peekNext() &gt; B.peekNext()) {
// : compare() result
// std::cout &lt;&lt; "compare() result: -1" &lt;&lt; std::endl;
return -1;
} else if (A.peekNext() &lt; B.peekNext()) {
// : compare() result
// std::cout &lt;&lt; "compare() result: 1" &lt;&lt; std::endl;
return 1;
} else {
A.moveNext();
B.moveNext();
}
}
// : compare() result
// std::cout &lt;&lt; "compare() result: 0" &lt;&lt; std::endl;
return 0;
}
}
}
}

// Manipulation procedures

// Resets the BigInteger to the zero state
void BigInteger::makeZero() {
digits.clear();
signum = 0;
// : makeZero() called
// std::cout &lt;&lt; "makeZero() called. signum = " &lt;&lt; signum &lt;&lt; std::endl;
}

// Negates the BigInteger
void BigInteger::negate() {
if (signum == 0) {
return;
}
if (signum == 1) {
signum = -1;
} else {
signum = 1;
}
// : negate() called
// std::cout &lt;&lt; "negate() called. New signum = " &lt;&lt; signum &lt;&lt; std::endl;
}

// Helper function to negate a List
void negateList(List&amp; L) {
L.moveFront();
while (L.position() &lt; L.length()) {
long x = L.moveNext();
if (x != 0) {
L.eraseBefore();
L.insertBefore(x * -1);
// : Negated list element
// std::cout &lt;&lt; "Negated list element: " &lt;&lt; x * -1 &lt;&lt; std::endl;
}
}
}

// Helper function to sum two Lists
void sumList(List&amp; S, List A, List B, int sgn) {
ListElement x, y;
S.clear();
A.moveBack();
B.moveBack();
while (A.position() &gt; 0 &amp;&amp; B.position() &gt; 0) {
x = A.movePrev();
y = B.movePrev();
S.insertAfter(x + (y * sgn));
// : Summed list elements
// std::cout &lt;&lt; "Summed list elements: " &lt;&lt; x &lt;&lt; " + " &lt;&lt; y * sgn &lt;&lt; " = " &lt;&lt; x + (y * sgn) &lt;&lt; std::endl;
}
while (A.position() &gt; 0) {
x = A.movePrev();
S.insertAfter(x);
// : Added remaining element from A
// std::cout &lt;&lt; "Added remaining element from A: " &lt;&lt; x &lt;&lt; std::endl;
}
while (B.position() &gt; 0) {
y = B.movePrev();
S.insertAfter(y * sgn);
// : Added remaining element from B
// std::cout &lt;&lt; "Added remaining element from B: " &lt;&lt; y * sgn &lt;&lt; std::endl;
}
}

// Helper function to normalize a List
int normalizeList(List&amp; L) {
int sgn;
ListElement q, r;
ListElement num, carry = 0;

L.moveBack();
while (L.position() &gt; 0) {
num = L.movePrev();
num += carry;
q = num / base;
r = num % base;

if (r &lt; 0) {
num = r + base;
carry = q - 1;
} else {
num = r;
carry = q;
}
L.setAfter(num);
if (L.position() == 0) {
if (carry &gt; 0) {
L.insertBefore(0);
// : Inserted carry
// std::cout &lt;&lt; "Inserted carry: " &lt;&lt; carry &lt;&lt; std::endl;
} else if (carry &lt; 0) {
L.insertBefore(carry);
// : Inserted negative carry
// std::cout &lt;&lt; "Inserted negative carry: " &lt;&lt; carry &lt;&lt; std::endl;
break;
}
}
}

L.moveFront();
while (L.position() &lt; L.length()) {
if (L.moveNext() == 0) {
L.eraseBefore();
// : Erased leading zero
// std::cout &lt;&lt; "Erased leading zero" &lt;&lt; std::endl;
} else {
break;
}
}

if (L.length() != 0) {
if (L.front() &gt; 0) {
sgn = 1;
} else if (L.front() &lt; 0) {
sgn = -1;
negateList(L);
normalizeList(L);
}
} else {
sgn = 0;
}
// : normalizeList() result
// std::cout &lt;&lt; "normalizeList() result: sgn = " &lt;&lt; sgn &lt;&lt; std::endl;
return sgn;
}

// Helper function to shift a List
void shiftList(List&amp; L, int p) {
L.moveBack();
for (int i = 0; i &lt; p; i++) {
L.insertBefore(0);
// : Shifted list
// std::cout &lt;&lt; "Shifted list by " &lt;&lt; p &lt;&lt; " positions" &lt;&lt; std::endl;
}
}

// Helper function to multiply a List by a scalar
void scalarMultList(List&amp; L, ListElement m) {
if (m != 1) {
L.moveFront();
while (L.position() &lt; L.length()) {
ListElement x = L.moveNext();
if (x != 0) {
L.eraseBefore();
L.insertBefore(x * m);
// : Scalar multiplied list element
// std::cout &lt;&lt; "Scalar multiplied list element: " &lt;&lt; x &lt;&lt; " * " &lt;&lt; m &lt;&lt; " = " &lt;&lt; x * m &lt;&lt; std::endl;
}
}
}
}

// Arithmetic operations

// Adds two BigIntegers
BigInteger BigInteger::add(const BigInteger&amp; N) const {
BigInteger sum;
int sign;

List A = this-&gt;digits;
List B = N.digits;
List&amp; L = sum.digits;

if (this-&gt;signum == N.signum) {
sumList(L, A, B, 1);
normalizeList(L);
sum.signum = this-&gt;signum;
} else {
sumList(L, A, B, -1);
sign = normalizeList(L);
sum.signum = sign * this-&gt;signum;
}
// : add() result
// std::cout &lt;&lt; "add() result: " &lt;&lt; sum.to_string() &lt;&lt; std::endl;
return sum;
}

// Subtracts two BigIntegers
BigInteger BigInteger::sub(const BigInteger&amp; N) const {
BigInteger A = BigInteger(N);
A.negate();
BigInteger diff = this-&gt;add(A);
// : sub() result
// std::cout &lt;&lt; "sub() result: " &lt;&lt; diff.to_string() &lt;&lt; std::endl;
return diff;
}

// Multiplies two BigIntegers
BigInteger BigInteger::mult(const BigInteger&amp; N) const {
int col = 0;
ListElement b;
BigInteger scalarM;
BigInteger prod;

List A = this-&gt;digits;
List B = N.digits;
List C = A;

prod.signum = this-&gt;signum * N.signum;

if (this-&gt;signum == 0 || N.signum == 0) {
prod = BigInteger(0);
// : mult() result (zero)
// std::cout &lt;&lt; "mult() result (zero): " &lt;&lt; prod.to_string() &lt;&lt; std::endl;
return prod;
}

B.moveBack();
while (B.position() &gt; 0) {
C = A;
b = B.movePrev();
if (b == 0) {
C.clear();
} else {
scalarMultList(C, b);
normalizeList(C);
shiftList(C, col);
scalarM.digits = C;
scalarM.signum = this-&gt;signum;
prod += scalarM;
normalizeList(C);
}
col++;
}
prod.signum = this-&gt;signum * N.signum;
</font>// : mult() result
// std::cout &lt;&lt; "mult() result: " &lt;&lt; prod.to_string() &lt;&lt; std::endl;
return prod;
}

// Other Functions

// Converts the BigInteger to a string
string BigInteger::to_string() {
if (digits.length() == 0) {
string s = "0";
// : to_string() result (zero)
// std::cout &lt;&lt; "to_string() result (zero): " &lt;&lt; s &lt;&lt; std::endl;
return s;
}
digits.moveFront();
if (digits.peekNext() == 0) {
string s = "0";
// : to_string() result (zero)
// std::cout &lt;&lt; "to_string() result (zero): " &lt;&lt; s &lt;&lt; std::endl;
return s;
} else {
<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/9/2568948074217/match2-1.html#1" target="1"><img src="./tm_1_4.gif" alt="other" border="0" align="left"></a>

string s = "";
if (signum == -1) {
s += "-";
}
for (digits.moveFront(); digits.position() &lt; digits.length(); digits.moveNext()) {
int len = std::to_string(digits.peekNext()).length();
if (len &lt; power &amp;&amp; digits.position() != 0) {
for (int i = 0; i &lt; (power - len); i++) {
s += "0";
}
}
s += std::to_string(digits.peekNext());
</font>}
// : to_string() result
// std::cout &lt;&lt; "to_string() result: " &lt;&lt; s &lt;&lt; std::endl;
return s;
}
}

// Overloaded Operators

// Outputs the BigInteger to a stream
ostream&amp; operator&lt;&lt;(ostream&amp; stream, BigInteger N) {
// : operator&lt;&lt; called
// std::cout &lt;&lt; "operator&lt;&lt; called" &lt;&lt; std::endl;
return stream &lt;&lt; N.BigInteger::to_string();
}

// Equality operator
bool operator==(const BigInteger&amp; A, const BigInteger&amp; B) {
// : operator== called
// std::cout &lt;&lt; "operator== called" &lt;&lt; std::endl;
return A.compare(B) == 0;
}

// Less than operator
bool operator&lt;(const BigInteger&amp; A, const BigInteger&amp; B) {
// : operator&lt; called
// std::cout &lt;&lt; "operator&lt; called" &lt;&lt; std::endl;
return A.compare(B) &lt; 0;
}

// Less than or equal to operator
bool operator&lt;=(const BigInteger&amp; A, const BigInteger&amp; B) {
// : operator&lt;= called
// std::cout &lt;&lt; "operator&lt;= called" &lt;&lt; std::endl;
return A.compare(B) &lt;= 0;
}

// Greater than operator
bool operator&gt;(const BigInteger&amp; A, const BigInteger&amp; B) {
// : operator&gt; called
// std::cout &lt;&lt; "operator&gt; called" &lt;&lt; std::endl;
return A.compare(B) &gt; 0;
}

// Greater than or equal to operator
bool operator&gt;=(const BigInteger&amp; A, const BigInteger&amp; B) {
// : operator&gt;= called
// std::cout &lt;&lt; "operator&gt;= called" &lt;&lt; std::endl;
return A.compare(B) &gt;= 0;
}

// Addition operator
BigInteger operator+(const BigInteger&amp; A, const BigInteger&amp; B) {
// : operator+ called
// std::cout &lt;&lt; "operator+ called" &lt;&lt; std::endl;
return A.add(B);
}

// Addition assignment operator
BigInteger operator+=(BigInteger&amp; A, const BigInteger&amp; B) {
// : operator+= called
// std::cout &lt;&lt; "operator+= called" &lt;&lt; std::endl;
A = A.add(B);
return A;
}

// Subtraction operator
BigInteger operator-(const BigInteger&amp; A, const BigInteger&amp; B) {
// : operator- called
// std::cout &lt;&lt; "operator- called" &lt;&lt; std::endl;
return A.sub(B);
}

// Subtraction assignment operator
BigInteger operator-=(BigInteger&amp; A, const BigInteger&amp; B) {
// : operator-= called
// std::cout &lt;&lt; "operator-= called" &lt;&lt; std::endl;
A = A.sub(B);
return A;
}

// Multiplication operator
BigInteger operator*(const BigInteger&amp; A, const BigInteger&amp; B) {
// : operator* called
// std::cout &lt;&lt; "operator* called" &lt;&lt; std::endl;
return A.mult(B);
}

// Multiplication assignment operator
BigInteger operator*=(BigInteger&amp; A, const BigInteger&amp; B) {
// : operator*= called
// std::cout &lt;&lt; "operator*= called" &lt;&lt; std::endl;
A = A.mult(B);
return A;
}
</pre>



</body></html>