
<!-- saved from url=(0062)http://moss.stanford.edu/results/9/2568948074217/match2-1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/avbandel/pa6/BigInteger.cpp</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/spring23/hhuan143/pa6/BigInteger.cpp<p></p><pre>/*
*James Huang, hhuan143
*2023 spring CSE101 PA#6
*BigInteger.cpp
*writes the functions of BigInteger.cpp
*/
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;stdexcept&gt;
#include&lt;stdlib.h&gt;
#include"BigInteger.h"
#include"List.h"
#include &lt;ctype.h&gt;
#include &lt;algorithm&gt; 

<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/9/2568948074217/match2-0.html#3" target="0"><img src="./tm_3_2.gif" alt="other" border="0" align="left"></a>

const long base = 1000000000;
const int power = 9;

BigInteger::BigInteger(){
	signum = 0;
	List digits;
}

BigInteger::BigInteger(long x){
	if (x &gt; 0){
		signum = 1;
	}else if (x &lt; 0){
		signum = -1;
		x = std::abs(x);
</font>	}else{
		signum = 0;
		digits.insertBefore(0);
		return;
	}
	//digits.moveFront();
	std::string str = "";
	str = std::to_string(x);
	//std::cout&lt;&lt;str&lt;&lt;std::endl;
	//std::cout &lt;&lt; std::stol(str) &lt;&lt; std::endl;
	//std::cout&lt;&lt;"meow"&lt;&lt;std::endl;
	while(1){
		if (str.length() &lt;= power){
			//std::cout&lt;&lt;"meow"&lt;&lt;std::endl;
			digits.insertAfter(std::stol(str) % base);
			//std::cout&lt;&lt;"long"&lt;&lt;digits&lt;&lt;std::endl;
			return;
		}else{
			digits.insertAfter(std::stol(str) % base);
			str = str.substr(0, (str.length() - power));
			//std::cout&lt;&lt;str&lt;&lt;std::endl;
		}
	}
	//std::cout&lt;&lt;digits&lt;&lt;std::endl;
}
// BigInteger()
// Constructor that creates a new BigInteger from the string s.
// Pre: s is a non-empty string consisting of (at least one) base 10 digit
// {0,1,2,3,4,5,6,7,8,9}, and an optional sign {+,-} prefix.
// 
BigInteger::BigInteger(std::string s){
	//std::cout &lt;&lt; "meow" &lt;&lt; std::endl;
	// BigInteger I = BigInteger(string)
<a name="5"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/9/2568948074217/match2-0.html#5" target="0"><img src="./tm_0_2.gif" alt="other" border="0" align="left"></a>

	if (s[0] == '-' || s[0] == '+'){
		for (unsigned int i = 1; i &lt; s.length(); i++){
			if (!isdigit(s[i])){
				throw std::invalid_argument("BigInteger: Constructor: non-numeric string");
</font>			}
		}
		if (s[0] == '-'){
			signum = -1;
		}else{
			signum = 1;
		}
		reverse(s.begin() + 1, s.end());// +123 -&gt; +321
		std::string temp = "";
<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/9/2568948074217/match2-0.html#4" target="0"><img src="./tm_4_2.gif" alt="other" border="0" align="left"></a>

		for (unsigned int i = 1; i &lt; s.length(); i++){
			temp += s[i];
			if(i % power == 0){
				reverse(temp.begin(), temp.end()); // 123 -&gt; 321
				digits.insertBefore(std::stol(temp));
</font><a name="6"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/9/2568948074217/match2-0.html#6" target="0"><img src="./tm_1_1.gif" alt="other" border="0" align="left"></a>

				digits.moveFront();
				temp = "";
			}
			else if (i == s.length() - 1){
				reverse(temp.begin(), temp.end());
				digits.insertBefore(std::stol(temp));
</font>				temp = "";
			}
		}
	}else{
		for (unsigned int i = 0; i &lt; s.length(); i++){
			if (!isdigit(s[i])){
				throw std::invalid_argument("BigInteger: Constructor: non-numeric string");
			}
		}
		reverse(s.begin(), s.end());
		std::string temp = "";
<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/9/2568948074217/match2-0.html#2" target="0"><img src="./tm_2_2.gif" alt="other" border="0" align="left"></a>

		for (unsigned int i = 0; i &lt; s.length(); i++){
			temp += s[i];
			if((i + 1) % power == 0){
				reverse(temp.begin(), temp.end());
				//std::cout &lt;&lt; temp &lt;&lt; std::endl;
				digits.insertBefore(std::stol(temp));
</font><a name="7"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/9/2568948074217/match2-0.html#7" target="0"><img src="./tm_2_1.gif" alt="other" border="0" align="left"></a>

				digits.moveFront();
				temp = "";
			}
			else if (i == s.length() - 1){
				reverse(temp.begin(), temp.end());
				digits.insertBefore(std::stol(temp));
</font><a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/9/2568948074217/match2-0.html#0" target="0"><img src="./tm_0_55.gif" alt="other" border="0" align="left"></a>

				temp = "";
			}
		}
		signum = 1;
	}
	//00 09 22 12 01
	digits.moveFront();
	while(digits.position() &lt; digits.length()){
		if (digits.position() == digits.length() - 1){
			if (digits.peekNext() == 0){
				signum = 0;
				digits.insertBefore(0);
			}
		}
		if (digits.moveNext() == 0){
			digits.eraseBefore();
		}else{
			break;
		}

	}
}

// BigInteger()
// Constructor that creates a copy of N.
BigInteger::BigInteger(const BigInteger&amp; N){
    this-&gt;signum = N.signum;
    this-&gt;digits = N.digits;
}

// // Access functions --------------------------------------------------------

// sign()
// Returns -1, 1 or 0 according to whether this BigInteger is positive, 
// negative or 0, respectively.
int BigInteger::sign() const{
	return signum;
}

// compare()
// Returns -1, 1 or 0 according to whether this BigInteger is less than N,
// greater than N or equal to N, respectively.
int BigInteger::compare(const BigInteger&amp; N) const{
	List A = this-&gt;digits;
	List B = N.digits;
	//std::cout &lt;&lt; "meow = "&lt;&lt;this-&gt;signum &lt;&lt; std::endl;


	if(this-&gt;signum != N.signum){
		if (this-&gt;signum &gt; N.signum){
			return 1;
		}else{
			return -1;
		}
	}else{
		//std::cout &lt;&lt; "meow = "&lt;&lt;this-&gt;signum &lt;&lt; std::endl;
		if (this-&gt;signum == 0){
			//std::cout &lt;&lt; "meow" &lt;&lt; std::endl;
			return 0;
		}else if (this-&gt;signum == 1){
			//both postivie
			if (A.length() &gt; B.length()){
				return 1;
			}else if(A.length() &lt; B.length()){
				return -1;
			}else{
				A.moveFront();
				B.moveFront();
				//std::cout &lt;&lt; "meow" &lt;&lt; std::endl;
				while(A.position() &lt; A.length()){
					//std::cout &lt;&lt; "A = "&lt;&lt; A.peekNext() &lt;&lt; std::endl;
					//std::cout &lt;&lt; "B = "&lt;&lt; B.peekNext() &lt;&lt; std::endl;
					if (A.peekNext() &gt; B.peekNext()){
						return 1;
					}else if(A.peekNext() &lt; B.peekNext()){
						return -1;
					}else{
						A.moveNext();
						B.moveNext();
					}
				}
				return 0;
			}
		}else{
			// both negative
			if (A.length() &gt; B.length()){
				return -1;
			}else if(A.length() &lt; B.length()){
				return 1;
			}else{
				A.moveFront();
				B.moveFront();
				while(A.position() &lt; A.length()){
					if (A.peekNext() &gt; B.peekNext()){
						return -1;
					}else if (A.peekNext() &lt; B.peekNext()){
						return 1;
					}else{
						A.moveNext();
						B.moveNext();
					}
				}
				return 0;
			}

		}
	}
}

// // Manipulation procedures -------------------------------------------------

// makeZero()
// Re-sets this BigInteger to the zero state.
void BigInteger::makeZero(){
	digits.clear();
	signum = 0;
}

// negate()
// If this BigInteger is zero, does nothing, otherwise reverses the sign of 
// this BigInteger positive &lt;--&gt; negative. 
void BigInteger::negate(){
	if (signum == 0){
		return;
	}
	if (signum == 1){
		signum = -1;
	}else{
		signum = 1;
	}
}

// negateList()
// Changes the sign of each integer in List L. Used by sub().
void negateList(List&amp; L){
    // iterate through the list of L
    L.moveFront();
    while(L.position() &lt; L.length()){
    	long x = L.moveNext();
    	if (x != 0){
    		L.eraseBefore();
    		L.insertBefore(x * -1);
    	}

    }
    //cout &lt;&lt; digits &lt;&lt; endl;
        // set a variable "x" of type ListElement to get the data of the next element of L  
        // if x is 0 then continue
        // then delete the element
        // instead insert the same data "x" but negative
}

// sumList()
// Overwrites the state of S with A + sgn*B (considered as vectors).
// Used by both sum() and sub().
void sumList(List&amp; S, List A, List B, int sgn){
    ListElement x, y;
    S.clear();
    A.moveBack();
    B.moveBack();
    //std::cout &lt;&lt; "sumList A = " &lt;&lt; A &lt;&lt; std::endl;
	//std::cout &lt;&lt; "sumList B = " &lt;&lt; B &lt;&lt; std::endl;
    while (A.position() &gt; 0 &amp;&amp; B.position() &gt; 0){
    	x = A.movePrev();
    	y = B.movePrev();
    	//std::cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; std::endl;
    	//std::cout &lt;&lt; "y = " &lt;&lt; y &lt;&lt; std::endl;
    	//std::cout &lt;&lt; "x +y*sign = " &lt;&lt; x+sgn*y &lt;&lt; std::endl;
    	S.insertAfter(x + (y * sgn));

    }
    while (A.position() &gt; 0){
    	x = A.movePrev();
    	S.insertAfter(x);
    }
    while (B.position() &gt; 0){
   	 	y = B.movePrev();
   	 	S.insertAfter(y * sgn);
    }

}

// normalizeList()
// Performs carries from right to left (least to most significant 
// digits), then returns the sign of the resulting integer. Used 
// by add(), sub() and mult().
int normalizeList(List&amp; L){
	int sgn;
	ListElement q, r;
	ListElement num, carry = 0;
	
	L.moveBack(); 
	while (L.position() &gt; 0){
		num = L.movePrev();
		num += carry;
		q = num / base; //498 / 100 = 4
		r = num % base; //498 % 100 = 98

		if (r &lt; 0){
			num = r + base;
			carry = q - 1;
		}else{
			num = r;
			carry = q;
		}
		//std::cout &lt;&lt; "L = " &lt;&lt; L &lt;&lt; std::endl;
		L.setAfter(num);
		//std::cout &lt;&lt; "L = " &lt;&lt; L &lt;&lt; std::endl;
		if (L.position() == 0){
			if (carry &gt; 0){
				L.insertBefore(0);
			}else if(carry &lt; 0){
				L.insertBefore(carry);
				break;
			}
		}
	}
	//std::cout &lt;&lt; "normalizeList = " &lt;&lt; L &lt;&lt; std::endl;
	//std::cout &lt;&lt; "meow1 " &lt;&lt; std::endl;
   //delete leading zeros
	L.moveFront();
	while (L.position() &lt; L.length()){
        // eliminate/erase all leading zeros
        if (L.moveNext() == 0){
        	L.eraseBefore();
        }else{
        	break;
        }
	}


	if (L.length() != 0){
		if (L.front() &gt; 0){
			sgn = 1;
		}else if (L.front() &lt; 0){
			sgn = -1;
			negateList(L);
			normalizeList(L);
		}
	}else{
		sgn = 0;
	}
   	return sgn;

}

// shiftList()
// Prepends p zero digits to L, multiplying L by base^p. Used by mult().
void shiftList(List&amp; L, int p){
	L.moveBack();
	for (int i = 0; i &lt; p; i++){
		L.insertBefore(0);
	}
}

// scalarMultList()
// Multiplies L (considered as a vector) by m. Used by mult().
void scalarMultList(List&amp; L, ListElement m){
	if (m != 1){
		L.moveFront();
		while(L.position() &lt; L.length()){
			ListElement x = L.moveNext();
			if (x != 0){
				L.eraseBefore();
				L.insertBefore(x * m);
			}
		}
	}
}


// // BigInteger Arithmetic operations ----------------------------------------

// add()
// Returns a BigInteger representing the sum of this and N.
BigInteger BigInteger::add(const BigInteger&amp; N) const{
	BigInteger sum;
	int sign;

	List A = this-&gt;digits;
    List B = N.digits;
	List&amp; L = sum.digits;

	if (this-&gt;signum == N.signum){
		//std::cout &lt;&lt; "AAAAA in add " &lt;&lt; A &lt;&lt; std::endl;
		//std::cout &lt;&lt; "BBBBB in add" &lt;&lt; B &lt;&lt; std::endl;
		sumList(L, A, B, 1);
		normalizeList(L);
		sum.signum = this-&gt;signum;
	}else{
		//std::cout &lt;&lt; "AAAAA in add " &lt;&lt; A &lt;&lt; std::endl;
		//std::cout &lt;&lt; "BBBBB in add" &lt;&lt; B &lt;&lt; std::endl;
		sumList(L, A, B, -1);
		sign = normalizeList(L);
		sum.signum = sign * this-&gt;signum;
	}
	return sum;
}

// sub()
// Returns a BigInteger representing the difference of this and N.
BigInteger BigInteger::sub(const BigInteger&amp; N) const{
	BigInteger A = BigInteger(N);//copy constructor!!!
	A.negate();
	BigInteger diff = this-&gt;add(A);
	return diff;
}

// mult()
// Returns a BigInteger representing the product of this and N. 
BigInteger BigInteger::mult(const BigInteger&amp; N) const{

	int col = 0;
	ListElement b;
	BigInteger scalarM;
	BigInteger prod;

	List A = this-&gt;digits;
	List B = N.digits;
	List C = A;

	prod.signum = this-&gt;signum * N.signum;

	if (this-&gt;signum == 0 || N.signum == 0){
		prod = BigInteger(0);
		return prod;
	}

	B.moveBack();
	while (B.position() &gt; 0){
		C = A;
		b = B.movePrev();
		if (b == 0){
			C.clear();
		}else{
			scalarMultList(C, b);
			normalizeList(C);
			shiftList(C, col);
			scalarM.digits = C;
			scalarM.signum = this-&gt;signum;
			prod += scalarM;
			normalizeList(C);
		}
		col++;
	}
	prod.signum = this-&gt;signum * N.signum;
</font>	return prod;

}

// Other Functions ---------------------------------------------------------

//to_string()
//Returns a string representation of this BigInteger consisting of its
//base 10 digits. If this BigInteger is negative, the returned string 
//will begin with a negative sign '-'. If this BigInteger is zero, the
//returned string will consist of the character '0' only.
std::string BigInteger::to_string(){
	//std::cout &lt;&lt; digits.length() &lt;&lt; std::endl;
	if (digits.length() == 0){
		//std::cout &lt;&lt; "meow" &lt;&lt; std::endl;
		std::string s = "0";
		return s;
	}
	digits.moveFront();
	if (digits.peekNext() == 0){
		std::string s = "0";
		//std::cout &lt;&lt; s &lt;&lt; std::endl;
		return s;
	}else{
<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/9/2568948074217/match2-0.html#1" target="0"><img src="./tm_1_4.gif" alt="other" border="0" align="left"></a>

		std::string s = "";
		if (signum == -1){
			s += "-";
		}
		for(digits.moveFront(); digits.position() &lt; digits.length(); digits.moveNext()){
			int len = std::to_string(digits.peekNext()).length();
			if (len &lt; power &amp;&amp; digits.position() != 0){
				for (int i = 0; i &lt; (power - len); i++){
					s += "0";
				}
			} 
			s += std::to_string(digits.peekNext());
</font>			
		}

		return s;
	}
}

// Overriden Operators -----------------------------------------------------

// operator&lt;&lt;()
// Inserts string representation of N into stream.
std::ostream&amp; operator&lt;&lt;( std::ostream&amp; stream, BigInteger N ){
	return stream &lt;&lt; N.BigInteger::to_string();
}

// operator==()
// Returns true if and only if A equals B. 
bool operator==( const BigInteger&amp; A, const BigInteger&amp; B ){
	return A.compare(B) == 0;
}

// operator&lt;()
// Returns true if and only if A is less than B. 
bool operator&lt;( const BigInteger&amp; A, const BigInteger&amp; B ){
	return A.compare(B) &lt; 0;
}

// operator&lt;=()
// Returns true if and only if A is less than or equal to B. 
bool operator&lt;=( const BigInteger&amp; A, const BigInteger&amp; B ){
	return A.compare(B) &lt;= 0;
}

// operator&gt;()
// Returns true if and only if A is greater than B. 
bool operator&gt;( const BigInteger&amp; A, const BigInteger&amp; B ){
	return A.compare(B) &gt; 0;
}

// operator&gt;=()
// Returns true if and only if A is greater than or equal to B. 
bool operator&gt;=( const BigInteger&amp; A, const BigInteger&amp; B ){
	return A.compare(B) &gt;= 0;
}

// operator+()
// Returns the sum A+B. 
BigInteger operator+( const BigInteger&amp; A, const BigInteger&amp; B ){
	return A.add(B);
}

// operator+=()
// Overwrites A with the sum A+B. 
BigInteger operator+=( BigInteger&amp; A, const BigInteger&amp; B ){
	A = A.add(B);
	return A;
}

// operator-()
// Returns the difference A-B. 
BigInteger operator-( const BigInteger&amp; A, const BigInteger&amp; B ){
	return A.sub(B);

}

// // operator-=()
// Overwrites A with the difference A-B. 
BigInteger operator-=( BigInteger&amp; A, const BigInteger&amp; B ){
	A = A.sub(B);
	return A;
}

// operator*()
// Returns the product A*B. 
BigInteger operator*( const BigInteger&amp; A, const BigInteger&amp; B ){
	return A.mult(B);
}

// operator*=()
// Overwrites A with the product A*B. 
BigInteger operator*=( BigInteger&amp; A, const BigInteger&amp; B ){
	A = A.mult(B);
	return A;
}


</pre>



</body></html>