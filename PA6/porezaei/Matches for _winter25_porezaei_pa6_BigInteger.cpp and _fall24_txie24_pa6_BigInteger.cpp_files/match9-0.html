
<!-- saved from url=(0062)http://moss.stanford.edu/results/5/6974366091630/match9-0.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/porezaei/pa6/BigInteger.cpp</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter25/porezaei/pa6/BigInteger.cpp<p></p><pre>/*
Name: Pouria Rezaei
CruzID: porezaei
Assignment Name: pa6
*/

#include &lt;cctype&gt;
#include &lt;cmath&gt;
#include &lt;stdexcept&gt;
#include "BigInteger.h"
#include "List.h"
using namespace std;


<a name="5"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/5/6974366091630/match9-1.html#5" target="1"><img src="./tm_0_3.gif" alt="other" border="0" align="left"></a>

const ListElement BASE  = 1000000000;  
const int POWER = 9;          

// Helper Functions

// Remove leading zeros
void delZero(List* L) {
    L-&gt;moveFront();
    while (L-&gt;length() &gt; 0 &amp;&amp; !L-&gt;peekNext()) {
        L-&gt;eraseAfter();
    }
}

// Helps simplify mult function. 
List helpMult(long s, List *b, int* counter) {
    List L;
    long carry = 0;
    long temp = 0;
</font>    for (b-&gt;moveBack(); b-&gt;position() &gt; 0; b-&gt;movePrev()) {
        temp = (b-&gt;peekPrev() * s) + carry;
        carry = temp / BASE;
        temp %= BASE;
        L.insertAfter(temp);
    }
    if (carry &gt; 0) {
        L.insertAfter(carry);
    }
    L.moveBack();
<a name="7"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/5/6974366091630/match9-1.html#7" target="1"><img src="./tm_2_2.gif" alt="other" border="0" align="left"></a>

    for (int i = 0; i &lt; *counter; i++) {
        L.insertAfter(0);
    }
    return L;
}

// Class Constructors &amp; Destructors ----------------------------------------

// BigInteger()
// Constructor that creates a new BigInteger in the zero state: 
// signum=0, digits=().
BigInteger::BigInteger() {
    signum = 0;
    digits = List();
}

// BigInteger()
// Constructor that creates a new BigInteger from the long value x.
BigInteger::BigInteger(long x) {
    // Handle zero separately
    if (x == 0) {
        signum = 0;
        digits.insertAfter(0);
</font>        return;
    }
    // Handle negative numbers
    if (x &lt; 0) {
        signum = -1;
        x = -x;
    } else {
        signum = 1;
    }
    // Extract digits from the long value
    while (x &gt; 0) {
        digits.insertBefore(x % BASE);
        x /= BASE;
    }
}

// BigInteger()
// Constructor that creates a new BigInteger from the string s.
// Pre: s is a non-empty string consisting of (at least one) base 10 digit
// {0,1,2,3,4,5,6,7,8,9}, and an optional sign {+,-} prefix.
BigInteger::BigInteger(string s) {
    if (!s.length()) {
        throw invalid_argument("BigInteger: String Constructor: empty string");
    }
<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/5/6974366091630/match9-1.html#4" target="1"><img src="./tm_4_3.gif" alt="other" border="0" align="left"></a>

    int offset = 0;
    if ((s[0] == '+') | (s[0] == '-')) {
        signum = 1;
        if (s[0] == '-') {
            signum = -1;
        }
        offset = 1;
        s = s.substr(offset, s.length() - 1);
    } else {
        signum = 1;
    }
    for (long unsigned int i = 0; i &lt; s.length();) {
        if (!isdigit(s[i])) {
</font>            throw invalid_argument("BigInteger: String Constructor is non-numeric");
        }
        i = i + 1;
    }
<a name="6"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/5/6974366091630/match9-1.html#6" target="1"><img src="./tm_1_2.gif" alt="other" border="0" align="left"></a>

    string num = "";
    List L;
    size_t max = 0;
    size_t curr_digits = s.length();
    while (max &lt; s.length() / POWER) {
        num = s.substr(curr_digits - POWER, POWER);
        digits.insertAfter(stol(num, nullptr, 10));
</font><a name="9"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/5/6974366091630/match9-1.html#9" target="1"><img src="./tm_4_1.gif" alt="other" border="0" align="left"></a>

        curr_digits = curr_digits - POWER;
        max++;
    }
    // Convert remaining digits to long and add them to digits
    if (curr_digits &gt; 0) {
        num = s.substr(0, curr_digits);
        digits.insertAfter(stol(num, nullptr, 10));
</font><a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/5/6974366091630/match9-1.html#0" target="1"><img src="./tm_0_13.gif" alt="other" border="0" align="left"></a>

    }

    delZero(&amp;digits);  // Remove leading zeros from the digits list
}

// BigInteger()
// Constructor that creates a copy of N.
BigInteger::BigInteger(const BigInteger&amp; N) {
    this-&gt;signum = N.signum;
    this-&gt;digits = N.digits;
}

   // Access functions --------------------------------------------------------

// sign()
// Returns -1, 1 or 0 according to whether this BigInteger is positive, 
// negative or 0, respectively.
int BigInteger::sign() const{
    return this-&gt;signum;
}

// compare()
// Returns -1, 1 or 0 according to whether this BigInteger is less than N,
// greater than N or equal to N, respectively.
int BigInteger::compare(const BigInteger&amp; N) const {
    // Check for sign differences.
    if (signum &gt; N.signum) {
        return 1;
    }
    else if (signum &lt; N.signum) {
        return -1;
    }
    else if (signum == 0 &amp;&amp; N.signum == 0) {
        return 0;
    }

    // Same signs so you can add without any problems.
    const List&amp; A = digits;
    const List&amp; B = N.digits;
    int length = A.length();

    // If lengths differ, the longer list is larger
    if (length != B.length()) {
        return (length &gt; B.length()) ? signum : -N.signum;
    }
    
    List A_copy = A;
    List B_copy = B;

    A_copy.moveFront();
    B_copy.moveFront();

    for (int i = 0; i &lt; length; ++i) {
        // A is larger 
        if (A_copy.peekNext() &gt; B_copy.peekNext()) {
            return signum;
        }
        // B is larger 
        else if (A_copy.peekNext() &lt; B_copy.peekNext()) {
            return -N.signum;
        }

        A_copy.moveNext();
        B_copy.moveNext();
    }

    // All digits are equal
    return 0;
}

// Manipulation procedures -------------------------------------------------

// makeZero()
// Re-sets this BigInteger to the zero state.
void BigInteger::makeZero() {
    digits.clear();
    signum = 0;
}

// negate()
// If this BigInteger is zero, does nothing, otherwise reverses the sign of 
// this BigInteger positive &lt;--&gt; negative. 
void BigInteger::negate() {
    signum *= -1;
}

// BigInteger Arithmetic operations ----------------------------------------

// add()
// Returns a BigInteger representing the sum of this and N.
BigInteger BigInteger::add(const BigInteger&amp; N) const {
    BigInteger A = *this;
    BigInteger B = N;
    BigInteger addResult;
</font>
    // Handle cases where signs are different.
    if (A.sign() &gt; 0 &amp;&amp; B.sign() &lt; 0) {
        B.negate();
        return A.sub(B);
    } else if (A.sign() &lt; 0 &amp;&amp; B.sign() &gt; 0) {
        A.negate();
        return B.sub(A);
    } else if (A.sign() &lt; 0 &amp;&amp; B.sign() &lt; 0) {
        A.negate();
        B.negate();
        addResult = A.add(B);
        addResult.negate();
        return addResult;
    }

    // Ensure A is the smaller BigInteger
    if (A &gt; B) {
        return B.add(A);
    }

    List aInt = A.digits;
<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/5/6974366091630/match9-1.html#3" target="1"><img src="./tm_3_7.gif" alt="other" border="0" align="left"></a>

    List bInt = B.digits;
    List resultInt = addResult.digits;

    long carry = 0;
    long temp = 0;

    aInt.moveBack();
    bInt.moveBack();

    // Now add.
    while (aInt.position() &gt; 0 &amp;&amp; bInt.position() &gt; 0) {
        temp = carry + aInt.peekPrev() + bInt.peekPrev();
        carry = temp / BASE;
        temp %= BASE;
        resultInt.insertAfter(temp);
        aInt.movePrev();
        bInt.movePrev();
    }

    // Handle remaining digits
    while (bInt.position() &gt; 0) {
        temp = carry + bInt.peekPrev();
        carry = temp / BASE;
        temp %= BASE;
        resultInt.insertAfter(temp);
        bInt.movePrev();
    }

    // check if there is a final carry
    if (carry &gt; 0) {
        resultInt.insertAfter(carry);
    }

    addResult.signum = 1;
    addResult.digits = resultInt;
    return addResult;
}

// sub()
// Returns a BigInteger representing the difference of this and N.
BigInteger BigInteger::sub(const BigInteger&amp; N) const {
</font>    BigInteger currList = *this;
    BigInteger B = N;
    BigInteger C;
<a name="8"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/5/6974366091630/match9-1.html#8" target="1"><img src="./tm_3_2.gif" alt="other" border="0" align="left"></a>

    List a = currList.digits;
    List b = B.digits;
    List c = C.digits;

    // Return zero if B and currList are equal
    if (B == currList) {
        return C;  
    }

    // Return negation of B if B is positive and currList is negative
    if (B.sign() &amp;&amp; !currList.sign()) {
        B.negate();
        return B;  
</font>    }

    // Return currList if B is negative and currList is positive
    if (!B.sign() &amp;&amp; currList.sign()) {
        return currList;  
    }

    // Return (B + (-currList)) negated if B is negative and currList is positive
    if (B.sign() &lt; 0 &amp;&amp; currList.sign() &gt; 0) {
        currList.negate();
        C = B.add(currList);
        C.negate();
        return C;  
    }

    // Return (B + (-currList)) if B is positive and currList is negative
    if (B.sign() &gt; 0 &amp;&amp; currList.sign() &lt; 0) {
        B.negate();
        C = B.add(currList);
        return C;  
    }
    
    // Return (currList - B) negated if both B and currList are negative
    if (B.sign() &lt; 0 &amp;&amp; currList.sign() &lt; 0) {
        B.negate();
        currList.negate();
        C = currList.sub(B);
        C.negate();
        return C;  
    }

    // Return negation of (B - currList) if B is less than currList
    if (B &lt; currList) {
        C = B.sub(currList);
<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/5/6974366091630/match9-1.html#2" target="1"><img src="./tm_2_10.gif" alt="other" border="0" align="left"></a>

        C.negate();
        return C;  
    }

    // Do sub.
    b.moveBack();
    a.moveBack();
    long dist = 0;
    long temp = 0;
    int i = a.position();
    while (!(i &lt;= 0)) {
        if (b.peekPrev() - dist &lt; a.peekPrev()) {
            temp = b.peekPrev() + BASE - a.peekPrev() - dist;
            dist = 1;
        } else {
            temp = b.peekPrev() - dist - a.peekPrev();
            if (!(b.peekPrev() &lt;= 0)) {
                dist = 0;
            }
        }
        c.insertAfter(temp);
        b.movePrev();
        a.movePrev();
        i--;
    }
    while (b.position() &gt; 0) {
        if (b.peekPrev() - dist &lt; 0) {
            temp = b.peekPrev() + BASE - 0 - dist;
            dist = 1;
        } else {
            temp = b.peekPrev() - dist - 0;
            if (!(b.peekPrev() &lt;= 0)) {
                dist = 0;
            }
        }
        c.insertAfter(temp);
        b.movePrev();
    }
    C.digits = c;
    delZero(&amp;(C.digits));  // Remove leading zeros from the result
    C.signum = -1;  // Set the sign of the result to negative
    return C;
}

// mult()
// Returns a BigInteger representing the product of this and N. 
BigInteger BigInteger::mult(const BigInteger&amp; N) const {
</font>    BigInteger currList = *this;
    BigInteger B = N;
    BigInteger C;
    List a = currList.digits;
    List b = B.digits;
    int counter = 0;

    b.moveBack();
    a.moveBack();
    int p = b.position();

    // Do mult.
    for (int i = p; i &gt; 0; i--) {
        List temp = helpMult(b.peekPrev(), &amp;a, &amp;counter);  // Multiply current digit of B with currList
        BigInteger T;
        T.signum = 1;
        T.digits = temp;
        C = C.add(T);  // Accumulate the result in C
        b.movePrev();  // Move to the next digit of B
        counter++;
    }
    C.signum = B.signum * currList.signum;  // Determine the sign of the result
    return C;
}

// Other Functions ---------------------------------------------------------

// to_string()
// Returns a string representation of this BigInteger consisting of its
// base 10 digits. If this BigInteger is negative, the returned string 
// will begin with a negative sign '-'. If this BigInteger is zero, the
// returned string will consist of the character '0' only.
string BigInteger::to_string() {
    string out = "";
    
    if (this-&gt;signum == 0) {
        return "0";  // Return "0" if the BigInteger is zero
    } else if (signum == -1) {
        out += "-";  // Add a negative sign if the BigInteger is negative
    }

    // Remove leading zeros from the digits list
    digits.moveFront();
    while (digits.front() == 0 &amp;&amp; digits.length() &gt; 1) {
        digits.eraseAfter();
    }

    for (digits.moveFront(); digits.position() &lt; digits.length(); digits.moveNext()) {
        string A = std::to_string(digits.peekNext());
        string B = "";
        // Make sure we have the correct amount of 0's shown depending on the base.
        while ((int)(B.length() + A.length()) &lt; POWER &amp;&amp; digits.position() != 0) {
            B += '0';
        }
        out += (B + A); 
    }
    return out;
}

// Overriden Operators -----------------------------------------------------

// operator&lt;&lt;()
// Inserts string representation of N into stream.
<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/5/6974366091630/match9-1.html#1" target="1"><img src="./tm_1_10.gif" alt="other" border="0" align="left"></a>

ostream&amp; operator&lt;&lt;( ostream&amp; stream, BigInteger N ) {
    return stream&lt;&lt;N.BigInteger::to_string();
}

// operator==()
// Returns true if and only if A equals B. 
bool operator==( const BigInteger&amp; A, const BigInteger&amp; B ) {
    int i = A.compare(B);
    return (i == 0) ? true : false;
}

// operator&lt;()
// Returns true if and only if A is less than B. 
bool operator&lt;( const BigInteger&amp; A, const BigInteger&amp; B ) {
    int i = A.compare(B);
    return (i == -1) ? true : false;
}

// operator&lt;=()
// Returns true if and only if A is less than or equal to B. 
bool operator&lt;=( const BigInteger&amp; A, const BigInteger&amp; B ) {
    int i = A.compare(B);
    return ((i == 0) || (i == -1)) ? true : false;
}

// operator&gt;()
// Returns true if and only if A is greater than B. 
bool operator&gt;( const BigInteger&amp; A, const BigInteger&amp; B ) {
    int i = A.compare(B);
    return (i == 1) ? true : false;
}

// operator&gt;=()
// Returns true if and only if A is greater than or equal to B. 
bool operator&gt;=( const BigInteger&amp; A, const BigInteger&amp; B ) {
    int i = A.compare(B);
    return ((i == 0) || (i == 1)) ? true : false;
}

// operator+()
// Returns the sum A+B. 
BigInteger operator+( const BigInteger&amp; A, const BigInteger&amp; B ) {
    return A.add(B);
}

// operator+=()
// Overwrites A with the sum A+B. 
BigInteger operator+=( BigInteger&amp; A, const BigInteger&amp; B ) {
</font>    BigInteger I = A.add(B);
    A.digits = I.digits;
    A.signum = I.signum;
    return A; 
}

// operator-()
// Returns the difference A-B. 
BigInteger operator-( const BigInteger&amp; A, const BigInteger&amp; B ) {
    return A.sub(B);
}

// operator-=()
// Overwrites A with the difference A-B. 
BigInteger operator-=( BigInteger&amp; A, const BigInteger&amp; B ) {
    BigInteger I = A.sub(B);
    A.digits = I.digits;
    A.signum = I.signum;
    return A; 
}

// operator*()
// Returns the product A*B. 
BigInteger operator*( const BigInteger&amp; A, const BigInteger&amp; B ) {
    return A.mult(B);
}

// operator*=()
// Overwrites A with the product A*B. 
BigInteger operator*=( BigInteger&amp; A, const BigInteger&amp; B ) {
    BigInteger I = A.mult(B);
    A.digits = I.digits;
    A.signum = I.signum;
    return A; 
}</pre>



</body></html>