
<!-- saved from url=(0062)http://moss.stanford.edu/results/1/3564772588174/match3-0.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/aaychen/pa6/BigInteger.cpp</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter25/aaychen/pa6/BigInteger.cpp<p></p><pre>/*
 * Aaron Chen
 * aaychen
 * 2025 Winter CSE101 pa6
 * BigInteger.cpp
 * BigInteger for BigInteger ADT
*/

#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;stdexcept&gt;
#include "BigInteger.h"
#include "List.h"

<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/1/3564772588174/match3-1.html#0" target="1"><img src="./tm_0_45.gif" alt="other" border="0" align="left"></a>

const int POWER = 9;
const long BASE = 1000000000;

using namespace std;

// Class Constructors &amp; Destructors ----------------------------------------

// BigInteger()
// Constructor that creates a new BigInteger in the zero state: 
// signum=0, digits=().
BigInteger::BigInteger(){
	signum = 0;
}

// BigInteger()
// Constructor that creates a new BigInteger from the long value x.
BigInteger::BigInteger(long x){
	if (x &gt; 0) {
		signum = 1;
	} else {
		signum = -1;
	}
	long value = x % BASE;
	while(value &gt; 0){
		digits.insertAfter(value);
		x = x / BASE;
		value = x % BASE;
	}
}

// BigInteger()
// Constructor that creates a new BigInteger from the string s.
// Pre: s is a non-empty string consisting of (at least one) base 10 digit
// {0,1,2,3,4,5,6,7,8,9}, and an optional sign {+,-} prefix.
BigInteger::BigInteger(std::string s){
	if(s.length() == 0){
		throw std::invalid_argument("BigInteger: Constructor: empty string");
	}
	if (s[0] == '+'){
		signum = 1;
	}
	if (s[0] == '-'){
		signum = -1;
	} else {
		signum = 1;
	}

	if (s[0] != '+' &amp;&amp; s[0] != '-'){
		for (char c : s){
			if (!isdigit(c)){
				throw std::invalid_argument("BigInteger: Constructor: non-numeric string");
			}
		}
	} else {
		string test = "";
		if (s.length() != 1) {
			test = s.substr(1, s.length());
			for (char c : test){
				if (!isdigit(c)){
					throw std::invalid_argument("BigInteger: Constructor: non-numeric string");
				}
			}
		} else {
			throw std::invalid_argument("BigInteger: Constructor: non-numeric string");
		}
	}

	int i = s.length() - POWER;
	while(i &gt; 0){
		digits.insertAfter(stol(s.substr(i, POWER)));
		i -= POWER;
	}
	if (i &lt; 0) {
		if (s[0] == '+' || s[0] == '-') {
			digits.insertAfter(stol(s.substr(1, i + POWER -1)));
		} else {
			digits.insertAfter(stol(s.substr(0, i + POWER)));
		}
	} else if (i == 0){
		digits.insertAfter(stol(s.substr(i, POWER)));
	}
	digits.moveFront();
	while(digits.peekNext() == 0 &amp;&amp; digits.length() &gt; 1){
		digits.eraseAfter();
	}
}

// BigInteger()
// Constructor that creates a copy of N.
BigInteger::BigInteger(const BigInteger&amp; N){
	this-&gt;signum = N.signum;
	this-&gt;digits = N.digits;
}

// Access functions --------------------------------------------------------

// sign()
// Returns -1, 1 or 0 according to whether this BigInteger is positive, 
// negative or 0, respectively.
int BigInteger::sign() const{
	return this-&gt;signum;
}

// compare()
// Returns -1, 1 or 0 according to whether this BigInteger is less than N,
// greater than N or equal to N, respectively.
int BigInteger::compare(const BigInteger&amp; N) const{
	if (this-&gt;signum &lt; N.signum){
		return -1;
	} else if (this-&gt;signum &gt; N.signum){
		return 1;
	} else if (this-&gt;signum == 0 &amp;&amp; 0 == N.signum){
		return 0;
	}

	List A = this-&gt;digits;
	List B = N.digits;
	if (this-&gt;signum == N.signum){
		if(this-&gt;signum == 1){
			if(A.length() &gt; B.length()){
				return 1;
			} else if (A.length() &lt; B.length()){
				return -1;
			}
			A.moveFront();
			B.moveFront();
			while(A.position() &lt; A.length())
			{
				if(A.peekNext() &gt; B.peekNext()){
					return 1;
				} else if (A.peekNext() &lt; B.peekNext()){
					return -1;
				}
				A.moveNext();
				B.moveNext();
			}
			return 0;
		}
		if(this-&gt;signum == -1){
			if(A.length() &gt; B.length()){
				return -1;
			} else if (A.length() &lt; B.length()){
				return 1;
			}
			A.moveFront();
			B.moveFront();
			while(A.position() &lt; A.length()){
				if(A.peekNext() &gt; B.peekNext()){
					return -1;
				} else if (A.peekNext() &lt; B.peekNext()){
					return 1;
				}
				A.moveNext();
				B.moveNext();
			}
			return 0;
		}
	}
	return 0;
}

// Manipulation procedures -------------------------------------------------

// makeZero()
// Re-sets this BigInteger to the zero state.
void BigInteger::makeZero(){
	signum = 0;
	digits.clear();
}

// negate()
// If this BigInteger is zero, does nothing, otherwise reverses the sign of
// this BigInteger positive &lt;--&gt; negative.
void BigInteger::negate(){
	signum *= -1;
}

// Multiplies L (considered as a vector) by m. Used by mult().
void scalarMultList(List&amp; L, ListElement m){
	L.moveFront();
	while(L.position() &lt; L.length()){
		L.setAfter(L.peekNext() * m);
		L.moveNext();
	}
}


// Changes the sign of each integer in List L. Used by sub().
void negateList(List&amp; L){
	scalarMultList(L, -1);
}

// Overwrites the state of S with A + sgn*B (considered as vectors).
// Used by both sum() and sub().
void sumList(List&amp; S, List A, List B, int sgn){
	S.clear();
	scalarMultList(B, sgn);
	
	A.moveBack();
	B.moveBack();
	while (A.position() &gt; 0 &amp;&amp; B.position() &gt; 0) {
		S.insertAfter(A.peekPrev() + B.peekPrev());
</font>		A.movePrev();
		B.movePrev();
	}
	while (A.position() &gt; 0) {
		S.insertAfter(A.peekPrev());
<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/1/3564772588174/match3-1.html#2" target="1"><img src="./tm_2_6.gif" alt="other" border="0" align="left"></a>

		A.movePrev();
	}
	while (B.position() &gt; 0) {
		S.insertAfter(B.peekPrev());
		B.movePrev();
	}
	S.moveFront();
	while(S.peekNext() == 0 &amp;&amp; S.length() &gt; 1){
		S.eraseAfter();
	}
}

// Performs carries from right to left (least to most significant
// digits), then returns the sign of the resulting integer. Used
// by add(), sub() and mult().
int normalizeList(List&amp; L){
	int sign = 1;
	if(L.peekNext() == 0){
		return 0;
	}
	if (L.peekNext() &lt; 0){
		negateList(L);
		sign = -1;
	}
	long val = 0;
	long carry = 0;
	L.moveBack();
	while(L.position() &gt; 0){
		val = L.peekPrev();
		if (val &lt; 0){
			val += BASE + carry;
			L.setBefore(val);
</font>			carry = -1;
		} else {
			val += carry;
			carry = 0;
			if (val &gt;= BASE){
				carry = val/BASE;
				val = val % BASE;
			}
			L.setBefore(val);
		}
		L.movePrev();
	}
	if(carry != 0){
		L.moveFront();
<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/1/3564772588174/match3-1.html#1" target="1"><img src="./tm_1_24.gif" alt="other" border="0" align="left"></a>

		L.insertAfter(carry);
	}
	return sign;
}

// Prepends p zero digits to L, multiplying L by base^p. Used by mult().
void shiftList(List&amp; L, int p){
	L.moveBack();
	for (int i = 0; i &lt; p; ++i){
		L.insertAfter(0);
	}
}

// BigInteger Arithmetic operations ----------------------------------------

// add()
// Returns a BigInteger representing the sum of this and N.
BigInteger BigInteger::add(const BigInteger&amp; N) const{
	BigInteger M;
	List A = this-&gt;digits;
	List B = N.digits;
	List sum;
	if(this-&gt;signum == -1){
		negateList(A);
	}
	if(N.signum == -1){
		negateList(B);
	}
	sumList(sum, A, B, 1);
	M.signum = normalizeList(sum);
	M.digits = sum;
	return M;
}

// sub()
// Returns a BigInteger representing the difference of this and N.
BigInteger BigInteger::sub(const BigInteger&amp; N) const{
	BigInteger M;
	BigInteger negN = N;
	negateList(negN.digits);
	M = this-&gt;add(negN);
	return M;
}

// mult()
// Returns a BigInteger representing the product of this and N.
BigInteger BigInteger::mult(const BigInteger&amp; N) const{
	BigInteger M;
	if(this-&gt;signum == 0 || N.signum == 0){
		return M;
	}
	List prod;
	List A;
	List B = N.digits;
	int shift = 0;
	prod.insertAfter(0);
	B.moveBack();
	while(B.position() &gt; 0){
		A = this-&gt;digits;
		scalarMultList(A, B.peekPrev());
		shiftList(A, shift);
		List temp = prod;
		sumList(prod, temp, A, 1);
		normalizeList(prod);
		B.movePrev();
		shift++;
	}
	M.digits = prod;
	M.signum = this-&gt;signum * N.signum;
	return M;
}

// Other Functions ---------------------------------------------------------

// to_string()
// Returns a string representation of this BigInteger consisting of its
// base 10 digits. If this BigInteger is negative, the returned string
// will begin with a negative sign '-'. If this BigInteger is zero, the
// returned string will consist of the character '0' only.
std::string BigInteger::to_string(){
	string s = "";
	if (this-&gt;signum == 0){
		return "0";
	} else if (signum == -1){
		s += "-";
	}
	digits.moveFront();
	while(digits.peekNext() == 0 &amp;&amp; digits.length() &gt; 1){
		digits.moveNext();
	}
	while(digits.position() != digits.length()){
		string temp = std::to_string(digits.peekNext());
		string zeros = "";
		while((zeros.length() + temp.length()) &lt; POWER &amp;&amp; digits.position() != 0){
			zeros += "0";
		}
		s += (zeros + temp);
		digits.moveNext();
	}
	return s;
}

// Overriden Operators -----------------------------------------------------

// operator&lt;&lt;()
// Inserts string representation of N into stream.
std::ostream&amp; operator&lt;&lt;( std::ostream&amp; stream, BigInteger N ){
	return stream &lt;&lt; N.BigInteger::to_string();
</font>}

// operator==()
// Returns true if and only if A equals B. 
bool operator==( const BigInteger&amp; A, const BigInteger&amp; B ){
	return (A.compare(B) == 0);
}

// operator&lt;()
// Returns true if and only if A is less than B. 
bool operator&lt;( const BigInteger&amp; A, const BigInteger&amp; B ){
	return (A.compare(B) == -1);
}

// operator&lt;=()
// Returns true if and only if A is less than or equal to B.
bool operator&lt;=( const BigInteger&amp; A, const BigInteger&amp; B ){
	return (A.compare(B) &lt;= 0);
}

// operator&gt;()
// Returns true if and only if A is greater than B.
bool operator&gt;( const BigInteger&amp; A, const BigInteger&amp; B ){
	return (A.compare(B) == 1);
}

// operator&gt;=()
// Returns true if and only if A is greater than or equal to B.
<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/1/3564772588174/match3-1.html#3" target="1"><img src="./tm_3_2.gif" alt="other" border="0" align="left"></a>

bool operator&gt;=( const BigInteger&amp; A, const BigInteger&amp; B ){
	return (A.compare(B) &gt;= 0);
}

// operator+()
// Returns the sum A+B. 
BigInteger operator+( const BigInteger&amp; A, const BigInteger&amp; B ){
	return A.BigInteger::add(B);
}

// operator+=()
// Overwrites A with the sum A+B.
BigInteger operator+=( BigInteger&amp; A, const BigInteger&amp; B ){
</font>	A = A.BigInteger::add(B);
	return A;
}

// operator-()
// Returns the difference A-B.
BigInteger operator-( const BigInteger&amp; A, const BigInteger&amp; B ){
	return A.BigInteger::sub(B);
}

// operator-=()
// Overwrites A with the difference A-B.
BigInteger operator-=( BigInteger&amp; A, const BigInteger&amp; B ){
	A = A.BigInteger::sub(B);
	return A;
}

// operator*()
// Returns the product A*B.
BigInteger operator*( const BigInteger&amp; A, const BigInteger&amp; B ){
	return A.BigInteger::mult(B);
}

// operator*=()
// Overwrites A with the product A*B.
BigInteger operator*=( BigInteger&amp; A, const BigInteger&amp; B ){
	A = A.BigInteger::mult(B);
	return A;
}

</pre>



</body></html>