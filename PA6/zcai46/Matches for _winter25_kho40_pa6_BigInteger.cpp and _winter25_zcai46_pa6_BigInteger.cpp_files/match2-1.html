
<!-- saved from url=(0062)http://moss.stanford.edu/results/7/7834820277962/match2-1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/kho40/pa6/BigInteger.cpp</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter25/zcai46/pa6/BigInteger.cpp<p></p><pre>/**
 * Eric Cai
 * zcai46
 * 2024 Winter CSE101 PA6
 * BigInteger.cpp
 * C++ implementation of the BigInteger ADT
 */
#include "BigInteger.h"
#include &lt;iostream&gt;
#include &lt;vector&gt;

const int power = 9;
const long base = 1000000000;

// Helper Function: Convert List to Vector
<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/7/7834820277962/match2-0.html#1" target="0"><img src="./tm_1_6.gif" alt="other" border="0" align="left"></a>

std::vector&lt;long&gt; listToVector(const List &amp;L) {
    std::vector&lt;long&gt; result;
    List temp = L;
    temp.moveFront();

    while (temp.position() &lt; temp.length()) {
        result.push_back(temp.peekNext());
        temp.moveNext();
    }

    return result;
}

// Helper Function: Convert Vector to List
void vectorToList(const std::vector&lt;long&gt; &amp;vec, List &amp;L) {
    L.clear();
    for (long digit : vec) {
        L.moveBack();
        L.insertAfter(digit);
    }
}

// Helper Function: Remove Leading Zeros
void removeZeros(std::vector&lt;long&gt;&amp; x) {
    while (x.size() &gt; 1 &amp;&amp; x.back() == 0) {
        x.pop_back();
</font>    }
}

// Constructor: Default
BigInteger::BigInteger() : signum(0), digits() {}

// Constructor: Long
BigInteger::BigInteger(long x) {
    if (x == 0) {
        signum = 0;
        return;
    }

<a name="5"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/7/7834820277962/match2-0.html#5" target="0"><img src="./tm_0_1.gif" alt="other" border="0" align="left"></a>

    signum = (x &gt; 0) ? 1 : -1;
    x = std::abs(x);
    
    while (x &gt; 0) {
        digits.insertBefore(x % base);
        x /= base;
    }
}

// Constructor: String
BigInteger::BigInteger(std::string s) {
</font>    if (s.empty()) {
        std::cerr &lt;&lt; "[DEBUG] Throwing Exception: Empty String\n";
        throw std::invalid_argument("BigInteger: Constructor: empty string");
    }
<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/7/7834820277962/match2-0.html#4" target="0"><img src="./tm_4_2.gif" alt="other" border="0" align="left"></a>

    int i = 0;
    signum = 1;
    if (s[i] == '+' || s[i] == '-') 
    {
        if (s[i] == '-') 
        {
            signum = -1;
        }
        i++;
</font>    }
// Ensure that after a sign, we have valid digits
    if (i &gt;= s.length() || !isdigit(s[i])) {
        std::cerr &lt;&lt; "[DEBUG] Throwing Exception: Non-numeric String\n";
        throw std::invalid_argument("BigInteger: Constructor: non-numeric string");
    }

<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/7/7834820277962/match2-0.html#3" target="0"><img src="./tm_3_3.gif" alt="other" border="0" align="left"></a>

    while (i &lt; (int)s.length() &amp;&amp; s[i] == '0') 
    {
        i++; 
    }

    if (i == (int)s.length()) 
    {
        signum = 0;
        return;
    }

    for (int j = s.length(); j &gt; i; j -= power) 
    {
        int start = std::max(i, j - power);
</font>        std::string chunk = s.substr(start, j - start);

        // Ensure every chunk is numeric
        for (char c : chunk) {
            if (!isdigit(c)) {
                std::cerr &lt;&lt; "[DEBUG] Throwing Exception: Non-numeric characters in chunk '" &lt;&lt; chunk &lt;&lt; "'\n";
                throw std::invalid_argument("BigInteger: Constructor: non-numeric string");
            }
        }

        digits.insertBefore(std::stol(chunk));
    }
}

// Copy Constructor
BigInteger::BigInteger(const BigInteger&amp; N) : signum(N.signum), digits(N.digits) {}

// Returns the signum
int BigInteger::sign() const {
    return signum;
}

// Compare two BigIntegers
<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/7/7834820277962/match2-0.html#2" target="0"><img src="./tm_2_3.gif" alt="other" border="0" align="left"></a>

int BigInteger::compare(const BigInteger&amp; N) const {
    if (signum != N.signum) {
        return (signum &lt; N.signum) ? -1 : 1;
    }

    if (signum == 0) return 0;

    std::vector&lt;long&gt; a = listToVector(digits);
    std::vector&lt;long&gt; b = listToVector(N.digits);

    removeZeros(a);
    removeZeros(b);

    if (a.size() != b.size()) {
</font><a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/7/7834820277962/match2-0.html#0" target="0"><img src="./tm_0_55.gif" alt="other" border="0" align="left"></a>

        return (signum &gt; 0) ? (a.size() &gt; b.size() ? 1 : -1) : (a.size() &gt; b.size() ? -1 : 1);
    }

    for (int i = a.size() - 1; i &gt;= 0; i--) {
        if (a[i] != b[i]) {
            return (signum &gt; 0) ? (a[i] &gt; b[i] ? 1 : -1) : (a[i] &gt; b[i] ? -1 : 1);
        }
    }
    return 0;
}

// Makes the BigInteger zero
void BigInteger::makeZero() {
    signum = 0;
    digits.clear();
}

// Negates the BigInteger
void BigInteger::negate() {
    if (signum != 0) {
        signum = -signum;
    }
}

// Adds two digit vectors.
std::vector&lt;long&gt; addHelper(const std::vector&lt;long&gt;&amp; a, const std::vector&lt;long&gt;&amp; b) 
{
    std::vector&lt;long&gt; result;
    size_t n = std::max(a.size(), b.size());
    long carry = 0;

    for (size_t i = 0; i &lt; n; i++) 
    {
        long d1 = (i &lt; a.size() ? a[i] : 0);
        long d2 = (i &lt; b.size() ? b[i] : 0);
        long sum = d1 + d2 + carry;

        result.push_back(sum % base);
        carry = sum / base;
    }

    removeZeros(result);
    return result;
}

// Subtracts vector b from vector a
std::vector&lt;long&gt; subHelper(const std::vector&lt;long&gt;&amp; a, const std::vector&lt;long&gt;&amp; b) 
{
    std::vector&lt;long&gt; result;
    long borrow = 0;

    for (size_t i = 0; i &lt; a.size(); i++) 
    {
        long d1 = a[i]; 
        long d2 = (i &lt; b.size()) ? b[i] : 0; // Digit from b (or 0 if out of bounds)
        long diff = d1 - d2 - borrow;

        if (diff &lt; 0) 
        {
            diff += base; // Borrow from the next higher digit
            borrow = 1;
        } 
        else 
        {
            borrow = 0;
        }

        result.push_back(diff);
    }

    removeZeros(result); 
    return result;
}


// Multiplies two digit vectors.
std::vector&lt;long&gt; multHelper(const std::vector&lt;long&gt;&amp; a, const std::vector&lt;long&gt;&amp; b) 
{
    if (a.empty() || b.empty()) return {0};

    std::vector&lt;long&gt; result(a.size() + b.size(), 0); 

    for (size_t i = 0; i &lt; a.size(); i++) 
    {
        long carry = 0;
        for (size_t j = 0; j &lt; b.size(); j++) 
        {
            long product = a[i] * b[j] + result[i + j] + carry;
            result[i + j] = product % base; 
            carry = product / base; 
        }
        result[i + b.size()] += carry; // Store remaining carry
    }

    removeZeros(result); 
    return result;
}


// Addition.
BigInteger BigInteger::add(const BigInteger&amp; N) const 
{
    BigInteger result;
    if (signum == 0) return N;
    if (N.signum == 0) return *this;
    
    std::vector&lt;long&gt; a = listToVector(digits);
    std::vector&lt;long&gt; b = listToVector(N.digits);
    
    if (signum == N.signum) 
    {
        std::vector&lt;long&gt; sum = addHelper(a, b);
        result.signum = signum;
        vectorToList(sum, result.digits);
    } 
    else 
    {
        BigInteger absA = *this;
        absA.signum = 1;
        BigInteger absB = N;
        absB.signum = 1;
        int compare = absA.compare(absB);

        if (compare == 0) 
        {
            result.makeZero();
        } 
        else if (compare &gt; 0) 
        {
            std::vector&lt;long&gt; diff = subHelper(a, b);
            result.signum = signum;
            vectorToList(diff, result.digits);
        } 
        else 
        {
            std::vector&lt;long&gt; diff = subHelper(b, a);
            result.signum = N.signum;
            vectorToList(diff, result.digits);
        }
    }

    if (result.digits.length() == 0) 
        result.signum = 0;

    return result;
}

// Subtraction.
BigInteger BigInteger::sub(const BigInteger&amp; N) const 
{
    BigInteger negN = N;
    negN.negate();
    return this-&gt;add(negN);
}

// Multiplication.
BigInteger BigInteger::mult(const BigInteger&amp; N) const 
{
    if (signum == 0 || N.signum == 0) return BigInteger();

    std::vector&lt;long&gt; a = listToVector(digits);
    std::vector&lt;long&gt; b = listToVector(N.digits);

    std::vector&lt;long&gt; product = multHelper(a, b);

    BigInteger result;
    result.signum = signum * N.signum; 
    vectorToList(product, result.digits);

    if (result.digits.length() == 0) 
        result.signum = 0;

    return result;
}




// Converts BigInteger to String
std::string BigInteger::to_string() {
    if (signum == 0) return "0";

    std::vector&lt;long&gt; vec = listToVector(digits);
    removeZeros(vec);
    
    std::string result = (signum &lt; 0) ? "-" : "";

    // The most significant digit does not need leading zeros.
    result += std::to_string(vec.back());

    // Process remaining digits, ensuring each segment has the correct length
    for (int i = static_cast&lt;int&gt;(vec.size()) - 2; i &gt;= 0; i--) 
    {
        std::string numStr = std::to_string(vec[i]);
        while (numStr.length() &lt; power) 
        {
            numStr = "0" + numStr;
        }
        result += numStr;
    }

    return result;
}

// Overloaded Operators
//-------------------------------------------------------------------------------------

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, BigInteger N) 
{
    stream &lt;&lt; N.to_string();
</font>    return stream;
}

bool operator==(const BigInteger&amp; A, const BigInteger&amp; B) 
{
    return A.compare(B) == 0;
}

bool operator&lt;(const BigInteger&amp; A, const BigInteger&amp; B) 
{
    return A.compare(B) &lt; 0;
}

bool operator&lt;=(const BigInteger&amp; A, const BigInteger&amp; B) 
{
    return A.compare(B) &lt;= 0;
}

bool operator&gt;(const BigInteger&amp; A, const BigInteger&amp; B) 
{
    return A.compare(B) &gt; 0;
}

bool operator&gt;=(const BigInteger&amp; A, const BigInteger&amp; B) 
{
    return A.compare(B) &gt;= 0;
}

BigInteger operator+(const BigInteger&amp; A, const BigInteger&amp; B) 
{
    return A.add(B);
}

BigInteger operator-(const BigInteger&amp; A, const BigInteger&amp; B) 
{
    return A.sub(B);
}

BigInteger operator*(const BigInteger&amp; A, const BigInteger&amp; B) 
{
    return A.mult(B);
}

BigInteger operator+=(BigInteger&amp; A, const BigInteger&amp; B) 
{
    A = A.add(B);
    return A;
}

BigInteger operator-=(BigInteger&amp; A, const BigInteger&amp; B) 
{
    A = A.sub(B);
    return A;
}

BigInteger operator*=(BigInteger&amp; A, const BigInteger&amp; B) 
{
    A = A.mult(B);
    return A;
}
</pre>



</body></html>