
<!-- saved from url=(0062)http://moss.stanford.edu/results/9/4014659580747/match0-1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/etthnguy/pa6/BigInteger.cpp</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter22/rzhong6/pa6/BigInteger.cpp<p></p><pre>/*********************************************************************************
* Daniel Zhong, rzhong6
* 2022 Winter CSE101 PA6
* BigInteger.cpp
* Implementation file for BigInteger ADT
*********************************************************************************/
#include&lt;string&gt;
#include&lt;sstream&gt;
#include"BigInteger.h"

// BASE = 10^POWER, 0 &lt;= POWER &lt;= 9
<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/9/4014659580747/match0-0.html#0" target="0"><img src="./tm_0_51.gif" alt="other" border="0" align="left"></a>

const long BASE = 1000000000;   // 1 billion
const int POWER = 9;

// Helper function:
// Normalize BigInteger N.
// Guarantte each element in digits less than BASE.
// Clean front 0 element. eg: 000 000 230 000 000 -&gt; 230 000 000
void normalize(BigInteger&amp; N){
    while(N.digits.length() &gt; 0 &amp;&amp; N.digits.front() == 0){
        N.digits.moveFront();
        N.digits.eraseAfter();
    }
    if(N.digits.length() == 0){
        N.signum = 0;
        return;
    }
    
    N.digits.moveBack();
    while(N.digits.position() &gt; 0){
        long carry = 0;
        long elem = N.digits.movePrev();
        if(elem &lt; 0){
            if(N.digits.position() == 0){
                N.digits.setAfter(-elem);
                N.signum *= -1;
                break;
            }
            for(carry = -1; elem + -carry * BASE &lt; 0; carry--) ;
            N.digits.setAfter(elem + -carry * BASE);
        }else if(elem &gt;= BASE){
            carry = 1;
            for(carry = 1; elem + -carry * BASE &gt;= BASE; carry++) ;
            N.digits.setAfter(elem + -carry * BASE);
        }
        if(N.digits.position() &gt; 0){
            long prev_elem = N.digits.movePrev();
            N.digits.setAfter(prev_elem + carry);
            N.digits.moveNext();
        }else if(carry &lt;= -1){
            N.digits.setAfter(- N.digits.front());
            N.signum = -1;
            if(N.digits.front() &lt; 0){
                N.digits.setAfter(BASE + N.digits.front());
                N.digits.moveNext();
                while(N.digits.position() &lt; N.digits.length()){
                    long n = N.digits.moveNext();
                    N.digits.setBefore(BASE - n);
                }
                break;
            }
            
        }else if (carry &gt;= 1){
            N.digits.insertAfter(carry);
        }
    }
    N.digits.moveFront();
}

BigInteger::BigInteger(){
    signum = 0;
    digits = List();
}

BigInteger::BigInteger(std::string s){
    if(s.length() == 0){
        throw std::invalid_argument("BigInteger: Constructor: empty string");
    }
    if((s[0] != '-' &amp;&amp; s[0] != '+') &amp;&amp; (s[0] &gt; '9' || s[0] &lt; '0')){
        throw std::invalid_argument("BigInteger: Constructor: non-numeric string");
    }
    for(int i = s.length() - 1; i &gt; 0; i--){
        if(s[i] &gt; '9' || s[i] &lt; '0'){
            throw std::invalid_argument("BigInteger: Constructor: non-numeric string");
        }
    }
    if(s == "0"){
        return;
    }
    // eg: "-1234"
    if(s.substr(0,1) == "-" || s.substr(0,1) == "+"){
        if(s.substr(0,1) == "-"){
            this-&gt;signum = -1;
        }else{
            this-&gt;signum = 1;
        }
        s = s.substr(1);
    }else{
        this-&gt;signum = 1;
    }

    int length = s.length();
    for(int i = 1; length - i * POWER &gt; - POWER; i++){
        // pos and cnt is passed to function substr()
        int pos = length - i * POWER;
        int cnt = POWER;
        // Cut s ito separate POWER length string, 
        // and convert the cutted string to a long number.
        std::string num_str;
        if(pos &gt; 0){
            num_str = s.substr(pos, cnt);
        }else{
            num_str = s.substr(0, pos + POWER);
        }
        long num = std::stol(num_str);
        this-&gt;digits.insertAfter(num);
    }
    // if(this-&gt;digits.front() &lt; 0){
    //     this-&gt;digits.moveFront();
    //     this-&gt;digits.setAfter(-this-&gt;digits.front());
    //     this-&gt;signum = -1;
    // }
}

BigInteger::BigInteger(const BigInteger&amp; N){
    this-&gt;signum = N.signum;
    // Use copy constructor
    this-&gt;digits = List(N.digits);
}

int BigInteger::sign() const{
    return signum;
}

int BigInteger::compare(const BigInteger&amp; N) const{
    BigInteger ret = this-&gt;sub(N);
    return ret.sign();
}

void BigInteger::makeZero(){
    this-&gt;signum = 0;
    this-&gt;digits.clear();
}

void BigInteger::negate(){
    this-&gt;signum *= -1;
}

BigInteger BigInteger::add(const BigInteger&amp; N) const{
    BigInteger newM(*this);
    BigInteger newN(N);
    if(newM.sign() != newN.sign()){
        if(newN.sign() &gt; 0){
            return newN.add(newM);
        }
        // return newM - (- newN)
        newN.signum *= -1;
        return newM.sub(newN);
    }
    // perform A = newM + newN
    BigInteger A;
    A.signum = signum;  // *this-&gt;signum is equal to N.signum
    List digitsM = newM.digits;
    List digitsN = newN.digits;
    List digitsA;
    digitsM.moveBack();
    digitsN.moveBack();
    while(digitsM.position() &gt; 0 &amp;&amp; digitsN.position() &gt; 0){
        long m = digitsM.movePrev();
        long n = digitsN.movePrev();
        digitsA.insertAfter(m + n);
    }
    // Insert rest ListElement in digitsM or digitsN into digitsA
    while(digitsM.position() &gt; 0){
        long m = digitsM.movePrev();
        digitsA.insertAfter(m);
    }
    while(digitsN.position() &gt; 0){
        long n = digitsN.movePrev();
        digitsA.insertAfter(n);
    }
    A.digits = digitsA;
    normalize(A);
    return A;
}

BigInteger BigInteger::sub(const BigInteger&amp; N) const{
    BigInteger newM(*this);
    BigInteger newN(N);

    // eg: 100 - (-20) = 100 + 20
    if(newM.sign() != newN.sign()){
        // return newM + (- newN )
        newN.signum *= -1;
        return newM.add(newN);
    }
    if(newN.digits.length() &gt; newM.digits.length()){
        BigInteger temp = newN - newM;
        temp.signum *= -1;
        return temp;
    }
    if( newN.digits.length() == newM.digits.length() &amp;&amp; newN.digits.length() &gt; 0 &amp;&amp; newN.digits.front() &gt; newM.digits.front()){
</font><a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/9/4014659580747/match0-0.html#1" target="0"><img src="./tm_1_33.gif" alt="other" border="0" align="left"></a>

        BigInteger temp = newN - newM;
        temp.signum *= -1;
        return temp;
    }
    // perform A = newM + newN
    BigInteger A;
    A.signum = newM.signum;
    List digitsM = newM.digits;
    List digitsN = newN.digits;
    List digitsA;
    digitsM.moveBack();
    digitsN.moveBack();
    while(digitsM.position() &gt; 0 &amp;&amp; digitsN.position() &gt; 0){
        long m = digitsM.movePrev();
        long n = digitsN.movePrev();
        digitsA.insertAfter(m - n);
        // digitsA.insertAfter(m - n &gt; 0 ? m - n : n - m);
        // if(newM.sign() &lt; 0 &amp;&amp; newN.sign() &lt; 0){
        //     digitsA.insertAfter(m - n &gt; 0 ? m - n : n - m);
        // }else{
        //     digitsA.insertAfter(m - n);
        // }
    }
    // Insert rest ListElement in digitsM or digitsN into digitsA
    while(digitsM.position() &gt; 0){
        long m = digitsM.movePrev();
        digitsA.insertAfter(m);
    }
    while(digitsN.position() &gt; 0){
        long n = digitsN.movePrev();
        digitsA.insertAfter(-n);
    }
    A.digits = digitsA;
    normalize(A);
    return A;
}



void shift(BigInteger&amp; N, int s){
    int pos = N.digits.position();
    N.digits.moveBack();
    for(int i = 0; i &lt; s; i++){
        N.digits.insertBefore(0);
    }

    // recovery position.
    while(N.digits.position() != pos){
        if(N.digits.position() &lt; pos){
            N.digits.moveNext();
        }else{
            N.digits.moveFront();
        }
    }
}

BigInteger BigInteger::mult(const BigInteger&amp; N) const{
    BigInteger newM(*this);
    BigInteger newN(N);
    BigInteger A;
    if(newM.sign() != newN.sign()){
        A.signum = -1;
    }else{
        A.signum = 1;
    }
    List digitsM = newM.digits;
    List digitsN = newN.digits;
    List digitsA;
    digitsM.moveBack();
    int SHIFT = 0;
    while(digitsM.position() &gt; 0){
        BigInteger scalerMult;
        scalerMult.signum = A.signum;
        long m = digitsM.movePrev();
        digitsN.moveBack();
        while(digitsN.position() &gt; 0){
            long n = digitsN.movePrev();
            scalerMult.digits.insertAfter(m * n);
            scalerMult.digits.moveFront();
            // Shift N with i position, and padding with 0;
        }
        shift(scalerMult, SHIFT);
        // A += scalerMult;    // TODO: rewrite the add operation, do not use add function.
        // int pos = scalerMult.digits.position();
        A.digits.moveBack();
        scalerMult.digits.moveBack();
        while(A.digits.position() &gt; 0 &amp;&amp; scalerMult.digits.position() &gt; 0){
            long a = A.digits.movePrev();
            long b = scalerMult.digits.movePrev();
            A.digits.setAfter(a + b);
        }
        while(scalerMult.digits.position() &gt; 0){
            long b = scalerMult.digits.movePrev();
            A.digits.moveFront();
            A.digits.insertAfter(b);
        }
        // Recovery position
        // while(scalerMult.digits.position() != pos){
        //     if(scalerMult.digits.position() &gt; pos){
        //         scalerMult.digits.movePrev();
        //     }else{
        //         scalerMult.digits.moveNext();
        //     }
        // }
        SHIFT ++;
    }
    normalize(A);

    return A;
}

std::string BigInteger::to_string(){
    if(this-&gt;signum == 0){
        return "0";
    }
    std::string s = "";
    if(this-&gt;signum == -1){
        s += '-';
    }
    digits.moveFront();
    while(digits.position() &lt; digits.length()){
        long elem = digits.moveNext();
        std::string elem_str = std::to_string(elem);

        // Padding with 0.
        while(digits.position() != 1 &amp;&amp; elem_str.length() &lt; POWER){
            elem_str = '0' + elem_str;
        }
        s += elem_str;
    
    }
    return s;
}

std::ostream&amp; operator&lt;&lt;( std::ostream&amp; stream, BigInteger N ){
    return stream &lt;&lt; N.to_string();
}

bool operator==( const BigInteger&amp; A, const BigInteger&amp; B ){
    BigInteger ret = A.sub(B);
    return ret.sign() == 0 ? true : false;
}

bool operator&lt;( const BigInteger&amp; A, const BigInteger&amp; B ){
    BigInteger ret = A.sub(B);
</font>    return ret.sign() &lt; 0 ? true : false;
}

bool operator&lt;=( const BigInteger&amp; A, const BigInteger&amp; B ){
    BigInteger ret = A.sub(B);
    return ret.sign() &lt;= 0 ? true : false;
}

bool operator&gt;( const BigInteger&amp; A, const BigInteger&amp; B ){
    BigInteger ret = A.sub(B);
    return ret.sign() &gt; 0 ? true : false;
}

<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/9/4014659580747/match0-0.html#2" target="0"><img src="./tm_2_2.gif" alt="other" border="0" align="left"></a>

bool operator&gt;=( const BigInteger&amp; A, const BigInteger&amp; B ){
    BigInteger ret = A.sub(B);
    return ret.sign() &gt;= 0 ? true : false;
}

BigInteger operator+( const BigInteger&amp; A, const BigInteger&amp; B ){
    return A.add(B);
}

BigInteger operator+=( BigInteger&amp; A, const BigInteger&amp; B ){
</font>    A = A.add(B);
    return A;
}

BigInteger operator-( const BigInteger&amp; A, const BigInteger&amp; B ){
    return A.sub(B);
}

BigInteger operator-=( BigInteger&amp; A, const BigInteger&amp; B ){
    A = A.sub(B);
    return A;
}

BigInteger operator*( const BigInteger&amp; A, const BigInteger&amp; B ){
<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/9/4014659580747/match0-0.html#3" target="0"><img src="./tm_3_1.gif" alt="other" border="0" align="left"></a>

    return A.mult(B);
}

BigInteger operator*=( BigInteger&amp; A, const BigInteger&amp; B ){
    A = A.mult(B);
    return A.mult(B);
</font>}
</pre>



</body></html>