
<!-- saved from url=(0062)http://moss.stanford.edu/results/2/9542875811840/match8-1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/smehrete/pa6/BigInteger.cpp</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/fall24/cdongon/pa6/BigInteger.cpp<p></p><pre>// Christian Dongon, 2063912, pa6

#include "BigInteger.h"
#include "List.h"

int power = 9;
long base = 1000000000;

BigInteger::BigInteger() {
  signum = 0;
  digits = List();
}

BigInteger::BigInteger(std::string s) {
  if (s.length() == 0) throw std::invalid_argument("BigInteger: Constructor: empty string");
<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/2/9542875811840/match8-0.html#3" target="0"><img src="./tm_3_3.gif" alt="other" border="0" align="left"></a>

  signum = (s[0] == '-') ? -1 : 1;
  if (s[0] == '+' || s[0] == '-') s = s.substr(1);
  for (char c : s) {
    if (!isdigit(c)) throw std::invalid_argument("BigInteger: Constructor: non-numeric string");
  }
  int pos = s.length() % power;
</font><a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/2/9542875811840/match8-0.html#2" target="0"><img src="./tm_2_13.gif" alt="other" border="0" align="left"></a>

  if (pos) digits.insertBefore(stol(s.substr(0, pos)));
  for (pos = s.length() % power; pos &lt; (int)s.length(); pos += power) {
    digits.insertBefore(stol(s.substr(pos, power)));
  }
}

BigInteger::BigInteger(const BigInteger&amp; N) {
  this-&gt;signum = N.signum;
  this-&gt;digits = N.digits;
}

int BigInteger::sign() const {
  return this-&gt;signum;
}

int BigInteger::compare(const BigInteger&amp; N) const {
  if (this-&gt;signum != N.signum) return this-&gt;signum &gt; N.signum ? 1 : -1;
  else if (this-&gt;signum == 0) return 0;

  List tempdigits = this-&gt;digits;
  List tempn = N.digits;

  int cmp = 0;
  if (tempdigits.length() != tempn.length()) {
    cmp = tempdigits.length() &gt; tempn.length() ? 1 : -1;
  } else {
    tempdigits.moveFront();
    tempn.moveFront();
    while (tempdigits.position() &lt; tempdigits.length() &amp;&amp; cmp == 0) {
</font>      cmp = tempdigits.peekNext() &gt; tempn.peekNext() ? 1 : (tempdigits.peekNext() &lt; tempn.peekNext() ? -1 : 0);
<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/2/9542875811840/match8-0.html#0" target="0"><img src="./tm_0_40.gif" alt="other" border="0" align="left"></a>

      tempdigits.moveNext();
      tempn.moveNext();
    }
  }
  return this-&gt;signum == 1 ? cmp : -cmp;
}

void negateList(List&amp; L) {
  for (L.moveFront(); L.position() &lt; L.length(); L.moveNext()) {
    L.setAfter(L.peekNext() * -1);
  }
}

void sumList(List&amp; S, List A, List B, int sgn) {
  S.clear();
  for (B.moveFront(); B.position() &lt; B.length(); B.moveNext()) {
    B.setAfter(sgn * B.peekNext());
  }
  A.moveBack();
  B.moveBack();
  while (A.position() &gt; 0 || B.position() &gt; 0) {
    S.insertAfter((A.position() &gt; 0 ? A.peekPrev() : 0) + (B.position() &gt; 0 ? B.peekPrev() : 0));
    if (A.position() &gt; 0) A.movePrev();
    if (B.position() &gt; 0) B.movePrev();
  }
  S.moveFront();
  while (S.front() == 0 &amp;&amp; S.length() &gt; 1) {
    S.eraseAfter();
  }
}

int normalizeList(List&amp; L) {
  if (L.front() == 0) return 0;
  int i = 1;
  if (L.front() &lt; 0) {
    i = -1;
    negateList(L);
  }
  L.moveBack();
  int car = 0;
  ListElement a = 0;
  while (L.position() &gt; 0) {
    a = L.peekPrev() + car;
    car = 0;
    if (a &lt; 0) {
      car = -1;
      a += base;
    }
    L.setBefore(a % base);
    car += a / base;
    L.movePrev();
  }
  if (car &gt; 0) {
    L.moveFront();
    L.insertAfter(car);
  }
  return i;
}

void shiftList(List&amp; L, int p) {
  L.moveBack();
  for (int i = 0; i &lt; p; i++) {
    L.insertAfter(0);
  }
}

void scalarMultList(List&amp; L, ListElement m) {
  for (L.moveFront(); L.position() &lt; L.length(); L.moveNext()) {
    L.setAfter(L.peekNext() * m);
  }
}

void BigInteger::makeZero() {
  signum = 0;
  digits.clear();
}

void BigInteger::negate() {
  signum *= -1;
}

BigInteger BigInteger::add(const BigInteger&amp; N) const {
  BigInteger sum;
  BigInteger tempdigits = *this;
  BigInteger tempn = N;
  int sign = 1;
  if (this-&gt;signum == -1) negateList(tempdigits.digits);
  if (N.signum == -1) sign = -1;
  sumList(sum.digits, tempdigits.digits, tempn.digits, sign);
  sum.signum = normalizeList(sum.digits);
  if (normalizeList(sum.digits) == -1) negateList(sum.digits);
  return sum;
}

BigInteger BigInteger::sub(const BigInteger&amp; N) const {
  BigInteger ntemp = N;
  negateList(ntemp.digits);
  BigInteger sum = add(ntemp);
  return sum;
}

BigInteger BigInteger::mult(const BigInteger&amp; N) const {
  BigInteger res;
  if (this-&gt;signum == 0 || N.signum == 0) return res;
  List sum;
  List Ntemp = N.digits;
</font>  List temp;
  for (int shift = 0; Ntemp.position() &gt; 0; ++shift, Ntemp.movePrev()) {
    temp = this-&gt;digits;
<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/2/9542875811840/match8-0.html#1" target="0"><img src="./tm_1_13.gif" alt="other" border="0" align="left"></a>

    scalarMultList(temp, Ntemp.peekPrev());
    shiftList(temp, shift);
    List sumtemp = sum;
    sumList(sum, sumtemp, temp, 1);
    normalizeList(sum);
  }
  res.digits = sum;
  res.signum = (this-&gt;signum == N.signum) ? 1 : -1;
  return res;
}

std::string BigInteger::to_string() {
  if (this-&gt;signum == 0) return "0";
  std::string s = (this-&gt;signum == -1) ? "-" : "";
  digits.moveFront();
  for (; digits.front() == 0 &amp;&amp; digits.length() &gt; 1; digits.eraseAfter()) {}
  for (digits.moveFront(); digits.position() &lt; digits.length(); digits.moveNext()) {
    std::string d = std::to_string(digits.peekNext());
    std::string m = "";
    for (; (int)m.length() + (int)d.length() &lt; power &amp;&amp; digits.position() &gt; 0; m += '0') {}
    s += m + d;
  }
  return s;
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, BigInteger N) {
</font>  return stream &lt;&lt; N.to_string();
}

bool operator==(const BigInteger&amp; A, const BigInteger&amp; B) {
  return A.compare(B) == 0;
}

bool operator&lt;(const BigInteger&amp; A, const BigInteger&amp; B) {
  return A.compare(B) &lt; 0;
}

bool operator&lt;=(const BigInteger&amp; A, const BigInteger&amp; B) {
  return A.compare(B) &lt;= 0;
}

bool operator&gt;(const BigInteger&amp; A, const BigInteger&amp; B) {
  return A.compare(B) &gt; 0;
}

bool operator&gt;=(const BigInteger&amp; A, const BigInteger&amp; B) {
  return A.compare(B) &gt;= 0;
}

BigInteger operator+(const BigInteger&amp; A, const BigInteger&amp; B) {
  return A.add(B);
}

BigInteger operator+=(BigInteger&amp; A, const BigInteger&amp; B) {
  A = A.add(B);
  return A;
}

BigInteger operator-(const BigInteger&amp; A, const BigInteger&amp; B) {
  return A.sub(B);
}

BigInteger operator-=(BigInteger&amp; A, const BigInteger&amp; B) {
  A = A.sub(B);
  return A;
}

BigInteger operator*(const BigInteger&amp; A, const BigInteger&amp; B) {
  return A.mult(B);
}

BigInteger operator*=(BigInteger&amp; A, const BigInteger&amp; B) {
  A = A.mult(B);
  return A;
}



</pre>



</body></html>