
<!-- saved from url=(0062)http://moss.stanford.edu/results/7/7834820277962/match1-1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/etthnguy/pa6/BigInteger.cpp</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter25/hreddy/pa6/BigInteger.cpp<p></p><pre>/***
* Harinand Reddy // First and Last Name
* hreddy // UCSC UserID
* 2025 Winter CSE101 PA6 // Replace ID with assignment number 
* BigInteger.cpp // FileName
* Implementation for Big Integer Abstract Data Type // Description
***/ 



#include&lt;string&gt;
#include&lt;sstream&gt;
#include&lt;stdexcept&gt;
#include"BigInteger.h"

<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/7/7834820277962/match1-0.html#4" target="0"><img src="./tm_4_5.gif" alt="other" border="0" align="left"></a>

const long base = 1000000000;
const int power = 9;

void normalize(BigInteger&amp; N)
{
    while (N.digits.length() &gt; 0 &amp;&amp; N.digits.front() == 0)
    {
        N.digits.moveFront();
        N.digits.eraseAfter();
    }
    if (N.digits.length() == 0)
    {
        N.signum = 0;
        return;
    }
    
    for (N.digits.moveBack(); N.digits.position() &gt; 0; )
    {
        long carry = 0;
        long elem = N.digits.movePrev();
        if (elem &lt; 0)
        {
            if (N.digits.position() == 0)
            {
                N.digits.setAfter(-elem);
                N.signum = -N.signum;
</font>                break;
            }
            carry = -1;
<a name="13"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/7/7834820277962/match1-0.html#13" target="0"><img src="./tm_3_1.gif" alt="other" border="0" align="left"></a>

            while (elem + -carry * base &lt; 0)
            {
                carry--;
            }
            N.digits.setAfter(elem + -carry * base);
        }
        else if (elem &gt;= base)
        {
            carry = 1;
</font><a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/7/7834820277962/match1-0.html#1" target="0"><img src="./tm_1_9.gif" alt="other" border="0" align="left"></a>

            while (elem + -carry * base &gt;= base)
            {
                carry++;
            }
            N.digits.setAfter(elem + -carry * base);
        }
        if (N.digits.position() &gt; 0)
        {
            long prev_elem = N.digits.movePrev();
            N.digits.setAfter(prev_elem + carry);
            N.digits.moveNext();
        }
        else if (carry &lt;= -1)
        {
            N.digits.setAfter(-N.digits.front());
            N.signum = -1;
            if (N.digits.front() &lt; 0)
            {
                N.digits.setAfter(base + N.digits.front());
                for (N.digits.moveNext(); N.digits.position() &lt; N.digits.length(); )
                {
                    long n = N.digits.moveNext();
                    N.digits.setBefore(base - n);
                }
                break;
            }
            
        }
        else if (carry &gt;= 1)
        {
            N.digits.insertAfter(carry);
        }
    }
    N.digits.moveFront();
}

BigInteger::BigInteger()
{
    signum = 0;
    digits = List();
}

BigInteger::BigInteger(long x)
</font>{
    signum = (x &gt; 0) - (x &lt; 0);
    digits = List();
    x = std::abs(x);
    while (x &gt; 0)
    {
        digits.insertAfter(x % base);
        x /= base;
    }
}

<a name="12"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/7/7834820277962/match1-0.html#12" target="0"><img src="./tm_2_1.gif" alt="other" border="0" align="left"></a>

BigInteger::BigInteger(std::string s)
{
    if (s.length() == 0)
    {
        throw std::invalid_argument("BigInteger: Constructor: empty string");
    }
    if ((s[0] != '-' &amp;&amp; s[0] != '+') &amp;&amp; (!isdigit(s[0])))
</font>    {
        throw std::invalid_argument("BigInteger: Constructor: non-numeric string");
    }
    for (int i = s.length() - 1; i &gt; 0; i--)
    {
        if (!isdigit(s[i]))
        {
            throw std::invalid_argument("BigInteger: Constructor: non-numeric string");
        }
    }
    if (s == "0")
    {
        return;
    }
    if (s[0] == '-' || s[0] == '+')
    {
        if (s[0] == '-')
        {
<a name="6"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/7/7834820277962/match1-0.html#6" target="0"><img src="./tm_1_4.gif" alt="other" border="0" align="left"></a>

            this-&gt;signum = -1;
        }
        else
        {
            this-&gt;signum = 1;
        }
        s = s.substr(1);
    }
    else
    {
        this-&gt;signum = 1;
    }

    int length = s.length();
    for (int i = 1; length - i * power &gt; - power; i++)
    {
        int pos = length - i * power;
        int count = power;
        std::string num_str;
        if (pos &lt;= 0)
        {
            num_str = s.substr(0, pos + power);
</font>        }
        else
        {
            num_str = s.substr(pos, count);
        }
<a name="5"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/7/7834820277962/match1-0.html#5" target="0"><img src="./tm_0_4.gif" alt="other" border="0" align="left"></a>

        long num = std::stol(num_str);
        this-&gt;digits.insertAfter(num);
    }
}

BigInteger::BigInteger(const BigInteger&amp; N)
{
    this-&gt;signum = N.signum;
    this-&gt;digits = List(N.digits);
}

int BigInteger::sign() const
{
    return signum;
}

int BigInteger::compare(const BigInteger&amp; N) const
{
    BigInteger ret = this-&gt;sub(N);
    return ret.sign();
}

void BigInteger::makeZero()
{
    this-&gt;signum = 0;
    this-&gt;digits.clear();
}

void BigInteger::negate()
</font>{
    if (this-&gt;signum != 0) 
    {
        this-&gt;signum = -this-&gt;signum;
    }
}

<a name="11"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/7/7834820277962/match1-0.html#11" target="0"><img src="./tm_1_1.gif" alt="other" border="0" align="left"></a>

BigInteger BigInteger::add(const BigInteger&amp; N) const
{
    BigInteger X(*this);
    BigInteger Y(N);
    if (X.sign() != Y.sign())
    {
        if (Y.sign() &gt; 0)
        {
            // X.signum = -X.signum;
            return Y.sub(X);
        }
        Y.signum = -Y.signum;
</font><a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/7/7834820277962/match1-0.html#2" target="0"><img src="./tm_2_7.gif" alt="other" border="0" align="left"></a>

        return X.sub(Y);
    }
    BigInteger A;
    A.signum = signum;
    List digitsX = X.digits;
    List digitsY = Y.digits;
    List digitsA;
    digitsX.moveBack();
    digitsY.moveBack();
    while (digitsX.position() &gt; 0 &amp;&amp; digitsY.position() &gt; 0)
    {
        long x = digitsX.movePrev();
        long y = digitsY.movePrev();
        digitsA.insertAfter(x + y);
    }

    while (digitsX.position() &gt; 0)
    {
        long x = digitsX.movePrev();
        digitsA.insertAfter(x);
    }

    while (digitsY.position() &gt; 0)
    {
        long y = digitsY.movePrev();
        digitsA.insertAfter(y);
    }

    A.digits = digitsA;
    normalize(A);
    return A;
}

BigInteger BigInteger::sub(const BigInteger&amp; N) const
{
    BigInteger X(*this);
    BigInteger Y(N);

    if (X.sign() != Y.sign())
    {
        Y.signum = -Y.signum;
</font>        return X.add(Y);
    }
    if (Y.digits.length() &gt; X.digits.length())
    {
        BigInteger temp = Y - X;
        temp.signum = -temp.signum;
        return temp;
    }
<a name="9"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/7/7834820277962/match1-0.html#9" target="0"><img src="./tm_4_2.gif" alt="other" border="0" align="left"></a>

    if (Y.digits.length() == X.digits.length() )
    {
        if (Y.digits.length() &gt; 0)
        {
            if (Y.digits.front() &gt; X.digits.front())
            {
                BigInteger temp = Y - X;
</font>                temp.signum = -temp.signum;
                return temp;
            }
        }
    }
<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/7/7834820277962/match1-0.html#3" target="0"><img src="./tm_3_7.gif" alt="other" border="0" align="left"></a>

    BigInteger A;
    A.signum = X.signum;
    List digitsX = X.digits;
    List digitsY = Y.digits;
    List digitsA;
    digitsX.moveBack();
    digitsY.moveBack();
    while (digitsX.position() &gt; 0 &amp;&amp; digitsY.position() &gt; 0)
    {
        long x = digitsX.movePrev();
        long y = digitsY.movePrev();
        digitsA.insertAfter(x - y);
    }

    while (digitsX.position() &gt; 0)
    {
        long x = digitsX.movePrev();
        digitsA.insertAfter(x);
    }

    while (digitsY.position() &gt; 0)
    {
        long y = digitsY.movePrev();
        digitsA.insertAfter(-y);
    }

    A.digits = digitsA;
    normalize(A);
    return A;
}



void shift(BigInteger&amp; N, int s)
{
    int pos = N.digits.position();
    N.digits.moveBack();
</font>    int i = 0;
    while (i &lt; s)
    {
        N.digits.insertBefore(0);
        i++;
    }

<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/7/7834820277962/match1-0.html#0" target="0"><img src="./tm_0_14.gif" alt="other" border="0" align="left"></a>

    while (N.digits.position() != pos)
    {
        if (N.digits.position() &lt; pos)
        {
            N.digits.moveNext();
        }
        else
        {
            N.digits.moveFront();
        }
    }
}

BigInteger BigInteger::mult(const BigInteger&amp; N) const
{
    BigInteger X(*this);
    BigInteger Y(N);
    BigInteger A;
    if (X.sign() != Y.sign())
    {
        A.signum = -1;
    }
    else
    {
        A.signum = 1;
    }
    List digitsX = X.digits;

    List digitsY = Y.digits;
    
    List digitsA;

    digitsX.moveBack();
    int SHIFT = 0;
    
    while(digitsX.position() &gt; 0)
    {
        BigInteger Mult;

        Mult.signum = A.signum;
        long x = digitsX.movePrev();
        digitsY.moveBack();
        while (digitsY.position() &gt; 0)
        {
            long y = digitsY.movePrev();
            Mult.digits.insertAfter(x * y);
            Mult.digits.moveFront();
        }

        shift(Mult, SHIFT);

        A.digits.moveBack();

        Mult.digits.moveBack();

        while (A.digits.position() &gt; 0 &amp;&amp; Mult.digits.position() &gt; 0)
        {
            long a = A.digits.movePrev();
            long b = Mult.digits.movePrev();
            A.digits.setAfter(a + b);
        }

        while (Mult.digits.position() &gt; 0)
        {
            long b = Mult.digits.movePrev();
            A.digits.moveFront();
            A.digits.insertAfter(b);
        }

        SHIFT ++;
    }
    normalize(A);

    return A;
}

std::string BigInteger::to_string()
{
    if (this-&gt;signum == 0)
    {
        return "0";
    }
    std::string s = "";
    if (this-&gt;signum == -1)
    {
        s += '-';
</font>    }
    digits.moveFront();
    bool checkLeadingZeroes = false;
    while (digits.position() &lt; digits.length())
    {
<a name="10"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/7/7834820277962/match1-0.html#10" target="0"><img src="./tm_0_1.gif" alt="other" border="0" align="left"></a>

        if (checkLeadingZeroes) {
            long elem = digits.moveNext();
            std::string element = std::to_string(elem);

            while (digits.position() != 1 &amp;&amp; element.length() &lt; power)
            {
                element = '0' + element;
            }
            s += element;
</font>        }
        else {
            while (digits.peekNext() == 0) 
            {
                digits.moveNext();
            }
            checkLeadingZeroes = true;
        }
        
    }
    if (s[0] == '-') {
        if (s[1] == '0') {
            s  = s[0] + s.substr(2, s.length());
        }
    }
    else {
        if (s[0] == '0') {
            s = s.substr(1, s.length());
        }
    }
    return s;
}

<a name="7"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/7/7834820277962/match1-0.html#7" target="0"><img src="./tm_2_3.gif" alt="other" border="0" align="left"></a>

std::ostream&amp; operator&lt;&lt;( std::ostream&amp; stream, BigInteger N )
{
    return stream &lt;&lt; N.to_string();
}

bool operator==( const BigInteger&amp; A, const BigInteger&amp; B )
{
    BigInteger ret = A.sub(B);
    return ret.sign() == 0 ? true : false;
}

bool operator&lt;( const BigInteger&amp; A, const BigInteger&amp; B )
{
    BigInteger ret = A.sub(B);
</font>    return ret.sign() &lt; 0 ? true : false;
}

bool operator&lt;=( const BigInteger&amp; A, const BigInteger&amp; B )
{
    BigInteger ret = A.sub(B);
    return ret.sign() &lt;= 0 ? true : false;
}

bool operator&gt;( const BigInteger&amp; A, const BigInteger&amp; B )
{
    BigInteger ret = A.sub(B);
    return ret.sign() &gt; 0 ? true : false;
}

<a name="8"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/7/7834820277962/match1-0.html#8" target="0"><img src="./tm_3_2.gif" alt="other" border="0" align="left"></a>

bool operator&gt;=( const BigInteger&amp; A, const BigInteger&amp; B )
{
    BigInteger ret = A.sub(B);
    return ret.sign() &gt;= 0 ? true : false;
}

BigInteger operator+( const BigInteger&amp; A, const BigInteger&amp; B )
{
    return A.add(B);
}

BigInteger operator+=( BigInteger&amp; A, const BigInteger&amp; B )
</font>{
    A = A.add(B);
    return A;
}

BigInteger operator-( const BigInteger&amp; A, const BigInteger&amp; B )
{
    return A.sub(B);
}

BigInteger operator-=( BigInteger&amp; A, const BigInteger&amp; B )
{
    A = A.sub(B);
    return A;
}

BigInteger operator*( const BigInteger&amp; A, const BigInteger&amp; B )
{
<a name="14"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/7/7834820277962/match1-0.html#14" target="0"><img src="./tm_4_1.gif" alt="other" border="0" align="left"></a>

    return A.mult(B);
}

BigInteger operator*=( BigInteger&amp; A, const BigInteger&amp; B )
{
    A = A.mult(B);
    return A.mult(B);
</font>}</pre>



</body></html>