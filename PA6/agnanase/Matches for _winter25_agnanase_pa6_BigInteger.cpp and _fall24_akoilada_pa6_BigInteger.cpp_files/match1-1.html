
<!-- saved from url=(0062)http://moss.stanford.edu/results/3/4374093143652/match1-1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/agnanase/pa6/BigInteger.cpp</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/fall24/akoilada/pa6/BigInteger.cpp<p></p><pre> /*
 * Arpana Koilada (@akoilada)
 * CSE101
 * pa6
* BigInteger.cpp
 */

#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;stdexcept&gt;
#include"BigInteger.h"
<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/3/4374093143652/match1-0.html#3" target="0"><img src="./tm_3_4.gif" alt="other" border="0" align="left"></a>

using namespace std;

const int power = 9;
const long base = 1000000000; // 10^9

void addNum(List&amp; S, List A, List B, int sgn);
void negateL(List&amp; L);
void List_shift(List&amp; L, int p);

void normL(List&amp; L, int op);

void list_scalarmult(List&amp; L, long m);

BigInteger::BigInteger(){
    signum = 0;
}

BigInteger::BigInteger(long x){
    if (x == 0){
        signum = 0;
</font>        return;
    }if (x &gt; 0){
        signum = 1;
        
    }else{
        signum = -1;
        x *= -1;
    }
    string s = std::to_string(x);
    size_t start_index = 0;

    signum = 1;
    if (s[0] == '+' || s[0] == '-') {
        start_index = 1;

        if (s[0] == '-'){
            signum = -1;
        }else{
            signum = 1;
        }
    }

    for (size_t i = start_index; i &lt; s.length(); i++) {
        if (!isdigit(s[i])) {
            throw std::invalid_argument("Constructor, not a numeric string");
        }
    }
    if(s.length() == 1 &amp;&amp; s[start_index] == '0'){
            signum = 0;
            return;
    }
    size_t i = s.length() - 1;
    bool flag = true;
    while(flag){
        string val = "";
        bool val_set = false;
        for(int j = 0; j &lt; power; j++){
            if(i &gt;= start_index){
                val_set = true;
                val.insert(0, 1, s[i]);
                if(i != 0){
                    i--;
                }else{
                    flag = false;
                    break;
                }
            }else{
                flag = false;
                break;
            }
        }
        if(val_set){
<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/3/4374093143652/match1-0.html#4" target="0"><img src="./tm_4_2.gif" alt="other" border="0" align="left"></a>

            digits.insertAfter(std::stol(val));
        }
    }


}

BigInteger::BigInteger(std::string s){
    if (s.empty()) {
        throw std::invalid_argument("Constructor , empty string");
    }
    size_t start_index = 0;

    signum = 1;
    if (s[0] == '+' || s[0] == '-') {
        start_index = 1;
</font>        if (s[0] != '-'){
            signum = 1;
        }
        else{
            signum = -1;
        }
    }
    for (size_t i = start_index; i &lt; s.length(); i++) {
        if (!isdigit(s[i])) {
            throw std::invalid_argument("Constructor, not a numeric string");
        }
    }

    if(s.length() == 1 &amp;&amp; s[start_index] == '0'){
            signum = 0;
            return;
    }
    
    size_t i = s.length() - 1;
    bool flag = true;
    while(flag){
        string val = "";
        bool val_set = false;
        for(int j = 0; j &lt; power; j++){
            if(i &gt;= start_index){
                val_set = true;
                val.insert(0, 1, s[i]);
                if(i == 0){
                    flag = false;
                    break;
                    
                }else{
                    i--;
                }
            }else{
                flag = false;
                break;
            }
        }
        if(val_set){
            digits.insertAfter(std::stol(val));
        }
    }
}

BigInteger::BigInteger(const BigInteger&amp; N){
    signum = N.signum;
    digits = N.digits;
    
}
int BigInteger::sign() const{
    return signum;
}

<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/3/4374093143652/match1-0.html#0" target="0"><img src="./tm_0_43.gif" alt="other" border="0" align="left"></a>

int BigInteger::compare(const BigInteger&amp; N) const{
    if(signum &lt; N.signum){
        return -1;
    }
    if(signum &gt; N.signum){
        return 1;
    }
    if(digits.length() &lt; N.digits.length()){
        return -1 * signum;
    }
    if(digits.length() &gt; N.digits.length()){
        return signum;
    }
    if(digits.equals(N.digits)){
        return 0;
    }

    List l1 = this-&gt;digits;
    List l2 = N.digits;
    l1.moveFront();
    l2.moveFront();
    while(l1.position() &lt; l1.length() &amp;&amp; l2.position() &lt; l2.length()){
        if(l1.peekNext() &lt; l2.peekNext()){
            return -1 * signum;
        }
        if(l1.peekNext() &gt; l2.peekNext()){
            return signum;
        }
        l1.moveNext();
        l2.moveNext();
    }
    return 0;
}

void BigInteger::makeZero(){
    signum = 0;
    digits.clear();
}

void BigInteger::negate(){
    signum *= -1;
}


BigInteger BigInteger::add(const BigInteger&amp; N) const{

    BigInteger A = *this;
    BigInteger B = N;
    BigInteger C(0);
    C.signum = 1;
    if((A.signum == 1 &amp;&amp; B.signum == 1) || (A.signum == -1 &amp;&amp; B.signum == -1)){
        if(A.signum == 1 &amp;&amp; B.signum == 1){
            C.signum = 1;
        }
        else{
            A.signum = 1;
            B.signum = 1;
            C.signum = -1;
        }
        addNum(C.digits, A.digits, B.digits, 1);
        normL(C.digits, 1);
        return C;
    }
    if(A.signum == 1 &amp;&amp; B.signum == -1){
        B.signum = 1;
        return A.sub(B);
    }
    if(A.signum == -1 &amp;&amp; B.signum == 1){
        A.signum = 1;
        return B.sub(A);
    }
    return C;

}

BigInteger BigInteger::sub(const BigInteger&amp; N) const{
    BigInteger A = *this;
    BigInteger B = N;
    BigInteger C(0);
    C.signum = 1;
    if(A == B){
        C.signum = 0;
        return C;
    }
    if((A.signum == 1 &amp;&amp; B.signum == 1) || (A.signum == -1 &amp;&amp; B.signum == -1)){
        if(A.signum != -1 || B.signum != -1){
            addNum(C.digits, A.digits, B.digits, -1);
            ;
        }
        else{
            addNum(C.digits, B.digits, A.digits, -1);
        }
        if(C.digits.peekNext() &lt; 0){
            C.signum = -1;
            negateL(C.digits);
        }
        normL(C.digits, -1);

        C.digits.moveFront();
        if(C.digits.peekNext() &lt; 0){
            C.signum = -1;
            negateL(C.digits);
            normL(C.digits, -1);
        }

        return C;
    }
    if((A.signum == -1 &amp;&amp; B.signum == 1) || (A.signum == 1 &amp;&amp; B.signum == -1)){
        bool c_neg = false;
        if(A.signum != -1 || B.signum != 1){
            B.signum = 1;
            C.signum = 1;
            
        }
        else{
            A.signum = 1;
            c_neg = true;
        }
        C = A + B;
        if(c_neg){
            C.signum = -1;
        }
        return C;
    }
    return C;
}

BigInteger BigInteger::mult(const BigInteger&amp; N) const{
    BigInteger A = *this;
    BigInteger B = N;
    BigInteger C(0);
    C.signum = 1;

    if(A.signum == B.signum){
        C.signum = 1;
    }
    else if(A.signum != B.signum &amp;&amp; A.signum != 0 &amp;&amp; B.signum != 0){
        C.signum = -1;
    }
    else if(A.signum == 0 || B.signum == 0){
        C.signum = 0;
        return C;
    }

    if (digits.length() &lt; N.digits.length()) {
        A = N;
        B = *this;
    }
    
    B.digits.moveBack();
    int shift = 0;
    while(B.digits.position() &gt; 0){
        List temp = A.digits;
        List currRes = C.digits;
        list_scalarmult(temp, B.digits.peekPrev());
        List_shift(temp, shift);
        C.digits.clear();
        addNum(C.digits, currRes, temp, 1);
        normL(C.digits, 1);
        B.digits.movePrev();
        shift++;
    }
    return C;

}

std::string BigInteger::to_string(){
    string s = "";
    if (signum == 0){
        s += "0";
        return s;
    }
    if(digits.length() == 0){
        throw std::invalid_argument("Digits is empty");
    }


    if (signum == -1){
        s += "-";
    }
    digits.moveFront();
    while(digits.peekNext() == 0){
        digits.moveNext();
    }
    bool is_first = true;
    while(digits.position() &lt; digits.length()){
        string tempRes = std::to_string(digits.peekNext());
        
        if(!is_first){
</font>            if(tempRes.length() != power){
                
                tempRes.insert(0, power - tempRes.length(), '0');
                
            }
        }
        s += tempRes;
        if(is_first){
<a name="6"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/3/4374093143652/match1-0.html#6" target="0"><img src="./tm_1_1.gif" alt="other" border="0" align="left"></a>

            is_first = false;
        }
        digits.moveNext();
    }
    return s;
}

std::ostream&amp; operator&lt;&lt;( std::ostream&amp; stream, BigInteger N ){
    return stream &lt;&lt; N.to_string();
</font>}

bool operator==( const BigInteger&amp; A, const BigInteger&amp; B ){
    return A.compare(B) == 0;
}

<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/3/4374093143652/match1-0.html#2" target="0"><img src="./tm_2_5.gif" alt="other" border="0" align="left"></a>

bool operator&lt;( const BigInteger&amp; A, const BigInteger&amp; B ){
    return A.compare(B) == -1;
}

bool operator&lt;=( const BigInteger&amp; A, const BigInteger&amp; B ){
    return A &lt; B || A == B;
}

bool operator&gt;( const BigInteger&amp; A, const BigInteger&amp; B ){
    return A.compare(B) == 1;
}

bool operator&gt;=( const BigInteger&amp; A, const BigInteger&amp; B ){
    return A &gt; B || A == B;
}

BigInteger operator+( const BigInteger&amp; A, const BigInteger&amp; B ){
    return A.add(B);
}

BigInteger operator+=( BigInteger&amp; A, const BigInteger&amp; B ){
</font>    A = A.add(B);
    return A;
}

BigInteger operator-( const BigInteger&amp; A, const BigInteger&amp; B ){
    return A.sub(B);
}

BigInteger operator-=( BigInteger&amp; A, const BigInteger&amp; B ){
    A = A.sub(B);
    return A;
}

BigInteger operator*( const BigInteger&amp; A, const BigInteger&amp; B ){
    return A.mult(B);
}


<a name="5"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/3/4374093143652/match1-0.html#5" target="0"><img src="./tm_0_1.gif" alt="other" border="0" align="left"></a>

BigInteger operator*=( BigInteger&amp; A, const BigInteger&amp; B ){
    A = A.mult(B);
    return A;
}


void negateL(List&amp; L){
    L.moveFront();
    while (L.position() &lt; L.length()) {
</font><a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/3/4374093143652/match1-0.html#1" target="0"><img src="./tm_1_13.gif" alt="other" border="0" align="left"></a>

        L.setAfter(L.peekNext() * -1);
        L.moveNext();
    }   
}

void addNum(List&amp; S, List A, List B, int sgn){
    S.moveBack();
    A.moveBack();
    B.moveBack();
    while(A.position() &gt; 0 &amp;&amp; B.position() &gt; 0){
        S.insertAfter(A.peekPrev() + sgn * B.peekPrev());
        A.movePrev();
        B.movePrev();
    }
    while(A.position() &gt; 0){
        S.insertAfter(A.peekPrev());
        A.movePrev();
    }
    while (B.position() &gt; 0) {
        S.insertAfter(sgn * B.peekPrev());
        B.movePrev();
    }
}

void normL(List&amp; L, int op){
    if(op == 1){
        L.moveBack();
        ListElement carry = 0;
        while(L.position() &gt; 0){
            ListElement val = L.peekPrev() + carry;
            int digits = 0; do { val /= 10; digits++; } while (val != 0);
            val = L.peekPrev() + carry;
            if(digits &gt; power){
                L.setBefore((val) % base);
                carry = (val) / base;
            }
            else{
                if(carry != 0){
                    L.setBefore(val);
                    carry = 0;
                }
            }
            L.movePrev();
        }
        if(carry != 0){
            L.insertBefore(carry);
        }
    }
    else{
        L.moveBack();
        ListElement carry = 0;
        while(L.position() &gt; 0){
            ListElement val = L.peekPrev() + carry;
            carry = 0;
            if(val &lt; 0){
                carry = -1;
                L.setBefore(val + base);
            }
            else{
                L.setBefore(val + carry);
                carry = 0;
            }
            L.movePrev();
        }

        
    }
}
void List_shift(List&amp; L, int p){
</font>    L.moveBack();
    for (int i = 0; i &lt; p; i++) {
        L.insertAfter(0);
    }
}

void list_scalarmult(List&amp; L, long m){
    L.moveFront();
    while (L.position() &lt; L.length()) {
        L.setAfter(L.peekNext() * m);
        L.moveNext();
    }
}
</pre>



</body></html>