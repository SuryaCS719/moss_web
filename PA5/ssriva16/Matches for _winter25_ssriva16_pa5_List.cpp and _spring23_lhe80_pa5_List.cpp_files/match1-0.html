
<!-- saved from url=(0061)http://moss.stanford.edu/results/8/265063914443/match1-0.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/ssriva16/pa5/List.cpp</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter25/ssriva16/pa5/List.cpp<p></p><pre>#include "List.h"
#include &lt;stdexcept&gt;

using namespace std;

List::Node::Node(ListElement x) {
    data = x;
    next = nullptr;
    prev = nullptr;
}

List::List() {
    frontDummy = new Node(-1);
    backDummy = new Node(-2);
    frontDummy-&gt;next = backDummy;
    backDummy-&gt;prev = frontDummy;
    beforeCursor = frontDummy;
    afterCursor = backDummy;
    pos_cursor = 0;
    num_elements = 0;
}

List::List(const List&amp; L) { 
    frontDummy = new Node(-1);
    backDummy = new Node(-2);
    frontDummy-&gt;next = backDummy;
    backDummy-&gt;prev = frontDummy;
    beforeCursor = frontDummy;
    afterCursor = backDummy;
    pos_cursor = 0;
    num_elements = 0;

    Node *X = L.frontDummy-&gt;next;
    while (X != L.backDummy) {
        this-&gt;insertAfter(X-&gt;data);
        moveNext();
        X = X-&gt;next;
    }
    moveFront();
}

List::~List() {
    clear();
    delete frontDummy;
    delete backDummy;
}


int List::length() const{
    return num_elements;
}

ListElement List::front() const{
    if (num_elements == 0) {
        throw length_error("Error: empty lisy");
    }
<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/8/265063914443/match1-1.html#2" target="1"><img src="./tm_2_5.gif" alt="other" border="0" align="left"></a>

    return frontDummy-&gt;next-&gt;data;
}

ListElement List::back() const{
    if (num_elements == 0) {
        throw length_error("Error: List is empty");
    }
    return backDummy-&gt;prev-&gt;data;
}

int List::position() const{
    if (pos_cursor &lt; 0 || pos_cursor &gt; num_elements) {
        throw range_error("Error: position underfined");
    }
    return pos_cursor;
}

ListElement List::peekNext() const{
    if (position() &gt;= length()) {
        throw range_error("Error: No element after cursor");
    }
    return afterCursor-&gt;data;
}

ListElement List::peekPrev() const{
</font>    if (position() &lt;= 0) {
        throw range_error("Error: No element before cursor");
    }
    return beforeCursor-&gt;data;
}


<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/8/265063914443/match1-1.html#1" target="1"><img src="./tm_1_17.gif" alt="other" border="0" align="left"></a>

void List::clear() {
    moveFront();
    while (length() &gt; 0) {
        eraseAfter();
    }
}

void List::moveFront() {
    beforeCursor = frontDummy;
    afterCursor = frontDummy-&gt;next;
    pos_cursor = 0;
    return;
}

void List::moveBack() {
    afterCursor = backDummy;
    beforeCursor = backDummy-&gt;prev;
    pos_cursor = num_elements;
}

ListElement List::moveNext() {
    if (position() &gt;= length()) {
        throw range_error("Error: No next element");
    }
    beforeCursor = beforeCursor-&gt;next;
    afterCursor = afterCursor-&gt;next;
    pos_cursor++;
    return beforeCursor-&gt;data;
}

ListElement List::movePrev() {
    if (position() &lt;= 0) {
        throw range_error("Error: No previous element");
    }
    beforeCursor = beforeCursor-&gt;prev;
    afterCursor = afterCursor-&gt;prev;
    pos_cursor--;
    return afterCursor-&gt;data;
}

void List::insertAfter(ListElement x) {
    if (position() &lt; 0) {
        exit(EXIT_FAILURE);
    }
    if (afterCursor == nullptr || beforeCursor == nullptr) {
        exit(EXIT_FAILURE);
    }    
    Node *X = new Node(x);

    X-&gt;prev = beforeCursor;
    beforeCursor-&gt;next = X;
    X-&gt;next = afterCursor;
    afterCursor-&gt;prev = X;
    afterCursor = X;

    num_elements++;
}

void List::insertBefore(ListElement x) {
    if (position() &lt; 0) {
        exit(EXIT_FAILURE);
    }
    if (afterCursor == nullptr || beforeCursor == nullptr) {
        exit(EXIT_FAILURE);
    }
    Node *X = new Node(x);

    X-&gt;prev = beforeCursor;
</font>    beforeCursor-&gt;next = X;
    X-&gt;next = afterCursor;
    afterCursor-&gt;prev = X;
<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/8/265063914443/match1-1.html#0" target="1"><img src="./tm_0_30.gif" alt="other" border="0" align="left"></a>

    beforeCursor = X;

    pos_cursor++;
    num_elements++;
}

void List::setAfter(ListElement x) {
    if (position() &gt;= length()) {
        throw range_error("No element after cursor");
    }
    afterCursor-&gt;next-&gt;data = x;
}

void List::setBefore(ListElement x) {
    if (position() &lt;= 0) {
        throw range_error("Error: There is no element before cursor");
    }
    beforeCursor-&gt;prev-&gt;data=x;
}

void List::eraseAfter() {
    if (position() &gt;= length()) {
        throw range_error("Error: There is no element to erase");
    }
    Node *X = afterCursor;
    beforeCursor-&gt;next = afterCursor-&gt;next;
    X-&gt;next-&gt;prev = beforeCursor;
    afterCursor = X-&gt;next;
    delete X;
    num_elements--;
}

void List::eraseBefore() {
    if (position() &lt;= 0) {
        throw range_error("Error: There is no element to erase");
    }
    Node *X = beforeCursor;
    beforeCursor = beforeCursor-&gt;prev;
    afterCursor-&gt;prev = beforeCursor;
    beforeCursor-&gt;next = afterCursor;
    delete X;
    pos_cursor--;
    num_elements--;
}


int List::findNext(ListElement x) {
    bool found = false;
    Node *X = afterCursor;
    while (!found &amp;&amp; X != backDummy) {
        found = (X-&gt;data == x);
        if (!found) {
            X = X-&gt;next;
        }
        pos_cursor++;
    }
    afterCursor = X-&gt;next;
    beforeCursor = X;
    if (found) {
        return pos_cursor;
    }
    else {
        return -1;
    }
}

int List::findPrev(ListElement x) {
    bool found = false;
    do {
        if (x == movePrev()) {
            found = true;
            break;
        }
    } while (pos_cursor &gt; 0);
    return (found ? pos_cursor : -1);
}

void List::cleanup() {
    int pos = 0;
    Node *cursor = frontDummy-&gt;next;
    Node *curr = nullptr;
    Node *n = nullptr;
    while (cursor != backDummy) {
        curr = cursor;
        n = cursor-&gt;next;
        pos++;
        while (n != backDummy) {
            if (cursor-&gt;data == n-&gt;data) {
                curr-&gt;next = n-&gt;next;
                n-&gt;next-&gt;prev = curr;
                delete n;
                n = curr-&gt;next;
                num_elements--;
                if (pos &lt; pos_cursor) {
                    pos_cursor--;
                }
            }
            else {
                curr = n;
                n = curr-&gt;next;                
            }
        }
        cursor = cursor-&gt;next;
    }
}

List List::concat(const List&amp; L) const {
    List newList;
</font>    Node *X = this-&gt;frontDummy-&gt;next;
    Node *Y = L.frontDummy-&gt;next;

    while (X != this-&gt;backDummy) {
        newList.insertAfter(X-&gt;data);
        X = X-&gt;next;
    }

<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/8/265063914443/match1-1.html#3" target="1"><img src="./tm_3_5.gif" alt="other" border="0" align="left"></a>

    while (Y != L.backDummy) {
        newList.insertAfter(Y-&gt;data);
        Y = Y-&gt;next;
    }
    return newList;
}

std::string List::to_string() const {
    Node *X = nullptr;
    string s = "";
    for (X = frontDummy; X!= nullptr; X = X-&gt;next) {
        s += std::to_string(X-&gt;data) + " ";
</font>    }
    return s;;
}

bool List::equals(const List&amp; R) const {
    bool eq = false;
    Node *X = nullptr;
    Node *Y = nullptr;

    eq = (this-&gt;num_elements == R.num_elements);

    X = this-&gt;frontDummy;
    Y = R.frontDummy;

    while (eq &amp;&amp; X != nullptr) {
        eq = (X-&gt;data == Y-&gt;data);
        X = X-&gt;next;
        Y = Y-&gt;next;
    }
    return eq;
}


std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const List&amp; L) {
    return stream &lt;&lt; L.List::to_string();
}

bool operator==(const List&amp; A, const List&amp; B) {
<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/8/265063914443/match1-1.html#4" target="1"><img src="./tm_4_2.gif" alt="other" border="0" align="left"></a>

    return A.List::equals(B);
}

List&amp; List::operator=(const List&amp; L) {
    if (this != &amp;L) {
        List temp = L;
    
        swap(frontDummy, temp.frontDummy);
</font>        swap(backDummy, temp.backDummy);
        swap(num_elements, temp.num_elements);
        swap(beforeCursor, temp.beforeCursor);
        swap(afterCursor, temp.afterCursor);
        swap(pos_cursor, temp.pos_cursor);
    }
    return *this;
}

</pre>



</body></html>