
<!-- saved from url=(0063)http://moss.stanford.edu/results/1/1137937075431/match13-1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/ssriva16/pa5/List.cpp</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter24/lluengas/pa5/List.cpp<p></p><pre>/* Lucy Luengas
 * lluengas
 * cse101 pa5 */

// List ADT of pa5

#include "List.h"
#include &lt;stdexcept&gt;

using namespace std;

List::Node::Node(ListElement x){
    data = x;
    next = nullptr;
    prev = nullptr;
}

// creates List in empty state
List::List(){
    frontDummy = new Node(5);
    backDummy = new Node(7);
    frontDummy-&gt;next = backDummy;
    backDummy-&gt;prev = frontDummy;
    beforeCursor = frontDummy;
    afterCursor = backDummy;
    pos_cursor = 0;
    num_elements = 0;
}

// copy constructor
List::List(const List&amp; L){
    frontDummy = new Node(5);
    backDummy = new Node(7);
    frontDummy-&gt;next = backDummy;
    backDummy-&gt;prev = frontDummy;
    beforeCursor = frontDummy;
    afterCursor = backDummy;
    pos_cursor = 0;
    num_elements = 0;

    // copy from L to N
    Node *N = L.frontDummy-&gt;next;
    while(N != L.backDummy){
        this-&gt;insertAfter(N-&gt;data);
        moveNext();
        N = N-&gt;next;
    }
    moveFront();
}

// deconstructor
List::~List(){
    clear();
    delete frontDummy;
    delete backDummy;
}

// access functions
int List::length() const{
    return num_elements;
}

ListElement List::front() const{
    if (num_elements == 0){
        throw length_error("List: front() called on List with length 0");
    }
<a name="5"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/1/1137937075431/match13-0.html#5" target="0"><img src="./tm_0_3.gif" alt="other" border="0" align="left"></a>

    return frontDummy-&gt;next-&gt;data;
}

ListElement List::back() const{
    if (num_elements == 0){
        throw length_error("List: front() called on List with length 0");
    }
    return backDummy-&gt;prev-&gt;data;
}

int List::position() const{
    if (pos_cursor &lt; 0 || pos_cursor &gt; num_elements){
        throw range_error("List: position() called on List with position undefined");
</font>    }
    return pos_cursor;
}

ListElement List::peekNext() const{
    if (pos_cursor &gt;= length()){
        throw range_error("List: peekNext() called on undefined element");
    }
    return afterCursor-&gt;data;
}

ListElement List::peekPrev() const{
    if (pos_cursor &lt;= 0){
        throw range_error("List: peekNext() called on undefined element");
    }
    return beforeCursor-&gt;data;
}


// manipulation procedures
void List::clear(){
    moveFront();
    while (length() &gt; 0){
        eraseAfter();
    }
}

void List::moveFront(){
    beforeCursor = frontDummy;
    afterCursor = frontDummy-&gt;next;
    pos_cursor = 0;
}

void List::moveBack(){
    afterCursor = backDummy;
    beforeCursor = backDummy-&gt;prev;
    pos_cursor = num_elements;
}

<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/1/1137937075431/match13-0.html#3" target="0"><img src="./tm_3_5.gif" alt="other" border="0" align="left"></a>

ListElement List::moveNext(){
    if (position() &gt;= length()){
        throw range_error("List: moveNext() called on cursor out of range (back)");
    }
    beforeCursor = beforeCursor-&gt;next;
    afterCursor = afterCursor-&gt;next;
    pos_cursor++;
    return beforeCursor-&gt;data;
}   

ListElement List::movePrev(){
    if (position() &lt;= 0){
        throw range_error("List: movePrev() called on cursor out of range (front)");
    }
    beforeCursor = beforeCursor-&gt;prev;
    afterCursor = afterCursor-&gt;prev;
    pos_cursor--;
    return afterCursor-&gt;data;
}

void List::insertAfter(ListElement x){
    if (position() &lt; 0){
</font>        throw range_error("List: insertAfter() called on cursor out of range (before front)");
    }
    if (afterCursor == nullptr || beforeCursor == nullptr){
        exit(EXIT_FAILURE);
    }
    Node *temp = new Node(x);

    temp-&gt;prev = beforeCursor;
    beforeCursor-&gt;next = temp;
    temp-&gt;next = afterCursor;
    afterCursor-&gt;prev = temp;
    afterCursor = temp;

    num_elements++;
}

void List::insertBefore(ListElement x){
    if (position() &lt; 0){
        throw range_error("List: insertBefore() called on cursor out of range (before front)");
    }
    if (afterCursor == nullptr || beforeCursor == nullptr){
        exit(EXIT_FAILURE);
    }
    Node *temp = new Node(x);

    temp-&gt;prev = beforeCursor;
    beforeCursor-&gt;next = temp;
    temp-&gt;next = afterCursor;
    afterCursor-&gt;prev = temp;
<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/1/1137937075431/match13-0.html#1" target="0"><img src="./tm_1_10.gif" alt="other" border="0" align="left"></a>

    beforeCursor = temp;

    pos_cursor++; // update cursor
    num_elements++;
}

void List::setAfter(ListElement x){
    if (position() &gt;= length()){
        throw range_error("List: setAfter() called on cursor out of range (back)");
    }
    afterCursor-&gt;next-&gt;data = x;
}

void List::setBefore(ListElement x){
    if (position() &lt;= 0){
        throw range_error("List: insertBefore() called on cursor out of range (front)");
    }
    beforeCursor-&gt;next-&gt;data = x;
}

void List::eraseAfter(){
    if (position() &gt;= length()){
        throw range_error("List: eraseAfter() called on cursor out of range (back)");
    }
    Node *erase = afterCursor;
    beforeCursor-&gt;next = afterCursor-&gt;next; //skips one
    erase-&gt;next-&gt;prev = beforeCursor;
    afterCursor = erase-&gt;next;
    delete erase;
    num_elements--;

}

void List::eraseBefore(){
    if (position() &lt;= 0){
        throw range_error("List: eraseBefore() called on cursor out of range (front)");
    }
    Node *erase = beforeCursor; // changed 
    beforeCursor = beforeCursor-&gt;prev; // changed
    afterCursor-&gt;prev = beforeCursor; // changed
</font>    beforeCursor-&gt;next = afterCursor; // changed
    delete erase;
    num_elements--; pos_cursor--;
    
}


// other functions
int List::findNext(ListElement x){
        // starting at current cursor pos
        //int cursor_pos = -1;
        Node *temp = afterCursor;
<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/1/1137937075431/match13-0.html#4" target="0"><img src="./tm_4_4.gif" alt="other" border="0" align="left"></a>

        bool eq = false;
        while(!eq &amp;&amp; temp != backDummy){
                eq = (temp-&gt;data == x);
                if (!eq){
                        temp = temp-&gt;next;
                }
                pos_cursor++;

        }


        afterCursor = temp-&gt;next;
        beforeCursor = temp;

        if (eq){
                return pos_cursor;
        } else {
                return -1;
        }
        //return cursor_pos;
}

int List::findPrev(ListElement x){
        bool eq = false;
</font>        //int cursor_pos = -1;
        Node *temp = beforeCursor;

        while( !eq &amp;&amp; temp != frontDummy){
                eq = (temp-&gt;data == x);
                if (!eq){
                        temp = temp-&gt;prev;
                }
                // fixing bug of going one before front of List
                if (temp-&gt;prev == nullptr){
                    break;
                } else {
                    pos_cursor--;
                }
        }
        /*do {
            if( x == movePrev()){
                eq = true;
                break;
            }
        } while (pos_cursor &gt; 1);*/
        beforeCursor = temp-&gt;prev;
        afterCursor = temp;

        if (eq){
                return pos_cursor;
        } else {
                //pos_cursor = 0;
                //pos_cursor--;
<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/1/1137937075431/match13-0.html#0" target="0"><img src="./tm_0_11.gif" alt="other" border="0" align="left"></a>

                return -1;
        }
}


void List::cleanup(){
        //int original_pos = pos_cursor; // remember original position
        int pos = 0;
        Node *at = frontDummy-&gt;next;
        Node *current = nullptr;
        Node *n = nullptr;
        // outer loop from at to final to end of list
       while(at != backDummy){
                current = at;
                n = at-&gt;next;
                pos++;
                // inner loop from at++ tp end of list
                while(n != backDummy){
                        if (at-&gt;data == n-&gt;data){
                                current-&gt;next = n-&gt;next;
                                n-&gt;next-&gt;prev = current;
                                delete n;
                                n = current-&gt;next;
                                num_elements--;
                                if (pos &lt; pos_cursor){
                                        pos_cursor--;
                                }
                        } else {
                                current = n;
                                n = current-&gt;next;
                        }
                }
                at = at-&gt;next;
        }
}

List List::concat(const List&amp; L) const{
        List newList;
        Node *N = this-&gt;frontDummy-&gt;next;
        Node *M = L.frontDummy-&gt;next;
</font>
        while (N != this-&gt;backDummy){
<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/1/1137937075431/match13-0.html#2" target="0"><img src="./tm_2_5.gif" alt="other" border="0" align="left"></a>

                newList.insertAfter(N-&gt;data);
                N = N-&gt;next;
        }
        while (M != L.backDummy){
                newList.insertAfter(M-&gt;data);
                M = M-&gt;next;
        }
        return newList;
}

std::string List::to_string() const{
        Node *temp = nullptr;
        string s = "";
        for (temp = frontDummy; temp != nullptr; temp = temp-&gt;next){
                s += std::to_string(temp-&gt;data) + " ";
</font>        }
        return s;
}


bool List::equals(const List&amp; R) const{
        Node *N = nullptr;
        Node *M = nullptr;

        bool eq = (this-&gt;num_elements == R.num_elements);

        N = this-&gt;frontDummy;
        M = R.frontDummy;

        while(eq &amp;&amp; N != nullptr){
                eq = (N-&gt;data == M-&gt;data);
                N = N-&gt;next;
                M = M-&gt;next;
        }
        return eq;
}



// overloaded ops
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const List&amp; L){
        return stream &lt;&lt; L.List::to_string();
}

bool operator==(const List&amp; A, const List&amp; B){
        return A.List::equals(B);
}

List&amp; List::operator=(const List&amp; L) {
        if (this != &amp;L) {
                List temp = L;

                swap(frontDummy, temp.frontDummy);
                swap(backDummy, temp.backDummy);
                swap(beforeCursor, temp.beforeCursor);
                swap(afterCursor, temp.afterCursor);
                swap(pos_cursor, temp.pos_cursor);
                swap(num_elements, temp.num_elements);
        }
        return *this;
}





        

</pre>



</body></html>