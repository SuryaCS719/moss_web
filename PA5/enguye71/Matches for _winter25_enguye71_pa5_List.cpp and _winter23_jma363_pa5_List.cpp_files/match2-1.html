
<!-- saved from url=(0062)http://moss.stanford.edu/results/4/7951512929025/match2-1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/enguye71/pa5/List.cpp</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter23/jma363/pa5/List.cpp<p></p><pre>/********************************************************************************* 
* Joey Ma, jma363
* 2023 Winter CSE101 PA5
* List.cpp
* List for List ADT originally from PA2 reused in PA4, rev for PA5
*********************************************************************************/ 

#include "List.h"

/* Class Constructors &amp; Destructors */


// --- Private constructors ---
List::Node::Node(ListElement x) {
  data = x;
  next = nullptr;
  prev = nullptr;
}

// --- Public constructors ---
// List() creates new List in the empty state.
List::List() {
  frontDummy = new Node(-420);
  backDummy = new Node(420);
  frontDummy-&gt;next = backDummy;
  backDummy-&gt;prev = frontDummy;
  beforeCursor = frontDummy;
  afterCursor = backDummy;
  pos_cursor = 0;
  num_elements = 0;
}

// List(const List &amp;L) copy constructor.
List::List(const List&amp; L) {
  frontDummy = new Node(-420);
  backDummy = new Node(420);
  frontDummy-&gt;next = backDummy;
  backDummy-&gt;prev = frontDummy;
  beforeCursor = frontDummy;
  afterCursor = backDummy;
  pos_cursor = 0;
  num_elements = 0;

<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/4/7951512929025/match2-0.html#4" target="0"><img src="./tm_4_4.gif" alt="other" border="0" align="left"></a>

  Node *N = L.frontDummy-&gt;next;
  while (N != L.backDummy) {
    this-&gt;insertBefore(N-&gt;data);
    N = N-&gt;next;
  }
}

// ~List() Destructor
List::~List() {
  this-&gt;clear();
  delete frontDummy;
  delete backDummy;
}

// Access functions --------------------------------------------------------

// length() returns the length of this List.
int List::length() const {
  return num_elements;
}

// front() returns the front element in this List. pre: length() &gt; 0
ListElement List::front() const {
  if (length() &lt;= 0) throw std::length_error("List: front(): empty list");
</font>  return frontDummy-&gt;next-&gt;data;
}

// back() returns the back element in this list. pre: length() &gt; 0
ListElement List::back() const {
  if (length() &lt;= 0) throw std::length_error("List: back(): empty list");
  return backDummy-&gt;prev-&gt;data;
}

// position() returns the position of the cursor in this List. 0 &lt;= position() &lt;= length()
<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/4/7951512929025/match2-0.html#3" target="0"><img src="./tm_3_6.gif" alt="other" border="0" align="left"></a>

int List::position() const {
  return pos_cursor;
}

// peekNext() returns the element after the cursor. pre: position() &lt; length()
ListElement List::peekNext() const {
  //if (position() &gt;= length()) throw std::range_error("List: peekNext(): position is out of range or at range");
  if (position() == length()) throw std::range_error("List: peekNext(): cursor at back");
  if (position() &gt; length()) throw std::range_error("List: peekNext(): cursor at front");
  return afterCursor-&gt;data;
}

// peekPrev() returns the element before the cursor. pre: position() &gt; 0
ListElement List::peekPrev() const {
  //if (position() &lt;= 0) throw std::range_error("List: peekPrev(): position is out of range or at range");
  if (position() == 0) throw std::range_error("List: peekPrev(): cursor at front");
  if (position() &lt; 0) throw std::range_error("List: peekPrev(): cursor at back");
  return beforeCursor-&gt;data;
}

// Manipulation procedures ----------------------------------------------------

// clear deletes all elements in this List, setting it to the empty state.
void List::clear() {
  moveFront();
  while(length() &gt; 0) eraseAfter();
}

// moveFront() moves cursor to position 0 in this List.
void List::moveFront() {
</font>  beforeCursor = frontDummy;
  afterCursor = frontDummy-&gt;next;
  pos_cursor = 0;
}

// moveBack() moves cursor to position length() in this List.
<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/4/7951512929025/match2-0.html#2" target="0"><img src="./tm_2_8.gif" alt="other" border="0" align="left"></a>

void List::moveBack() {
  beforeCursor = backDummy-&gt;prev;
  afterCursor = backDummy;
  pos_cursor = length(); // num_elements
}

// Note to myself: new error messages may pose inaccuracies about pos_cursor but matches output regardless
// moveNext() advances cursor to next higher position. Returns the List element that was passed over. pre: position() &lt; length()
ListElement List::moveNext() {
  //if (position() &gt;= length()) throw std::range_error("List: moveNext(): position is out of range or at range");
  if (position() == length()) throw std::range_error("List: moveNext(): cursor at back");
  if (position() &gt; length()) throw std::range_error("List: moveNext(): cursor at front");
  beforeCursor = afterCursor;
  afterCursor = afterCursor-&gt;next;
  pos_cursor++;
  return beforeCursor-&gt;data;
}

// movePrev() advances cursor to next lower position. Returns the List element that was passed over. pre: position() &gt; 0
ListElement List::movePrev() {
  //if (position() &lt;= 0) throw std::range_error("List: movePrev(): position is out of range or at range");
  if (position() == 0) throw std::range_error("List: movePrev(): cursor at front");
  if (position() &lt; 0) throw std::range_error("List: movePrev(): cursor at back");
  afterCursor = beforeCursor;
  beforeCursor = beforeCursor-&gt;prev;
  pos_cursor--;
  return afterCursor-&gt;data;
}

// insertAfter() inserts x after cursor.
void List::insertAfter(ListElement x) {
</font>  Node *N = new Node(x);
  N-&gt;prev = beforeCursor;
  N-&gt;next = afterCursor;
  beforeCursor-&gt;next = N;
  afterCursor-&gt;prev = N;
  
  afterCursor = N;
  num_elements++;
}

// insertBefore() inserts x before cursor.
void List::insertBefore(ListElement x) {
  Node *N = new Node(x);
  N-&gt;prev = beforeCursor;
  N-&gt;next = afterCursor;
  beforeCursor-&gt;next = N;
<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/4/7951512929025/match2-0.html#0" target="0"><img src="./tm_0_21.gif" alt="other" border="0" align="left"></a>

  afterCursor-&gt;prev = N;
  
  beforeCursor = N;
  pos_cursor++;

  num_elements++;
}

// setAfter() overwrites the List element after the cursor with x. pre: position() &lt; length()
void List::setAfter(ListElement x) {
  //if (position() &gt;= length()) throw std::range_error("List: setAfter(): position is out of range or at range");
  if (position() == length()) throw std::range_error("List: setAfter(): cursor at back");
  if (position() &gt; length()) throw std::range_error("List: setAfter(): cursor at front");
  afterCursor-&gt;data = x;
}

// setBefore() overwrites the List element before the cursor with x. pre: position() &gt; 0
void List::setBefore(ListElement x) {
  //if (position() &lt;= 0) throw std::range_error("List: setBefore(): position is out of range or at range");
  if (position() == 0) throw std::range_error("List: setBefore(): cursor at front");
  if (position() &lt; 0) throw std::range_error("List: setBefore(): cursor at back");
  beforeCursor-&gt;data = x;
}

// eraseAfter() deletes element after cursor. pre: position() &lt; length()
void List::eraseAfter() {
  //if (position() &gt;= length()) throw std::range_error("List: eraseAfter() position is out of range or at range");
  if (position() == length()) throw std::range_error("List: eraseAfter(): cursor at back");
  if (position() &gt; length()) throw std::range_error("List: eraseAfter(): cursor at front");
  Node *N = afterCursor;
  beforeCursor-&gt;next = N-&gt;next;
  afterCursor-&gt;next-&gt;prev = beforeCursor;
  afterCursor = N-&gt;next;
  delete N;
  num_elements--;
}

// eraseBefore() deletes element before cursor. pre: position() &gt; 0
void List::eraseBefore() {
  //if (position() &lt;= 0) throw std::range_error("List: eraseBefore() position is out of range or at range");
  if (position() == 0) throw std::range_error("List: eraseBefore(): cursor at front");
  if (position() &lt; 0) throw std::range_error("List: eraseBefore(): cursor at back");
  Node *N = beforeCursor;
  afterCursor-&gt;prev = N-&gt;prev;
  afterCursor-&gt;prev-&gt;next = afterCursor;
  beforeCursor = N-&gt;prev;
  delete N;
  num_elements--;
  pos_cursor--;
}

// Other Functions ---------------------------------------------------------

// findNext()
// Starting from the current cursor position, performs a linear search (in 
// the direction front-to-back) for the first occurrence of element x. If x
// is found, places the cursor immediately after the found element, then 
// returns the final cursor position. If x is not found, places the cursor 
// at position length(), and returns -1. 
int List::findNext(ListElement x) {
	while (position() &lt; length()) { // position() = pos_cursor
		if (peekNext() == x) {       // peekNext() = afterCursor-&gt;data
			moveNext();
			return position();
		}
		moveNext();
	}
	return -1;
}

// findPrev()
// Starting from the current cursor position, performs a linear search (in 
// the direction back-to-front) for the first occurrence of element x. If x
// is found, places the cursor immediately before the found element, then
// returns the final cursor position. If x is not found, places the cursor 
// at position 0, and returns -1. 
int List::findPrev(ListElement x) {
  while (position() &gt; 0) {          // position() = pos_cursor
    if (peekPrev() == x) {          // peekNext() = afterCursor-&gt;data
      movePrev();
      return position();
    }
    movePrev();
  }
  return -1;
}

/* 
Notes for myself:
First while loop iterate through all nodes in the list.
Second while loop compares each node to all subsequent nodes in the list.
If-statements starting from the second if statement:
2. If the node is before the cursor, erase it and update compare_node to its previous node.
3. If the node is after the cursor, erase it and update compare_node to its previous node.
4. If the node is not before or after the cursor, delete the node and update compare_node to its previous node.
5. If the position of the deleted node is before the cursor, decrement the cursor position.
*/
// cleanup()
// Removes any repeated elements in this List, leaving only unique elements.
// The order of the remaining elements is obtained by retaining the frontmost 
// occurrance of each element, and removing all other occurances. The cursor 
// is not moved with respect to the retained elements, i.e. it lies between 
// the same two retained elements that it did before cleanup() was called.
void List::cleanup() {
  int current_pos = 0;
  Node *current_node = frontDummy-&gt;next;
  while (current_node != backDummy) {
</font>    int compare_pos = current_pos + 1;
    Node *compare_node = current_node-&gt;next;
<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/4/7951512929025/match2-0.html#1" target="0"><img src="./tm_1_11.gif" alt="other" border="0" align="left"></a>

    while (compare_node != backDummy) {
      Node *prev_node = compare_node-&gt;prev;
      if (compare_node-&gt;data == current_node-&gt;data) {
        if (compare_node == beforeCursor) {
          eraseBefore();
          compare_node = prev_node;
        } else if (compare_node == afterCursor) {
          eraseAfter();
          compare_node = prev_node;
        } else {
          Node *temp = compare_node;
          compare_node = compare_node-&gt;prev;
          temp-&gt;prev-&gt;next = temp-&gt;next;
          temp-&gt;next-&gt;prev = temp-&gt;prev;
          delete temp;
          num_elements--;
          if (compare_pos &lt;= position()) pos_cursor--;
        }
      }
      compare_node = compare_node-&gt;next;
      compare_pos++;
    }
    current_node = current_node-&gt;next;
    current_pos++;
  }
}

// concat()
// Returns a new List consisting of the elements of this List, followed by
// the elements of L. The cursor in the returned List will be at postion 0.
List List::concat(const List&amp; L) const {
  List M = List();
  for (Node *n1 = frontDummy-&gt;next; n1 != backDummy; n1 = n1-&gt;next) M.insertBefore(n1-&gt;data);
  for (Node *n2 = L.frontDummy-&gt;next; n2 != L.backDummy; n2 = n2-&gt;next) M.insertBefore(n2-&gt;data);
</font>  M.moveFront();
  return M;
}

// to_string()
// Returns a string representation of this List consisting of a comma 
// separated sequence of elements, surrounded by parentheses.
std::string List::to_string() const {
  std::string s = "(";
<a name="5"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/4/7951512929025/match2-0.html#5" target="0"><img src="./tm_0_4.gif" alt="other" border="0" align="left"></a>

  for (Node *N = frontDummy-&gt;next; N != backDummy; N = N-&gt;next) {
    s += std::to_string(N-&gt;data) + (N != backDummy-&gt;prev ? ", " : ")");
  }
  return s;
}

// equals()
// Returns true if and only if this List is the same integer sequence as R.
// The cursors in this List and in R are unchanged.
bool List::equals(const List&amp; R) const {
  if (length() != R.length()) return false;
</font>  for (Node *N = frontDummy-&gt;next, *M = R.frontDummy-&gt;next; N != backDummy; N = N-&gt;next, M = M-&gt;next) {
    if (N-&gt;data != M-&gt;data) return false;
  }
  return true;
}

// Overriden Operators -----------------------------------------------------

// operator&lt;&lt;()
// Inserts string representation of L into stream.
std::ostream&amp; operator&lt;&lt;( std::ostream&amp; stream, const List&amp; L ) {
  return stream &lt;&lt; L.List::to_string();
}

// operator==()
// Returns true if and only if A is the same integer sequence as B. The 
// cursors in both Lists are unchanged.
bool operator==( const List&amp; A, const List&amp; B ) {
  return A.List::equals(B);
}

// operator=()
// Overwrites the state of this List with state of L.
List&amp; List::operator=( const List&amp; L ) {
	if (this != &amp;L) {
		List temp = L;
		std::swap(frontDummy, temp.frontDummy);
		std::swap(backDummy, temp.backDummy);
		std::swap(beforeCursor, temp.beforeCursor);
		std::swap(afterCursor, temp.afterCursor);
		std::swap(pos_cursor, temp.pos_cursor);
		std::swap(num_elements, temp.num_elements);
	}
	return *this;
}
</pre>



</body></html>