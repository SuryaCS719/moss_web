
<!-- saved from url=(0117)file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match1-0.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>/winter25/agnanase/pa3/Graph.c</title>
</head>
<body bgcolor="white">
<hr>
/winter25/agnanase/pa3/Graph.c<p></p><pre>/***
* Arti Gnanasekar
* agnanase 
* 2025 Winter CSE101 PA3
* Graph.c
* Implementation file for Graph ADT
***/ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include "Graph.h"

/*** Graph Struct ***/
typedef struct GraphObj {
    int order; // # of vertices 
    int size; // # of edges/arcs 
    List* adj; // adjacency list 
<a name="4"></a><font color="#FF00FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match1-1.html#4" target="1"><img align="left" alt="other" border="0" src="./tm_4_4.gif"></a>

    int* color; // color of the vertice (white, gray, black)
    int* discover; // discover time of vertice 
    int* finish; // finish time of vertice
    int* parent; // parent of vertice 
} GraphObj; 

/*** Constructors-Destructors ***/
Graph newGraph (int n){ 
    Graph G = malloc(sizeof(GraphObj));
    assert(G != NULL);
    G-&gt;order = n;
    G-&gt;size = 0;
    G-&gt;adj = calloc(n+1, sizeof(List));
</font>    G-&gt;color = calloc(n+1, sizeof(int));
    G-&gt;discover = calloc(n+1, sizeof(int));
<a name="2"></a><font color="#0000FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match1-1.html#2" target="1"><img align="left" alt="other" border="0" src="./tm_2_6.gif"></a>

    G-&gt;finish = calloc(n+1, sizeof(int));
    G-&gt;parent = calloc(n+1, sizeof(int));
    assert(G-&gt;adj != NULL);
    assert(G-&gt;color != NULL);
    assert(G-&gt;discover != NULL);
    assert(G-&gt;finish != NULL);
    assert(G-&gt;parent != NULL);
    for (int i = 1; i &lt;= n; i++){
        G-&gt;adj[i] = newList();
        G-&gt;color[i] = WHITE;
</font>        G-&gt;parent[i] = NIL;
        G-&gt;discover[i] = UNDEF;
<a name="3"></a><font color="#00FFFF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match1-1.html#3" target="1"><img align="left" alt="other" border="0" src="./tm_3_4.gif"></a>

        G-&gt;finish[i] = UNDEF;
    }
    return G;
}

void freeGraph(Graph *pG){
    if (pG == NULL || *pG == NULL){
        return;
    }
    for (int i = 1; i &lt;= (*pG)-&gt;order; i++){
        freeList(&amp;((*pG)-&gt;adj[i]));
    }
    free((*pG)-&gt;color);
</font>    free((*pG)-&gt;parent);
    free((*pG)-&gt;discover);
    free((*pG)-&gt;finish);
    free((*pG)-&gt;adj);
    free(*pG);
    *pG = NULL;
}

/*** Access functions ***/
int getOrder(Graph G){
    if (G == NULL){
        fprintf(stderr, "Graph Error: calling getOrder() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }
    return (G-&gt;order);
}

int getSize(Graph G){
    if (G == NULL){
        fprintf(stderr, "Graph Error: calling getSize() on NULL Graph reference\n");
<a name="0"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match1-1.html#0" target="1"><img align="left" alt="other" border="0" src="./tm_0_42.gif"></a>

        exit(EXIT_FAILURE);
    }
    return (G-&gt;size);
}

int getParent(Graph G, int u){
    if (G == NULL){
        fprintf(stderr, "Graph Error: calling getParent() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }
    if (u &gt; G-&gt;order || u &lt; 1){
        fprintf(stderr, "Graph Error: calling getParent() on invalid vertex\n");
        exit(EXIT_FAILURE);
    }
    return (G-&gt;parent[u]);
}

int getDiscover(Graph G, int u){
    if (G == NULL){
        fprintf(stderr, "Graph Error: calling getDiscover() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }
    if (u &gt; G-&gt;order || u &lt; 1){
        fprintf(stderr, "Graph Error: calling getDiscover() on invalid vertex\n");
        exit(EXIT_FAILURE);
    }

    return (G-&gt;discover[u]);
}

int getFinish(Graph G, int u) {
    if (G == NULL){
        fprintf(stderr, "Graph Error: calling getFinish() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }
    if (u &gt; G-&gt;order || u &lt; 1){
        fprintf(stderr, "Graph Error: calling getFinish() on invalid vertex\n");
        exit(EXIT_FAILURE);
    }
    return (G-&gt;finish[u]);
}

/*** Manipulation procedures ***/
void addArc(Graph G, int u, int v) { 
    if (G == NULL){
        fprintf(stderr, "Graph Error: calling addArc() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }
    if (u &gt; G-&gt;order || u &lt; 1){
        fprintf(stderr, "Graph Error: calling addArc() on invalid vertex\n");
        exit(EXIT_FAILURE);
    }
    if (v &gt; G-&gt;order || v &lt; 1){
        fprintf(stderr, "Graph Error: calling addArc() on invalid vertex\n");
        exit(EXIT_FAILURE);
    }
    
    moveFront(G-&gt;adj[u]);
    while(index((G-&gt;adj[u])) &gt;= 0 &amp;&amp; get(G-&gt;adj[u]) &lt; v){
        moveNext(G-&gt;adj[u]);
    }
    if(index((G-&gt;adj[u])) &lt; 0 || get((G-&gt;adj[u])) != v){
        if(index((G-&gt;adj[u])) &lt; 0){
            append(G-&gt;adj[u], v);
        }else{
            insertBefore(G-&gt;adj[u], v);
        }
        G-&gt;size++;
    }
} 
void addEdge(Graph G, int u, int v){
    addArc(G, u, v);
    addArc(G, v, u);
    G-&gt;size--;
}

void Visit (Graph G, int x, int* time, List S);

void DFS(Graph G, List S){
    if (S == NULL) {
        fprintf(stderr, "Graph Error: calling DFS() with invalid List length\n");
        exit(EXIT_FAILURE);
    }
    for (int i = 1; i &lt;= getOrder(G); i++){
        G-&gt;color[i] = WHITE;
        G-&gt;parent[i] = NIL;
        G-&gt;discover[i] = UNDEF;
        G-&gt;finish[i] = UNDEF;
    }
    int time = 0;
    moveFront(S);
    List finished = newList();
    while(index(S) &gt;= 0){
        int u = get(S);
        if(G-&gt;color[u] == WHITE){
            Visit(G, u, &amp;time, finished);
        }
        moveNext(S);
    }
    clear(S);
    moveFront(finished);
       while(index(finished) &gt;= 0){
        append(S, get(finished));
        moveNext(finished);
    }
    freeList(&amp;finished);
}

void Visit (Graph G, int x, int* time, List S){ 
    G-&gt;discover[x] = ++(*time);
</font>    G-&gt;color[x] = GRAY;
    moveFront(G-&gt;adj[x]);
    while(index((G-&gt;adj[x])) &gt;= 0){
        int y = get(G-&gt;adj[x]);
        if(G-&gt;color[y] == WHITE){
            G-&gt;parent[y] = x;
            Visit(G, y, time, S);
        }
        moveNext(G-&gt;adj[x]);
    }

<a name="5"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match1-1.html#5" target="1"><img align="left" alt="other" border="0" src="./tm_0_4.gif"></a>

    G-&gt;color[x] = BLACK;
    G-&gt;finish[x] = ++(*time);
    prepend(S, x); 
}

Graph transpose(Graph G){
    if (G == NULL){
        fprintf(stderr, "Graph Error: calling transpose() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }
    Graph T = newGraph(getOrder(G));
    for (int i = 1; i &lt;= getOrder(G); i++){
</font>        moveFront(G-&gt;adj[i]);
        while(index((G-&gt;adj[i])) &gt;= 0){
            int v = get(G-&gt;adj[i]);
            addArc(T, v, i);
            moveNext(G-&gt;adj[i]);
        }
    }
    return T;
}
Graph copyGraph(Graph G){
    if (G == NULL){
        fprintf(stderr, "Graph Error: calling transpose() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }
    Graph C = newGraph(getOrder(G));
    for (int i = 1; i &lt;= getOrder(G); i++){
        moveFront(G-&gt;adj[i]);
        while(index((G-&gt;adj[i])) &gt;= 0){
            int v = get(G-&gt;adj[i]);
            addArc(C, i, v);
            moveNext(G-&gt;adj[i]);
        }
    }
    return C;
}
<a name="1"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match1-1.html#1" target="1"><img align="left" alt="other" border="0" src="./tm_1_7.gif"></a>

void printGraph(FILE* out , Graph G){
    if(G == NULL){
        fprintf(stderr, "Graph Error: calling printGraph() on NULL Graph reference\n");
        exit(EXIT_FAILURE);    
    }
    if(out == NULL){
        fprintf(stderr, "Stream Error: callig printGraph() on NULL file stream\n");
    }
    for(int i = 1; i &lt;= getOrder(G); i++){
        fprintf(out, "%d: ", i);
        for(moveFront(G-&gt;adj[i]); index((G-&gt;adj[i])) &gt;= 0; moveNext(G-&gt;adj[i])){
            fprintf(out, "%d ", get(G-&gt;adj[i]));
        }
        fprintf(out, "\n");
</font>    }
}



</pre>


</body></html>