
<!-- saved from url=(0117)file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_1/report/match2-1.html#4 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>/winter25/jkarnsom/pa3/Graph.c</title>
</head>
<body bgcolor="white">
<hr>
/fall23/ktchambe/pa3/Graph.c<p></p><pre>/*
Kyle Chambers
CSE101
Graph.c
pa3
*/

#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include "Graph.h"
#include "List.h"

#define INF -1
#define NIL -2
#define UNDEF -3

#define WHITE 0
#define GRAY 1
#define BLACK 2

<a name="10"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_1/report/match2-0.html#10" target="0"><img align="left" alt="other" border="0" src="./tm_0_1.gif"></a>

int time = 0;

// Structs

//  GraphObj Type
typedef struct GraphObj
{
    List *listAdjacency;
    int *color;
    int *parent;
    int *distance;
    int *discover;
    int *finish;
    int size;
    int sourceVertex;
</font>    int order;
    
    
} GraphObj;

//  Constructors/Destructors

Graph newGraph(int n)
{
    Graph G = malloc(sizeof(struct GraphObj));
    assert(G != NULL);

    G-&gt;listAdjacency = malloc(n * sizeof(List));
    G-&gt;color = malloc(n * sizeof(int));
    G-&gt;parent = malloc(n * sizeof(int));
    G-&gt;distance = malloc(n * sizeof(int));
    G-&gt;discover = malloc(n * sizeof(int));
    G-&gt;finish = malloc(n * sizeof(int));

    assert(G-&gt;listAdjacency != NULL &amp;&amp; G-&gt;color != NULL &amp;&amp; G-&gt;parent != NULL &amp;&amp; G-&gt;distance != NULL &amp;&amp;
           G-&gt;discover != NULL &amp;&amp; G-&gt;finish != NULL);

    G-&gt;sourceVertex = NIL;
    G-&gt;order = n;
    G-&gt;size = 0;

    for (int i = 0; i &lt; n; i++)
    {
        G-&gt;parent[i] = NIL;
        G-&gt;listAdjacency[i] = newList();
<a name="8"></a><font color="#00FFFF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_1/report/match2-0.html#8" target="0"><img align="left" alt="other" border="0" src="./tm_3_1.gif"></a>

        G-&gt;distance[i] = INF;
        G-&gt;discover[i] = UNDEF;
        G-&gt;finish[i] = UNDEF;
    }

    return G;
}

void freeGraph(Graph *pG)
{
    if (*pG == NULL)
    {
        printf("Graph Error: calling freeGraph() on NULL Graph reference\n");
</font>        exit(EXIT_FAILURE);
    }

    Graph G = *pG;

    // Free individual lists within the graph
    for (int i = 0; i &lt; G-&gt;order; i++)
    {
        freeList(&amp;(G-&gt;listAdjacency[i]));
    }

    // Free dynamically allocated arrays and the graph object
    free(G-&gt;listAdjacency);
    free(G-&gt;distance);
    free(G-&gt;parent);
    free(G-&gt;color);
    free(G-&gt;discover);
    free(G-&gt;finish);
    free(G);

    *pG = NULL;
}

//  Access Functions ----------------------------------------------------------------------

int getOrder(Graph G)
{
    if (G == NULL)
    {
        printf("ERROR: calling getOrder() on a graph that doesn't exist!\n");
<a name="11"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_1/report/match2-0.html#11" target="0"><img align="left" alt="other" border="0" src="./tm_1_1.gif"></a>

        exit(EXIT_FAILURE);
    }
    return G-&gt;order;
}

int getSize(Graph G)
{
    if (G == NULL)
    {
        printf("ERROR: calling getSize() on a graph that doesn't exist!\n");
        exit(EXIT_FAILURE);
    }
    return G-&gt;size;
}

int getSource(Graph G)
{
    if (G == NULL)
</font>    {
        printf("ERROR: calling getSource() on a graph that doesn't exist!\n");
        exit(EXIT_FAILURE);
    }
    return G-&gt;sourceVertex;
}

int getParent(Graph G, int u)
{
    if (G == NULL || u &lt; 1 || u &gt; G-&gt;order)
    {
        printf("Graph Error: calling getParent() with invalid arguments\n");
<a name="12"></a><font color="#0000FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_1/report/match2-0.html#12" target="0"><img align="left" alt="other" border="0" src="./tm_2_1.gif"></a>

        exit(EXIT_FAILURE);
    }

    if (G-&gt;sourceVertex == NIL)
    {
        return NIL; // No source, return NIL
    }

    return G-&gt;parent[u - 1];
}

int getDiscover(Graph G, int u)
{
    // Ensure that the graph reference is not NULL and that the vertex index is valid
    if (G == NULL || u &lt; 1 || u &gt; getOrder(G))
</font><a name="13"></a><font color="#00FFFF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_1/report/match2-0.html#13" target="0"><img align="left" alt="other" border="0" src="./tm_3_1.gif"></a>

    {
        printf("Graph Error: calling getDiscover() with invalid arguments\n");
        exit(EXIT_FAILURE);
    }

    // Return the discovery time of vertex u (subtract 1 because u is 1-based)
    return G-&gt;discover[u - 1];
}

int getFinish(Graph G, int u)
</font>{
    // Ensure that the graph reference is not NULL and the vertex index is within bounds
    if (G != NULL &amp;&amp; u &gt;= 1 &amp;&amp; u &lt;= getOrder(G))
    {
        // Return the finish time of vertex u (subtract 1 because u is 1-based)
        return G-&gt;finish[u - 1];
    }
    else
    {
        printf("Graph Error: calling getFinish() with invalid arguments\n");
        exit(EXIT_FAILURE);
    }
}
// Recursivly called helper function for getting the path
void getPathHelper(Graph G, List L, int u)
{
    if (u == getSource(G))
    {
        append(L, u);
    }
    else if (getParent(G, u) == NIL)
    {
        append(L, NIL);
    }
    else
    {
        getPathHelper(G, L, getParent(G, u));
        append(L, u);
    }
}

void getPath(List L, Graph G, int u)
{
    clear(L);

    if (G == NULL)
    {
<a name="14"></a><font color="#FF00FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_1/report/match2-0.html#14" target="0"><img align="left" alt="other" border="0" src="./tm_4_1.gif"></a>

        printf("ERROR: Calling getPath() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }

    if (u &lt; 1 || u &gt; getOrder(G))
    {
        printf("ERROR: Calling getPath() out of range of Order\n");
        exit(EXIT_FAILURE);
    }

    if (G-&gt;sourceVertex == NIL)
    {
        printf("ERROR: Calling getPath() before calling BFS()\n");
        exit(EXIT_FAILURE);
</font>    }

    getPathHelper(G, L, u);
}

//  Manipulation procedures

void makeNull(Graph G)
{
    if (G == NULL)
    {
        printf("ERROR: calling makeNull() on a graph that doesn't exist!\n");
        exit(EXIT_FAILURE);
    }

    int i = 1;
<a name="3"></a><font color="#00FFFF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_1/report/match2-0.html#3" target="0"><img align="left" alt="other" border="0" src="./tm_3_2.gif"></a>

    while (i &lt;= G-&gt;order)
    {
        clear(G-&gt;listAdjacency[i]);
        G-&gt;distance[i] = INF;
        G-&gt;parent[i] = NIL;
        G-&gt;color[i] = WHITE;
        i++;
    }
    G-&gt;sourceVertex = NIL;
</font>    G-&gt;size = 0;
}

void addEdge(Graph G, int u, int v)
{
    printf("\nAdd Edge");
    if (G == NULL)
    {
        printf("ERROR: Calling addEdge() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }

    if (u &lt; 1 || u &gt; G-&gt;order || v &lt; 1 || v &gt; G-&gt;order)
    {
        printf("ERROR: Calling addEdge() out of range of Order\n");
        exit(EXIT_FAILURE);
    }

    // Allocate memory for adjacency lists if not already allocated
    if (G-&gt;listAdjacency[u] == NULL)
    {
        G-&gt;listAdjacency[u] = newList();
    }

    if (G-&gt;listAdjacency[v] == NULL)
    {
        G-&gt;listAdjacency[v] = newList();
    }

    // Insert the edge into the adjacency lists
    List U = G-&gt;listAdjacency[u - 1];
    List V = G-&gt;listAdjacency[v - 1];

    // Insert v into the adjacency list of u
    moveFront(U);
    while (index(U) != -1 &amp;&amp; get(U) &lt; v)
    {
        moveNext(U);
    }
    if (index(U) == -1)
    {
        append(U, v);
    }
    else
    {
        insertBefore(U, v);
    }

    // Insert u into the adjacency list of v
    moveFront(V);
    while (index(V) != -1 &amp;&amp; get(V) &lt; u)
    {
        moveNext(V);
    }
    if (index(V) == -1)
    {
        append(V, u);
    }
    else
    {
<a name="9"></a><font color="#FF00FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_1/report/match2-0.html#9" target="0"><img align="left" alt="other" border="0" src="./tm_4_1.gif"></a>

        insertBefore(V, u);
    }

    G-&gt;size++;
}

void addArc(Graph G, int u, int v) {
    if (G == NULL) {
        printf("Graph Error: Attempted to add a directed edge to a NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }
    if (u &lt; 1 || u &gt; getOrder(G)) {
</font>        printf("Graph Error: Attempted to add a directed edge with an out-of-bounds source vertex\n");
        exit(EXIT_FAILURE);
    }
    if (v &lt; 1 || v &gt; getOrder(G)) {
        printf("Graph Error: Attempted to add a directed edge with an out-of-bounds destination vertex\n");
        exit(EXIT_FAILURE);
    }

    List sourceVertexList = G-&gt;listAdjacency[u - 1];

    moveFront(sourceVertexList);
    while (index(sourceVertexList) &gt;= 0) {
        if (get(sourceVertexList) == v) {
            return;
        }
<a name="6"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_1/report/match2-0.html#6" target="0"><img align="left" alt="other" border="0" src="./tm_1_2.gif"></a>

        moveNext(sourceVertexList);
    }

    if (length(sourceVertexList) == 0) {
        append(sourceVertexList, v);
    } else {
        if (v &gt; back(sourceVertexList)) {
            append(sourceVertexList, v);
        } else {
            moveFront(sourceVertexList);
            while (v &gt; get(sourceVertexList)) {
                moveNext(sourceVertexList);
            }
            insertBefore(sourceVertexList, v);
</font>        }
    }
    G-&gt;size++;
}


void BFS(Graph G, int s)
{
    printf("\nAdd BFS");
    if (G == NULL)
    {
        printf("ERROR: Calling BFS() on a graph that doesn't exist\n");
        exit(EXIT_FAILURE);
    }
    for (int i = 1; i &lt;= G-&gt;order; i++)
    {
        if (i != s)
        {
            G-&gt;parent[i] = NIL;
            G-&gt;color[i] = WHITE;
            G-&gt;distance[i] = INF;
        }
    }
    G-&gt;parent[s] = NIL;
    G-&gt;distance[s] = 0;
    G-&gt;sourceVertex = s;
    G-&gt;color[s] = GRAY;

    List Q = newList();
    prepend(Q, s);
    while (length(Q) &gt; 0)
    {
        int tempInt = front(Q);
        deleteFront(Q);
        List adjacentNumber = G-&gt;listAdjacency[tempInt];

        if (length(adjacentNumber) &gt; 0)
        {
            moveFront(adjacentNumber);
            while (index(adjacentNumber) != NIL)
            {
                int otherTempInt = get(adjacentNumber);
                if (G-&gt;color[otherTempInt] == WHITE)
                {
<a name="7"></a><font color="#0000FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_1/report/match2-0.html#7" target="0"><img align="left" alt="other" border="0" src="./tm_2_1.gif"></a>

                    G-&gt;color[otherTempInt] = GRAY;
                    G-&gt;distance[otherTempInt] = G-&gt;distance[tempInt] + 1;
                    G-&gt;parent[otherTempInt] = tempInt + 1;
                    append(Q, otherTempInt);
                }
                moveNext(adjacentNumber);
</font>            }
        }

        G-&gt;color[tempInt] = BLACK;
    }
    freeList(&amp;Q);
}

void Visit(Graph G, List S, int x) {
    // Mark the current vertex as discovered and set its color to GRAY
    G-&gt;discover[x] = ++time;
<a name="4"></a><font color="#FF00FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_1/report/match2-0.html#4" target="0"><img align="left" alt="other" border="0" src="./tm_4_2.gif"></a>

    G-&gt;color[x] = GRAY;

    List L = G-&gt;listAdjacency[x];

    for (moveFront(L); index(L) &gt;= 0; moveNext(L)) {
        int y = get(L) - 1; // Adjacent vertex

        // If the adjacent vertex is unvisited (WHITE), visit it
        if (G-&gt;color[y] == WHITE) {
</font>            Visit(G, S, y);
            G-&gt;parent[y] = x + 1; // Set parent to current vertex

        }
    }

    // Mark the current vertex as finished (BLACK) and record the finish time
<a name="0"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_1/report/match2-0.html#0" target="0"><img align="left" alt="other" border="0" src="./tm_0_8.gif"></a>

    G-&gt;color[x] = BLACK;
    G-&gt;finish[x] = ++time;

    // Prepend the current vertex to the result list S
    prepend(S, x + 1);
}

void DFS(Graph G, List S) {
    // Check if the graph reference is NULL, indicating an invalid operation
    if (G == NULL) {
        printf("Graph Error: calling DFS() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }

    // Check if the length of list S matches the order of the graph
    if (length(S) != getOrder(G)) {
        printf("Graph Error: calling DFS() with an out-of-bounds reference (u)\n");
        exit(EXIT_FAILURE);
    }

    // Initialize the source vertex and coloring
    G-&gt;sourceVertex = 0;
    for (int i = 0; i &lt; getOrder(G); i++) {
        G-&gt;color[i] = WHITE;
        G-&gt;parent[i] = NIL;
    }

    time = 0;
    
    // Create a copy of list S, traverse it, and perform DFS
    List L = copyList(S);
    clear(S);

    for (moveFront(L); index(L) &gt;= 0; moveNext(L)) {
        if (G-&gt;color[get(L) - 1] == WHITE)
            Visit(G, S, get(L) - 1);
    }

    freeList(&amp;L);
</font><a name="2"></a><font color="#0000FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_1/report/match2-0.html#2" target="0"><img align="left" alt="other" border="0" src="./tm_2_3.gif"></a>

}

//  Other Operations

void printGraph(FILE *out, Graph G)
{
    //printf("\nPrint Graph");
    if (G == NULL)
    {
        printf("ERROR: Calling BFS() on a graph that doesn't exist\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i &lt; G-&gt;order; i++)
    {
        fprintf(out, "%d: ", i + 1);
        printList(out, G-&gt;listAdjacency[i]);
        fprintf(out, "\n");
</font>    }
    //printf("\nPrint Graph End");
}

Graph transpose(Graph G) {
    // Check if the graph reference is NULL, indicating an invalid operation
    if (G == NULL) {
        printf("Graph Error: calling transpose() on a NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }

    // Create a new graph with the same order as G
    Graph T = newGraph(getOrder(G));

    for (int i = 0; i &lt; getOrder(G); i++) {
<a name="1"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_1/report/match2-0.html#1" target="0"><img align="left" alt="other" border="0" src="./tm_1_3.gif"></a>

        List L = G-&gt;listAdjacency[i]; // Get the adjacency list for vertex i

        for (moveFront(L); index(L) &gt;= 0; moveNext(L)) {
            // Add an arc in the transpose graph from the adjacent vertex to vertex i
            addArc(T, get(L), i + 1);
        }
    }

    return T;
}

Graph copyGraph(Graph G) {
    // Check if the graph reference is NULL, indicating an invalid operation
    if (G == NULL) {
        printf("Graph Error: calling copyGraph() on a NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }

    // Create a new graph with the same order as G
    Graph copyResult = newGraph(getOrder(G));

    // Copy the general graph properties
    copyResult-&gt;size = getSize(G);
    copyResult-&gt;sourceVertex = getSource(G);
</font><a name="5"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_1/report/match2-0.html#5" target="0"><img align="left" alt="other" border="0" src="./tm_0_2.gif"></a>


    for (int i = 0; i &lt; getOrder(G); i++) {
        // Copy the adjacency list, color, parent, distance, discover, and finish values
        copyResult-&gt;listAdjacency[i] = copyList(G-&gt;listAdjacency[i]);
        copyResult-&gt;color[i] = G-&gt;color[i];
</font>        copyResult-&gt;parent[i] = G-&gt;parent[i];
        copyResult-&gt;distance[i] = G-&gt;distance[i];
        copyResult-&gt;discover[i] = G-&gt;discover[i];
        copyResult-&gt;finish[i] = G-&gt;finish[i];
    }

    return copyResult;
}</pre>


</body></html>