
<!-- saved from url=(0117)file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/Graph.c/part_2/report/match0-1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>/winter25/jkarnsom/pa3/Graph.c</title>
</head>
<body bgcolor="white">
<hr>
/spring23/larchena/pa3/Graph.c<p></p><pre>/*
*	Luca Archenault
*	larchena
*	CSE101
*	pa3, Graph.c
*   
*	This file contains the ADT-Graph definitions, which Graph.h, FindPath.c, and GraphTest.c use.
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;assert.h&gt;
#include "Graph.h"
#include "List.h"

#define INF -1
#define NIL -2
#define UNDEF -3

int time = 0;

enum color {
    WHITE = 0, BLACK = 1, GRAY = 2
};

// Structs --------------------------------------------------------------------------------

//  GraphObj Type
typedef struct GraphObj {
    List* list; 
    int* color;
    int* parent;
    int* distance;
    int sourceVertex;
    int order; 
    int size;
    int* discover; 
    int* finish;
<a name="3"></a><font color="#00FFFF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/Graph.c/part_2/report/match0-0.html#3" target="0"><img align="left" alt="other" border="0" src="./tm_3_6.gif"></a>

}GraphObj;

//  Constructors/Destructors --------------------------------------------------------------

//  Returns reference to new empty Graph object with n-vertices and no edges
Graph newGraph(int n) {
    Graph G = malloc(sizeof(GraphObj));
    assert(G!=NULL);
    G-&gt;list = calloc(n, sizeof(List));
    G-&gt;color = calloc(n, sizeof(int));
    G-&gt;parent = calloc(n, sizeof(int)); 
    G-&gt;distance = calloc(n, sizeof(int));
    G-&gt;discover = calloc(n, sizeof(int)); 
    G-&gt;finish = calloc(n, sizeof(int)); 
    G-&gt;sourceVertex = NIL;
    G-&gt;order = n;
    G-&gt;size = 0;

    for(int i = 0; i &lt; (n); i++) {
        G-&gt;parent[i] = NIL;
</font>    }
    for(int i = 0; i &lt; (n); i++) {
        G-&gt;list[i] = newList();
    }
    for(int i = 0; i &lt; (n); i++) {
        G-&gt;distance[i] = INF;
    }
    for(int i = 0; i &lt; (n); i++) {
        G-&gt;discover[i] = UNDEF; 
    }
    for(int i = 0; i &lt; (n); i++) {
<a name="9"></a><font color="#FF00FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/Graph.c/part_2/report/match0-0.html#9" target="0"><img align="left" alt="other" border="0" src="./tm_4_3.gif"></a>

        G-&gt;finish[i] = UNDEF; 
    }

    return G;
}

//  Frees all heap memory held by Graph *pG, and sets it to NULL
void freeGraph(Graph* pG)
{
    if(*pG == NULL) {
        printf("Graph Error: calling freeGraph() on NULL Graph reference\n");
        exit(EXIT_FAILURE);   
    }
    
    if(pG != NULL &amp;&amp; *pG != NULL) {
        for(int i = 0; i &lt; (*pG)-&gt;order; i++) {
            freeList(&amp;((*pG)-&gt;list[i]));
</font>        }
        free((*pG)-&gt;list);
        free((*pG)-&gt;distance);
        free((*pG)-&gt;parent);
        free((*pG)-&gt;color);
<a name="7"></a><font color="#0000FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/Graph.c/part_2/report/match0-0.html#7" target="0"><img align="left" alt="other" border="0" src="./tm_2_3.gif"></a>

        free((*pG)-&gt;discover);
        free((*pG)-&gt;finish);
        free(*pG);
        *pG = NULL;
    }
}

//  Access Functions ----------------------------------------------------------------------

//  Returns graph order
int getOrder(Graph G) {
    if(G == NULL) {
        printf("Graph Error: calling getOrder() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }
    return G-&gt;order;
}

//  Returns graph size
int getSize(Graph G) {
    if(G == NULL) {
        printf("Graph Error: calling getSize() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }
    return G-&gt;size; 
}

//  Returns the most recently used source
int getSource(Graph G) {
    if(G == NULL) {
</font>        printf("Graph Error: calling getSource() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }
    return G-&gt;sourceVertex;
}

//  Returns the parent of a vertex in the tree made by BFS, or NIL if none
<a name="10"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/Graph.c/part_2/report/match0-0.html#10" target="0"><img align="left" alt="other" border="0" src="./tm_0_2.gif"></a>

int getParent(Graph G, int u) {
    if(G == NULL) {
        printf("Graph Error: calling getDist() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }
    if(u &lt; 1 || u &gt; getOrder(G)) {
        printf("Graph Error: calling getParent() with out of bounds reference\n");
        exit(EXIT_FAILURE);
    }

    if(G-&gt;sourceVertex == NIL) {
        return NIL;
    }
    return G-&gt;parent[u-1];
}

//  Returns the distance the source-vertex to the u-vertex, or NIL if no source
</font><a name="1"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/Graph.c/part_2/report/match0-0.html#1" target="0"><img align="left" alt="other" border="0" src="./tm_1_9.gif"></a>

int getDist(Graph G, int u) {
    if(G == NULL) {
        printf("Graph Error: calling getDist() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }
    if(u &lt; 1 || u &gt; getOrder(G)) {
        printf("Graph Error: calling getDist() with out of bounds reference\n");
        exit(EXIT_FAILURE);
    }

    if(G-&gt;sourceVertex == NIL) {
        return INF;
    }
    return G-&gt;distance[u-1];
}

//  Fills list L with the vertices of shortest path from source-vertex to u-vertex,
//  or NIL if no path exists
void getPath(List L, Graph G, int u) {
    if(G == NULL || L == NULL) {
        printf("Graph Error: calling getPath() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }
    if(u &lt; 1 || u &gt; getOrder(G)) {
        printf("Graph Error: calling getPath() with out of bounds reference\n");
        exit(EXIT_FAILURE);
    }
    if(G-&gt;sourceVertex == NIL) {
        printf("Graph Error: calling getPath() without calling BFS beforehand\n");
        exit(EXIT_FAILURE);
    } 
    
    if(u != getSource(G) &amp;&amp; getParent(G, u) == NIL) {
        append(L, NIL);
        return;
    }

    List temp = newList();

    int current = u;
    while(current != NIL) {
        prepend(temp, current);
        current = getParent(G, current);
    }

    int i = 0;
    moveFront(temp);
    while(i &lt; length(temp)) {
        append(L, get(temp));
        moveNext(temp);
        i++;
    }

    freeList(&amp;temp);
</font>}

//  New Material
//  Returns the disover time of u in graph G, given that the graph exists and u isn't out of bounds
int getDiscover(Graph G, int u) {
<a name="6"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/Graph.c/part_2/report/match0-0.html#6" target="0"><img align="left" alt="other" border="0" src="./tm_1_3.gif"></a>

    if(G == NULL) {
        printf("Graph Error: calling getDiscover() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }
    if(u &lt; 1 || u &gt; getOrder(G)) {
        printf("Graph Error: calling getDiscover() with out of bounds reference\n");
        exit(EXIT_FAILURE);
    }

    return G-&gt;discover[u-1];
}

//  Returns the finish time of u in graph G, given that the graph exists and u isn't out of bounds
int getFinish(Graph G, int u) {
    if(G == NULL) {
        printf("Graph Error: calling getFinish() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }
    if(u &lt;  1 || u  &gt; getOrder(G)) {
        printf("Graph Error: calling getFinish() with out of bounds reference\n");
        exit(EXIT_FAILURE);
    }

    return G-&gt;finish[u-1];
</font>}

//  Manipulation procedures ---------------------------------------------------------------

//  Deletes all edges of G
<a name="5"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/Graph.c/part_2/report/match0-0.html#5" target="0"><img align="left" alt="other" border="0" src="./tm_0_5.gif"></a>

void makeNull(Graph G) {
    if (G == NULL) {
        printf("Graph Error: calling makeNull() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }

    int i = 0;
    while(i &lt; getOrder(G)) {
        clear(G-&gt;list[i]); 
        G-&gt;color[i] = WHITE;
        G-&gt;parent[i] = NIL;
        G-&gt;distance[i] = INF;
        i++;
    }

    G-&gt;size = 0;
    G-&gt;sourceVertex = NIL;
}

//  Runs the BFS algorithm on the graph G, with source s. Manipulates source, parent, color,
//  and distance
void addEdge(Graph G, int u, int v) {
    if(G == NULL) {
        printf("Graph Error: calling addEdge() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }
    if(u &lt; 1 || u &gt; getOrder(G)) {
</font>        printf("Graph Error: calling addEdge() with out of bounds reference (u)\n");
        exit(EXIT_FAILURE);
    }
<a name="11"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/Graph.c/part_2/report/match0-0.html#11" target="0"><img align="left" alt="other" border="0" src="./tm_1_2.gif"></a>

    if(v &lt; 1 || v &gt; getOrder(G)) {
        printf("Graph Error: calling addEdge() with out of bounds reference (v)\n");
        exit(EXIT_FAILURE);
    }

    List U = G-&gt;list[u-1];
    List V = G-&gt;list[v-1];
</font>
    moveFront(U);
    while(index(U)&gt;=0){
        if(get(U) == v)
            return;
<a name="4"></a><font color="#FF00FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/Graph.c/part_2/report/match0-0.html#4" target="0"><img align="left" alt="other" border="0" src="./tm_4_5.gif"></a>

        moveNext(U);
    }
    
    if(length(U) == 0) {
        append(U, v);
    }
    else {
        if(v &gt; back(U)) {
            append(U, v);
        }
        else {
            moveFront(U);
            while(v &gt; get(U)) {
                moveNext(U);
            }
            insertBefore(U,v);
        }
    }

    if(length(V) == 0) {
        append(V, u);
    }
    else {
        if(u &gt; back(V)) {
            append(V, u);
        }
        else {
            moveFront(V);
            while(u &gt; get(V)) {                
                moveNext(V);
            }
            insertBefore(V,u);
        }
    }
    G-&gt;size++;
}

//  Connects vertex-u and vertex-v with an edge. Edge is added to adjacency lists of both
void addArc(Graph G, int u, int v) {
    if(G==NULL) {
        printf("Graph Error: calling addArc() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }
    if(u &lt; 1 || u &gt; getOrder(G)) {
</font>        printf("Graph Error: calling addArc() with out of bounds reference (u)\n");
        exit(EXIT_FAILURE);
    }
    if(v &lt; 1 || v &gt; getOrder(G)) {
        printf("Graph Error: calling addArc() with out of bounds reference (v)\n");
        exit(EXIT_FAILURE);
    }

    List U = G-&gt;list[u-1];

    moveFront(U);
    while(index(U)&gt;=0){
        if(get(U) == v)
            return;
<a name="8"></a><font color="#00FFFF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/Graph.c/part_2/report/match0-0.html#8" target="0"><img align="left" alt="other" border="0" src="./tm_3_3.gif"></a>

        moveNext(U);
    }

    if(length(U) == 0) {
        append(U, v);
    }
    else {
        if(v &gt; back(U)) {
            append(U, v);
        }
        else {
            moveFront(U);
            while(v &gt; get(U))
                moveNext(U);
            insertBefore(U, v);
        }
    }
    G-&gt;size++;
}

//  Visits the vertices recursively and alters the global "time" variable accoringly
void Visit(Graph G, List S, int x) {
    G-&gt;discover[x] = ++time;
</font>    G-&gt;color[x] = GRAY;
    
    List L = G-&gt;list[x];

    for(moveFront(L); index(L) &gt;= 0; moveNext(L)) {
        if(G-&gt;color[get(L)-1] == WHITE) {
            Visit(G, S, get(L)-1);
            G-&gt;parent[get(L)-1] = x+1;
        }
    }

<a name="0"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/Graph.c/part_2/report/match0-0.html#0" target="0"><img align="left" alt="other" border="0" src="./tm_0_23.gif"></a>

    G-&gt;color[x] = BLACK;
    G-&gt;finish[x] = ++time;
    prepend(S, x+1);
}

//  Uses helper function Visit() to do a depth first search on G
void DFS(Graph G, List S) {
    if(G == NULL) {
        printf("Graph Error: calling DFS() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }   
    if(length(S) != getOrder(G)) {
        printf("Graph Error: calling DFS() with out of bounds reference (u)\n");
        exit(EXIT_FAILURE);
    }

    G-&gt;sourceVertex = 0;
    for(int i = 0; i &lt; getOrder(G); i++) {
        G-&gt;color[i] = WHITE;
        G-&gt;parent[i] = NIL;
    }

    time = 0;
    List L = copyList(S);
    clear(S);
    
    for(moveFront(L); index(L) &gt;= 0; moveNext(L)) {
        if(G-&gt;color[get(L)-1] == WHITE)
            Visit(G, S, get(L)-1);
    }

    freeList(&amp;L);
}

//  Connects vertex-u to vertex-v with a directed edge. v is added to u adjacency list
void BFS(Graph G, int s)
{
    if(G == NULL) {
        printf("Graph Error: calling BFS() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }

    G-&gt;sourceVertex = s;

    //sets all vertices to an undiscovered state
    for(int i = 0; i &lt; getOrder(G); i++) {
        G-&gt;color[i] = WHITE;
        G-&gt;distance[i] = INF;
        G-&gt;parent[i] = NIL;
    }

    //sets source vertex to discovered
    G-&gt;distance[s-1] = 0;
    G-&gt;color[s-1] = GRAY;
    G-&gt;parent[s-1] = NIL;

    int curr = 0;

    List L = newList();
    prepend(L, s);
    while(length(L) != 0) {
        moveFront(L);
        curr = get(L)-1;
        deleteFront(L);
        List temp = G-&gt;list[curr];
        moveFront(temp);
        while(index(temp) != -1) {
            int adj_index = get(temp)-1;
            if(G-&gt;color[adj_index] == WHITE) {
                G-&gt;color[adj_index] = GRAY;
                G-&gt;distance[adj_index] = G-&gt;distance[curr]+1;
                G-&gt;parent[adj_index] = curr+1;
                append(L, get(temp));
            }
            moveNext(temp);
        }
        G-&gt;color[curr] = BLACK;
    }
    freeList(&amp;L);
}

//  Other Operations ----------------------------------------------------------------------

//  Prints adjacency list of G to the out-file
void printGraph(FILE* out, Graph G) {
    if(G == NULL) {
        printf("Graph Error: calling printGraph() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }
    
    for(int i = 0; i &lt; G-&gt;order; i++) {
        fprintf(out, "%d: ", i+1);
        printList(out, G-&gt;list[i]);
        fprintf(out, "\n");
</font>    }
}

//  Returns the transpose to graph G. Reverses the edges
<a name="2"></a><font color="#0000FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/Graph.c/part_2/report/match0-0.html#2" target="0"><img align="left" alt="other" border="0" src="./tm_2_7.gif"></a>

Graph transpose(Graph G) {
    if(G == NULL) {
        printf("Graph Error: calling transpose() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }

    Graph T = newGraph(getOrder(G));
    List L = NULL;
    for(int i = 0; i &lt; getOrder(G); i++) {
        L = G-&gt;list[i];
        for(moveFront(L); index(L) &gt;= 0; moveNext(L)) {
            addArc(T, get(L), i+1);
        }
    }

    return T;
}

//  Copies all aspects of graph G into a new graph, and returns it
Graph copyGraph(Graph G) {
    if(G == NULL) {
        printf("Graph Error: calling copyGraph() on NULL Graph reference\n");
        exit(EXIT_FAILURE);
    }

    Graph copyResult = newGraph(getOrder(G));
    copyResult-&gt;order = getOrder(G);
    copyResult-&gt;size = getSize(G);
    copyResult-&gt;sourceVertex = getSource(G);

    for(int i = 0; i &lt; getOrder(G); i++) {
        copyResult-&gt;list[i] = copyList(G-&gt;list[i]);    
        copyResult-&gt;color[i] = G-&gt;color[i];
</font>        copyResult-&gt;parent[i] = G-&gt;parent[i];    
        copyResult-&gt;distance[i] = G-&gt;distance[i];    
        copyResult-&gt;discover[i] = G-&gt;discover[i];    
        copyResult-&gt;finish[i] = G-&gt;finish[i];    
    }

    return copyResult;
}</pre>


</body></html>