
<!-- saved from url=(0117)file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter24/Graph.c/part_4/report/match0-0.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>/winter25/smandal2/pa3/Graph.c</title>
</head>
<body bgcolor="white">
<hr>
/winter25/smandal2/pa3/Graph.c<p></p><pre>/*
Name: Shivani Mandalaparthi
Assignment: pa3
File name: Graph.c
cruzid: smandal2
*/




#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include "Graph.h"

typedef struct GraphObj {
   List* neighbors; 
<a name="1"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter24/Graph.c/part_4/report/match0-1.html#1" target="1"><img align="left" alt="other" border="0" src="./tm_1_14.gif"></a>

   int* color; 
   int* discover;
   int* finish;
   int* parent;
   int order;
   int size;
} GraphObj;

Graph newGraph(int n) {
   Graph G;
   G = malloc(sizeof(GraphObj));
   assert(G != NULL);
   G-&gt;order = n;
   G-&gt;size = 0;
   G-&gt;neighbors = (List*)calloc(n + 1, sizeof(List));
   for (int i = 0; i &lt; n + 1; i++) {
      G-&gt;neighbors[i] = newList();
   }
   G-&gt;color = (int*)calloc(n + 1, sizeof(int));
   G-&gt;parent = (int*)calloc(n + 1, sizeof(int));
   for (int i = 0; i &lt; n + 1; i++) {
      G-&gt;parent[i] = NIL;
   }
   G-&gt;discover = (int*)calloc(n + 1, sizeof(int));
   G-&gt;finish = (int*)calloc(n + 1, sizeof(int));
   for (int i = 0; i &lt; n + 1; i++) {
      G-&gt;discover[i] = UNDEF;
      G-&gt;finish[i] = UNDEF;
   }
   return G;
}

void freeGraph(Graph* pG) {
   if (pG != NULL &amp;&amp; *pG != NULL) { 
</font><a name="4"></a><font color="#FF00FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter24/Graph.c/part_4/report/match0-1.html#4" target="1"><img align="left" alt="other" border="0" src="./tm_4_3.gif"></a>

      for (int n = 0; n &lt;= (*pG)-&gt;order; n++) {
         freeList(&amp;((*pG)-&gt;neighbors)[n]);  
      }
      free((*pG)-&gt;neighbors);
      (*pG)-&gt;neighbors = NULL;
      if ((*pG)-&gt;color != NULL) { 
         free((*pG)-&gt;color);
         (*pG)-&gt;color = NULL;
</font>      }
      if ((*pG)-&gt;parent != NULL) { 
         free((*pG)-&gt;parent);
         (*pG)-&gt;parent = NULL;
      }
      if ((*pG)-&gt;discover != NULL) {
<a name="3"></a><font color="#00FFFF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter24/Graph.c/part_4/report/match0-1.html#3" target="1"><img align="left" alt="other" border="0" src="./tm_3_3.gif"></a>

         free((*pG)-&gt;discover);
         (*pG)-&gt;discover = NULL;
      }
      if ((*pG)-&gt;finish != NULL) {
         free((*pG)-&gt;finish);
         (*pG)-&gt;finish = NULL;
      }
   }
   free(*pG);
   (*pG) = NULL;
}

int getOrder(Graph G) {
   if (G == NULL) {
      fprintf(stderr, "NULL Graph in getOrder\n");
      exit(EXIT_FAILURE);
   }
   return G-&gt;order;
</font>}

int getSize(Graph G) {
   if (G == NULL) {
      fprintf(stderr, "NULL Graph in getSize\n");
      exit(EXIT_FAILURE);
   }
   return G-&gt;size;
}

int getParent(Graph G, int u) {
   if (G == NULL) {
      fprintf(stderr, "NULL Graph in getParent\n");
      exit(EXIT_FAILURE);
   }
   if (u &lt; 1 || u &gt; G-&gt;order) {
      fprintf(stderr, "Out of Bounds index in getParent\n");
      exit(EXIT_FAILURE);
   }
   return G-&gt;parent[u];
}

int getDiscover(Graph G, int u) {
   if (G == NULL) {
      fprintf(stderr, "NULL Graph in getdiscover\n");
      exit(EXIT_FAILURE);
   }
   if (u &lt; 1 || u &gt; G-&gt;order) {
      fprintf(stderr, "Out of Bounds index in getdiscover\n");
      exit(EXIT_FAILURE);
   }
   return G-&gt;discover[u];
}

int getFinish(Graph G, int u) {
   if (G == NULL) {
      fprintf(stderr, "Graph Error: calling getFinish() on NULL Graph reference\n");
<a name="0"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter24/Graph.c/part_4/report/match0-1.html#0" target="1"><img align="left" alt="other" border="0" src="./tm_0_55.gif"></a>

      exit(EXIT_FAILURE);
   }
   if (u &lt; 1 || u &gt; G-&gt;order) {
      fprintf(stderr, "Graph Error: calling getFinish() on vertex outside bounds of Graph\n");
      exit(EXIT_FAILURE);
   }
   return G-&gt;finish[u];
}

bool sortedInsert(Graph G, int u, int v) {
   if (G == NULL) {
      fprintf(stderr, "NULL Graph in sortedInsert");
      exit(EXIT_FAILURE);
   }
   if ((u &lt; 1 || u &gt; G-&gt;order) || (v &lt; 1 || v &gt; G-&gt;order)) {
      fprintf(stderr, "Out of Bounds index in sortedInsert");
      exit(EXIT_FAILURE);
   }
   if (length(G-&gt;neighbors[u]) == 0) {
      append(G-&gt;neighbors[u], v);
      return false;
   }
   bool p = false;
   bool repeat = false;
   moveFront(G-&gt;neighbors[u]);
   for (int i = 0; i &lt; length(G-&gt;neighbors[u]); i++) {
      if (v == get(G-&gt;neighbors[u])) {
         repeat = true;
         return repeat;
      }
      if (v &lt; get(G-&gt;neighbors[u])) {
         insertBefore(G-&gt;neighbors[u], v);
         p = true;
         break;
      }
      moveNext(G-&gt;neighbors[u]);
   }
   if (!p) {
      append(G-&gt;neighbors[u], v);
   }
   return repeat;
}

void addEdge(Graph G, int u, int v) {
   if (G == NULL) {
      fprintf(stderr, "NULL Graph in addEdge\n");
      exit(EXIT_FAILURE);
   }
   if ((u &lt; 1 || u &gt; G-&gt;order) || (v &lt; 1 || v &gt; G-&gt;order)) {
      fprintf(stderr, "Out of Bounds index in addEdge");
      exit(EXIT_FAILURE);
   }
   bool dirOne = sortedInsert(G, u, v);
   bool dirTwo = sortedInsert(G, v, u);
   if ((!dirOne) &amp;&amp; (!dirTwo)) {
      G-&gt;size++;
   }
}

void addArc(Graph G, int u, int v) {
   if (G == NULL) {
      fprintf(stderr, "NULL Graph in addArc\n");
      exit(EXIT_FAILURE);
   }
   if ((u &lt; 1 || u &gt; G-&gt;order) || (v &lt; 1 || v &gt; G-&gt;order)) {
      fprintf(stderr, "Out of Bounds index in addArc");
      exit(EXIT_FAILURE);
   }
   bool present = sortedInsert(G, u, v);
   if (!present) {
      G-&gt;size++;
   }
}

int Visit(Graph G, int x, int time) {
   int t = time + 1;
   G-&gt;discover[x] = t;
   G-&gt;color[x] = 1;
   int y;
   moveFront(G-&gt;neighbors[x]);
   for (int i = 0; i &lt; length(G-&gt;neighbors[x]); i++) {
      y = get(G-&gt;neighbors[x]);
      if (G-&gt;color[y] == 0) {
         G-&gt;parent[y] = x;
         t = Visit(G, y, t);
      }
      moveNext(G-&gt;neighbors[x]);
   }
   G-&gt;color[x] = 2;
   t++;
   G-&gt;finish[x] = t;
   return t;
}

void DFS(Graph G, List S) {
   if (G == NULL) {
      fprintf(stderr, "NULL Graph in DFS\n");
      exit(EXIT_FAILURE);
   }
   if (length(S) != G-&gt;order) {
      fprintf(stderr, "Invalid Length List in DFS\n");
      exit(EXIT_FAILURE);
   }
   for (int i = 1; i &lt;= G-&gt;order; i++) {
      G-&gt;color[i] = 0;
      G-&gt;parent[i] = NIL;
   }
   int time = 0;
   moveFront(S);
   for (int x = 0; x &lt; length(S); x++) {
      if (G-&gt;color[get(S)] == 0) {
         time = Visit(G, get(S), time);
      }
      moveNext(S);
   }
   clear(S);
   bool p;
   for (int i = 1; i &lt;= G-&gt;order; i++) {
      if (length(S) == 0) {
         append(S, i);
      } else {
         p = false;
         moveFront(S);
         for (int j = 0; j &lt; length(S); j++) {
            if (G-&gt;finish[i] &gt; G-&gt;finish[get(S)]) {
               insertBefore(S, i);
               p = true;
               break;
            }
            moveNext(S);
         }
         if (!p) {
            append(S, i);
         }
      }
   }
}

Graph transpose(Graph G) {
   if (G == NULL) {
      fprintf(stderr, "NULL Graph in transpose\n");
      exit(EXIT_FAILURE);
   }
   Graph m = newGraph(G-&gt;order);
   for (int u = 1; u &lt;= G-&gt;order; u++) {
      moveFront(G-&gt;neighbors[u]);
      for (int v = 1; v &lt;= length(G-&gt;neighbors[u]); v++) {
         addArc(m, get(G-&gt;neighbors[u]), u);
         moveNext(G-&gt;neighbors[u]);
      }
   }
   return m;
}

Graph copyGraph(Graph G) {
</font>   if (G == NULL) {
      fprintf(stderr, "NULL Graph in copyGraph\n");
      exit(EXIT_FAILURE);
   }
<a name="2"></a><font color="#0000FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter24/Graph.c/part_4/report/match0-1.html#2" target="1"><img align="left" alt="other" border="0" src="./tm_2_5.gif"></a>

   Graph copy = newGraph(G-&gt;order);
   for (int u = 1; u &lt;= G-&gt;order; u++) {
      moveFront(G-&gt;neighbors[u]);
      for (int v = 1; v &lt;= length(G-&gt;neighbors[u]); v++) {
         addArc(copy, u, get(G-&gt;neighbors[u]));
         moveNext(G-&gt;neighbors[u]);
      }
   }
   return copy;
}

void printGraph(FILE* out, Graph G) {
</font>   for (int i = 1; i &lt;= G-&gt;order; i++) {
      fprintf(out, "%d: ", i);
      printList(out, G-&gt;neighbors[i]);
      fprintf(out, "\n");
   }
}
</pre>


</body></html>