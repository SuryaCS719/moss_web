
<!-- saved from url=(0115)file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_2/report/match0-0.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>/winter25/jwaseq/pa3/Graph.c</title>
</head>
<body bgcolor="white">
<hr>
/winter25/jwaseq/pa3/Graph.c<p></p><pre>//-----------------------------------------------------------------------------
// Jason Waseq
// jwaseq
// pa3
// Graph.c
//-----------------------------------------------------------------------------

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include "List.h"
#include "Graph.h"

<a name="1"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_2/report/match0-1.html#1" target="1"><img align="left" alt="other" border="0" src="./tm_1_16.gif"></a>

typedef struct GraphObj{
    List* adjacencyList;
   char** color;
    int** parent;
    int** discover;
    int** finish;
    int order;
    int size;
} GraphObj;

Graph newGraph(int n){
    Graph g = (Graph)calloc(1, sizeof(GraphObj));
    assert(g != NULL);
    g-&gt;adjacencyList = (List*)calloc(n + 1, sizeof(List));
    g-&gt;color = calloc(n + 1, sizeof(char*));
    g-&gt;parent = calloc(n + 1, sizeof(int*));
    g-&gt;discover = calloc(n + 1, sizeof(int*));
    g-&gt;finish = calloc(n + 1, sizeof(int*));

    for(int i = 0; i &lt;= n; i++){
        g-&gt;adjacencyList[i] = newList();
        g-&gt;color[i] = calloc(1, sizeof(char));
        g-&gt;parent[i] = calloc(1, sizeof(int));
        g-&gt;discover[i] = calloc(1, sizeof(int));
        g-&gt;finish[i] = calloc(1, sizeof(int));
        *(g-&gt;color[i]) = 'w';
        *(g-&gt;parent[i]) = NIL;
        *(g-&gt;discover[i]) = UNDEF;
        *(g-&gt;finish[i]) = UNDEF;
    }

    g-&gt;order = n;
    g-&gt;size = 0;
    return g;
}

void freeGraph(Graph* pG){
</font>    if(pG!=NULL &amp;&amp; *pG!=NULL) { 
<a name="0"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_2/report/match0-1.html#0" target="1"><img align="left" alt="other" border="0" src="./tm_0_66.gif"></a>

        for(int i = 0; i &lt;= (*pG)-&gt;order; i++){
            freeList(&amp;((*pG)-&gt;adjacencyList[i]));
            free((*pG)-&gt;color[i]);
            free((*pG)-&gt;parent[i]);
            free((*pG)-&gt;discover[i]);
            free((*pG)-&gt;finish[i]);
        }
      free(((*pG)-&gt;color));
      free(((*pG)-&gt;parent));
      free(((*pG)-&gt;discover));
      free(((*pG)-&gt;finish));
      free((*pG)-&gt;adjacencyList);
      free(*pG);
      *pG = NULL;
      pG = NULL;
   }
}

int getOrder(Graph G){
    return G-&gt;order;
}
int getSize(Graph G){
    return G-&gt;size;
}
int getParent(Graph G, int u){
    if(u &gt;= 1 &amp;&amp; u &lt;= getOrder(G)){
        return *(G-&gt;parent[u]);
        
    }else{
        return NIL;
    }
}

int getDiscover(Graph G, int u){
    if(u &gt;= 1 &amp;&amp; u &lt;= getOrder(G)){
        return *(G-&gt;discover[u]);
    }else{
        return NIL;
    }
}

int getFinish(Graph G, int u){
    if(u &gt;= 1 &amp;&amp; u &lt;= getOrder(G)){
        return *(G-&gt;finish[u]);
    }else{
        return NIL;
    }
}

void addEdge(Graph G, int u, int v){
    if (u == v){
        return;
    }
    
    int i, y = 0;
    if (length(G-&gt;adjacencyList[u]) &gt; 0) {
        moveFront(G-&gt;adjacencyList[u]);
        y = get(G-&gt;adjacencyList[u]);
        if (v &lt; y) {
            prepend(G-&gt;adjacencyList[u], v);
        }
        else {
            for (i = 1; i &lt; length(G-&gt;adjacencyList[u]); i++) {
                moveNext(G-&gt;adjacencyList[u]);
                y = get(G-&gt;adjacencyList[u]);
                if (v &lt; y) {
                    insertBefore(G-&gt;adjacencyList[u], v);
                    break;
                }
            }
        }
        moveBack(G-&gt;adjacencyList[u]);
        y = get(G-&gt;adjacencyList[u]);
        if (y &lt; v) {
            append(G-&gt;adjacencyList[u], v);
        }
    }
    else {
        append(G-&gt;adjacencyList[u], v);
    }
    if (length(G-&gt;adjacencyList[v]) &gt; 0) {
        moveFront(G-&gt;adjacencyList[v]);
        y = get(G-&gt;adjacencyList[v]);
        if (u &lt; y) {
            prepend(G-&gt;adjacencyList[v], u);
        }
        else {
            for (i = 1; i &lt; length(G-&gt;adjacencyList[v]); i++) {
                moveNext(G-&gt;adjacencyList[v]);
                y = get(G-&gt;adjacencyList[v]);
                if (u &lt; y) {
                    insertBefore(G-&gt;adjacencyList[v], u);
                    break;
                }
            }
        }
        moveBack(G-&gt;adjacencyList[v]);
        y = get(G-&gt;adjacencyList[v]);
        if (y &lt; u) {
            append(G-&gt;adjacencyList[v], u);
        }
    }
    else {
        append(G-&gt;adjacencyList[v], u);
    }
    G-&gt;size++;
}

void addArc(Graph G, int u, int v) {
    int i, y = 0;
    if (length(G-&gt;adjacencyList[u]) &gt; 0) {
        moveFront(G-&gt;adjacencyList[u]);
        y = get(G-&gt;adjacencyList[u]);
        if (v &lt; y) {
            prepend(G-&gt;adjacencyList[u], v);
            G-&gt;size++;
        }
        else {
            for (i = 1; i &lt; length(G-&gt;adjacencyList[u]); i++) {
                moveNext(G-&gt;adjacencyList[u]);
                y = get(G-&gt;adjacencyList[u]);
                if (v &lt; y) {
                    insertBefore(G-&gt;adjacencyList[u], v);
                    G-&gt;size++;
                    break;
                }
            }
        }
        moveBack(G-&gt;adjacencyList[u]);
        y = get(G-&gt;adjacencyList[u]);
        if (y &lt; v) {
            append(G-&gt;adjacencyList[u], v);
            G-&gt;size++;
        }
    }
    else {
        append(G-&gt;adjacencyList[u], v);
        G-&gt;size++;
    }
}

void Visit(Graph G, List S, int x, int * ptime) {
    (*ptime)++;
    *(G-&gt;discover[x]) = *ptime;
    *(G-&gt;color[x]) = 'g';
    int y;
    for (moveFront(G-&gt;adjacencyList[x]); index(G-&gt;adjacencyList[x]) &gt;= 0; moveNext(G-&gt;adjacencyList[x])) {
        y = get(G-&gt;adjacencyList[x]);
        if (*(G-&gt;color[y]) == 'w') {
            *(G-&gt;parent[y]) = x;
            Visit(G, S, y, ptime);
        }
    }
    *(G-&gt;color[x]) = 'b';
    (*ptime)++;
    *(G-&gt;finish[x]) = *ptime;
    append(S, x);

}

void DFS(Graph G, List S){
    for(int x = 0; x &lt;= getOrder(G); x++){
        *(G-&gt;color[x]) = 'w';
        *(G-&gt;parent[x]) = NIL;
    }
    int time = 0;

    for(int x = 1; x &lt;= getOrder(G); x++){
        int y = front(S);
        deleteFront(S);
        if (*(G-&gt;color[y]) == 'w') {
            Visit(G, S, y, &amp;time);
        }
    }

    List S1 = newList();
    for (moveFront(S); index(S) &gt;= 0; moveNext(S)) {
        int y = get(S);
        prepend(S1, y);
    }
    clear(S);
    for (moveFront(S1); index(S1) &gt;= 0; moveNext(S1)) {
        int y = get(S1);
        append(S, y);
    }
    freeList(&amp;S1);
}


Graph transpose(Graph G) {
    Graph outgraph = newGraph(getOrder(G));
    for (int x = 1; x &lt;= getOrder(G); x++){
</font>        for (moveFront(G-&gt;adjacencyList[x]); index(G-&gt;adjacencyList[x]) &gt;= 0; moveNext(G-&gt;adjacencyList[x])) {
<a name="3"></a><font color="#00FFFF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_2/report/match0-1.html#3" target="1"><img align="left" alt="other" border="0" src="./tm_3_2.gif"></a>

            int y = get(G-&gt;adjacencyList[x]);
            addArc(outgraph, y, x);
        }
    }
    return outgraph;
}
Graph copyGraph(Graph G){
    Graph outgraph = newGraph(getOrder(G));
    for (int x = 1; x &lt;= getOrder(G); x++){
</font>        for (moveFront(G-&gt;adjacencyList[x]); index(G-&gt;adjacencyList[x]) &gt;= 0; moveNext(G-&gt;adjacencyList[x])) {
<a name="2"></a><font color="#0000FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_fall23/Graph.c/part_2/report/match0-1.html#2" target="1"><img align="left" alt="other" border="0" src="./tm_2_7.gif"></a>

            int y = get(G-&gt;adjacencyList[x]);
            addArc(outgraph, x, y);
        }
    }
    return outgraph;
}

void printGraph(FILE* out, Graph G){
    for(int i = 1; i &lt;= getOrder(G); i++){
        moveFront(G-&gt;adjacencyList[i]);
        fprintf(out, "%d:", i);
        while(index(G-&gt;adjacencyList[i]) &gt;= 0){
            int neighbor = get(G-&gt;adjacencyList[i]);
            fprintf(out, " %d", neighbor);
            moveNext(G-&gt;adjacencyList[i]);
        }
        if(length(G-&gt;adjacencyList[i]) == 0){
            fprintf(out, " ");
        }
        fprintf(out, "\n");
</font>    }
}

</pre>


</body></html>