
<!-- saved from url=(0117)file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter23/Graph.c/part_4/report/match5-0.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>/winter25/saemlee/pa3/Graph.c</title>
</head>
<body bgcolor="white">
<hr>
/winter25/saemlee/pa3/Graph.c<p></p><pre>/***
 * Sabrina Lee
 * saemlee 
 * 2025 Winter CSE101 PA3
 * Graph.c
 * Implementation of a graph data structure with 
 * depth-first search and various graph manipulation functions.
 ***/

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;
#include "Graph.h"

#define INF -99
#define NIL 0
#define UNDEF -1

<a name="1"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter23/Graph.c/part_4/report/match5-1.html#1" target="1"><img align="left" alt="other" border="0" src="./tm_1_7.gif"></a>

typedef struct GraphObj {
    List *adjacencyLists;
    char *vertexColors;
    int *vertexParents;
    int *vertexDistances;
    int *numVertices;
    int numEdges;
    int sourceVertex;
} GraphObj;

void Visit(Graph G, int x, int *time);

/*** Constructors-Destructors ***/

// Function newGraph() returns a Graph pointing to a newly created GraphObj representing a graph having n vertices and no edges.
Graph newGraph(int n) {
    Graph G = malloc(sizeof(GraphObj));
    assert(G != NULL);

    G-&gt;adjacencyLists = malloc(sizeof(List*) * (n + 1));
    G-&gt;vertexColors = malloc(sizeof(char) * (n + 1)); // Fix char* to char
</font>    G-&gt;vertexParents = malloc(sizeof(int) * (n + 1));  // Fix int* to int
    G-&gt;vertexDistances = malloc(sizeof(int) * (n + 1)); 
    G-&gt;numVertices = malloc(sizeof(int) * (n + 1)); 

    // Initialize all lists and attributes
    for (int i = 1; i &lt;= n; i++) {
        G-&gt;adjacencyLists[i] = newList();
        G-&gt;vertexColors[i] = 'w';
        G-&gt;vertexParents[i] = NIL;
        G-&gt;vertexDistances[i] = UNDEF; 
        G-&gt;numVertices[i] = UNDEF;
    }

    G-&gt;numEdges = n;
    G-&gt;sourceVertex = 0;

    return G;
}

// Function freeGraph frees all heap memory associated with the Graph *pG, then sets the handle *pG to NULL.
void freeGraph(Graph* pG) { 
    if (pG &amp;&amp; *pG) {
        // Free all adjacency lists
        for (int i = 1; i &lt;= (*pG)-&gt;numEdges; i++) {
            freeList(&amp;(*pG)-&gt;adjacencyLists[i]);
        }

        // Free remaining fields
        free((*pG)-&gt;adjacencyLists);
        free((*pG)-&gt;vertexColors);
        free((*pG)-&gt;vertexParents);
        free((*pG)-&gt;numVertices);
        free((*pG)-&gt;vertexDistances);
        
        // Finally, free the graph object itself
        free(*pG);
        *pG = NULL;
    }
}

/*** Access functions ***/

// Function getOrder returns the number of vertices
int getOrder(Graph G) {
    if (!G) {
        printf("Graph Error: calling getOrder() on NULL Graph\n");
        exit(EXIT_FAILURE);
    }
    return G-&gt;numEdges;
}

// Function getSize returns the number of edges
int getSize(Graph G) {
    if (!G) {
        printf("Graph Error: calling getSize() on NULL Graph\n");
        exit(EXIT_FAILURE);
    }
    return G-&gt;sourceVertex;
}

// Function getParent returns the parent of vertex u in the BFS tree created by BFS(), or NIL if BFS() has not yet been called.
int getParent(Graph G, int u) {
    if (!G || u &lt; 1 || u &gt; getOrder(G)) {
        printf("Graph Error: calling getParent() on invalid vertex\n");
        exit(EXIT_FAILURE);
    }
    return G-&gt;vertexParents[u];
}

// Function getDiscover returns the discovery time of vertex u
int getDiscover(Graph G, int u) {
    if (!G || u &lt; 1 || u &gt; getOrder(G)) {
        printf("Graph Error: calling getDiscover() on invalid vertex\n");
        exit(EXIT_FAILURE);
    }
    return G-&gt;vertexDistances[u];
}

// Function getFinish returns the finish time of vertex u
int getFinish(Graph G, int u) {
<a name="7"></a><font color="#0000FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter23/Graph.c/part_4/report/match5-1.html#7" target="1"><img align="left" alt="other" border="0" src="./tm_2_3.gif"></a>

    if (!G || u &lt; 1 || u &gt; getOrder(G)) {
        printf("Graph Error: calling getFinish() on invalid vertex\n");
        exit(EXIT_FAILURE);
    }
    return G-&gt;numVertices[u];
}


/*** Manipulation procedures ***/

// Function addEdge() inserts a new edge joining u to v
void addEdge(Graph G, int u, int v) {
    if (G == NULL) {
        printf("Graph Error: calling addEdge() on NULL Graph\n");
        exit(EXIT_FAILURE);
    }
    if (getOrder(G) &lt; 1 || u &lt; 1 || u &gt; getOrder(G) || v &lt; 1 || v &gt; getOrder(G)) {
</font><a name="3"></a><font color="#00FFFF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter23/Graph.c/part_4/report/match5-1.html#3" target="1"><img align="left" alt="other" border="0" src="./tm_3_4.gif"></a>

        printf("Graph Error: calling addEdge() on invalid vertices\n");
        exit(EXIT_FAILURE);
    }
    // Add arcs in both directions
    addArc(G, u, v);
    addArc(G, v, u);
    G-&gt;sourceVertex--;
}

// Function addArc() inserts a new directed edge from u to v
void addArc(Graph G, int u, int v) {
    if (G == NULL) {
        printf("Graph Error: calling addArc() on NULL Graph\n");
        exit(EXIT_FAILURE);
    }
    if (getOrder(G) &lt; 1 || u &lt; 1 || u &gt; getOrder(G) || v &lt; 1 || v &gt; getOrder(G)) {
</font>        printf("Graph Error: calling addArc() on invalid vertices\n");
        exit(EXIT_FAILURE);
    }

    // Insert v into adjacency list of u if not already present
    List adjacencyList = G-&gt;adjacencyLists[u];
    moveFront(adjacencyList);
    
    while (index(adjacencyList) != -1) {
        int current = get(adjacencyList);
        if (current == v) return;  // Already exists
        if (current &gt; v) {
            insertBefore(adjacencyList, v);
            return;
        }
        moveNext(adjacencyList);
    }
<a name="0"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter23/Graph.c/part_4/report/match5-1.html#0" target="1"><img align="left" alt="other" border="0" src="./tm_0_7.gif"></a>

    append(adjacencyList, v);  // If not found, append to the list
    G-&gt;sourceVertex++;
}

// Depth-First Search
void DFS(Graph G, List S) {
    if (G == NULL || S == NULL) {
        printf("Graph Error: calling DFS() on NULL Graph\n");
        exit(EXIT_FAILURE);
    }
    if (getOrder(G) != length(S)) {
        printf("Graph Error: Invalid stack and order\n");
        exit(EXIT_FAILURE);
    }

    // Initialize vertex colors and parents
    for (int i = 1; i &lt;= getOrder(G); i++) {
        G-&gt;vertexColors[i] = 'w';
        G-&gt;vertexParents[i] = NIL;
    }

    int time = 0;
    moveFront(S);
    while (index(S) &gt;= 0) {
</font>        int vertex = get(S);
        if (G-&gt;vertexColors[vertex] == 'w') {
<a name="2"></a><font color="#0000FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter23/Graph.c/part_4/report/match5-1.html#2" target="1"><img align="left" alt="other" border="0" src="./tm_2_6.gif"></a>

            Visit(G, vertex, &amp;time);  // Perform DFS visit
        }
        moveNext(S);
    }

    // Reorder list S based on finish times (numVertices)
    List temp = newList();
    for (int i = 1; i &lt;= getOrder(G); i++) {
        moveFront(temp);
        while (index(temp) != -1 &amp;&amp; G-&gt;numVertices[get(temp)] &gt; G-&gt;numVertices[i]) {
            moveNext(temp);
        }
        if (index(temp) == -1) {
            append(temp, i);
        } else {
            insertBefore(temp, i);
        }
    }

    clear(S);
    moveFront(temp);
</font>    while (index(temp) &gt;= 0) {
<a name="4"></a><font color="#FF00FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter23/Graph.c/part_4/report/match5-1.html#4" target="1"><img align="left" alt="other" border="0" src="./tm_4_4.gif"></a>

        append(S, get(temp));  // Refill the stack with the reversed order
        moveNext(temp);
    }
    freeList(&amp;temp);
}


void Visit(Graph G, int x, int *time) {
    if (G == NULL) {
        printf("Graph Error: calling Visit() on NULL Graph\n");
        exit(EXIT_FAILURE);
    }

    G-&gt;vertexDistances[x] = ++(*time);
    G-&gt;vertexColors[x] = 'g';
</font>
    // Use a more explicit iterator pattern
    List adjacencyList = G-&gt;adjacencyLists[x];
    for (moveFront(adjacencyList); index(adjacencyList) &gt;= 0; moveNext(adjacencyList)) {
        int neighbor = get(adjacencyList);
        if (G-&gt;vertexColors[neighbor] == 'w') {
            G-&gt;vertexParents[neighbor] = x;
            Visit(G, neighbor, time);
        }
    }

<a name="6"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter23/Graph.c/part_4/report/match5-1.html#6" target="1"><img align="left" alt="other" border="0" src="./tm_1_4.gif"></a>

    G-&gt;vertexColors[x] = 'b';
    G-&gt;numVertices[x] = ++(*time);
}

Graph transpose(Graph G) {
    if (G == NULL) {
        printf("Graph Error: calling transpose() on NULL Graph\n");
        exit(EXIT_FAILURE);
    }

    Graph T = newGraph(getOrder(G));
    for (int i = 1; i &lt;= getOrder(G); i++) {
</font>        List adjacencyList = G-&gt;adjacencyLists[i];
        for (moveFront(adjacencyList); index(adjacencyList) &gt;= 0; moveNext(adjacencyList)) {
            addArc(T, get(adjacencyList), i);
        }
    }
    return T;
}

Graph copyGraph(Graph G) {
    if (G == NULL) {
        printf("Graph Error: calling copyGraph() on NULL Graph\n");
        exit(EXIT_FAILURE);
    }

    Graph C = newGraph(getOrder(G));
    for (int i = 1; i &lt;= getOrder(G); i++) {
        List adjacencyList = G-&gt;adjacencyLists[i];
        for (moveFront(adjacencyList); index(adjacencyList) &gt;= 0; moveNext(adjacencyList)) {
            addArc(C, i, get(adjacencyList));
        }
    }
<a name="5"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter23/Graph.c/part_4/report/match5-1.html#5" target="1"><img align="left" alt="other" border="0" src="./tm_0_4.gif"></a>

    C-&gt;numEdges = getOrder(G);
    return C;
}

void printGraph(FILE* out, Graph G) {
    if (G == NULL) {
        printf("Graph Error: calling printGraph() on NULL Graph\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 1; i &lt;= getOrder(G); i++) {
        fprintf(out, "%d: ", i);
        printList(out, G-&gt;adjacencyLists[i]);
</font>        fprintf(out, "\n");
    }
}
</pre>


</body></html>