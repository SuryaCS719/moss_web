
<!-- saved from url=(0117)file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match2-1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>/winter25/ataneja1/pa3/Graph.c</title>
</head>
<body bgcolor="white">
<hr>
/winter25/vsingha3/pa3/Graph.c<p></p><pre>// Vani Singhal
//vsingha3@ucsc.edu
//pa3

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "Graph.h"


<a name="2"></a><font color="#0000FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match2-0.html#2" target="0"><img align="left" alt="other" border="0" src="./tm_2_7.gif"></a>

typedef struct GraphObj {
    int order;
    int size;
    List* adj;
    int* parent;
    int* discover;
    int* finish;
} GraphObj;

void Visit(Graph G, int u, int* time, List S){
	G-&gt;discover[u] = ++(*time);
    for (moveFront(G-&gt;adj[u]); index(G-&gt;adj[u]) &gt;= 0; moveNext(G-&gt;adj[u])) {
</font>        int v = get(G-&gt;adj[u]);
<a name="3"></a><font color="#00FFFF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match2-0.html#3" target="0"><img align="left" alt="other" border="0" src="./tm_3_6.gif"></a>

        if (G-&gt;discover[v] == UNDEF) {
            G-&gt;parent[v] = u;
            Visit(G, v, time, S);
        }
    }
    G-&gt;finish[u] = ++(*time);
    prepend(S, u);
}

Graph newGraph(int n) {
    Graph G = malloc(sizeof(GraphObj));
    G-&gt;order = n;
    G-&gt;size = 0;
    G-&gt;adj = calloc(n + 1, sizeof(List));
</font>    G-&gt;parent = calloc(n + 1, sizeof(int));
    G-&gt;discover = calloc(n + 1, sizeof(int));
    G-&gt;finish = calloc(n + 1, sizeof(int));
    for (int i = 1; i &lt;= n; i++) {
        G-&gt;adj[i] = newList();
        G-&gt;parent[i] = NIL;
        G-&gt;discover[i] = UNDEF;
        G-&gt;finish[i] = UNDEF;
    }
    return G;
}

void freeGraph(Graph* pG) {
    if (pG != NULL &amp;&amp; *pG != NULL) {
        for (int i = 1; i &lt;= (*pG)-&gt;order; i++) {
            freeList(&amp;((*pG)-&gt;adj[i]));
        }
        free((*pG)-&gt;adj);
        free((*pG)-&gt;parent);
        free((*pG)-&gt;discover);
        free((*pG)-&gt;finish);
        free(*pG);
        *pG = NULL;
    }
}


int getSize(Graph G) {
    if (G == NULL) {
        fprintf(stderr, "Error: Calling getSize() on NULL Graph\n");
        exit(EXIT_FAILURE);
    }
    return G-&gt;size;
}

int getOrder(Graph G) {
<a name="1"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match2-0.html#1" target="0"><img align="left" alt="other" border="0" src="./tm_1_15.gif"></a>

    if (G == NULL) {
        fprintf(stderr, "Error: Calling getOrder() on NULL Graph\n");
        exit(EXIT_FAILURE);
    }
    return G-&gt;order;
}

int getParent(Graph G, int u) {
    if (G == NULL || u &lt; 1 || u &gt; G-&gt;order) {
        fprintf(stderr, "Error: Calling getParent() with invalid vertex\n");
        exit(EXIT_FAILURE);
    }
    return G-&gt;parent[u] == 0 ? NIL : G-&gt;parent[u];
}

int getDiscover(Graph G, int u) {
    if (G == NULL || u &lt; 1 || u &gt; G-&gt;order) {
        fprintf(stderr, "Error: Calling getDiscover() with invalid vertex\n");
        exit(EXIT_FAILURE);
    }
    return G-&gt;discover[u];
}

int getFinish(Graph G, int u) {
    if (G == NULL || u &lt; 1 || u &gt; G-&gt;order) {
        fprintf(stderr, "Error: Calling getFinish() with invalid vertex\n");
        exit(EXIT_FAILURE);
    }
    return G-&gt;finish[u];
}


void addEdge(Graph G, int u, int v) {
</font><a name="0"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match2-0.html#0" target="0"><img align="left" alt="other" border="0" src="./tm_0_16.gif"></a>

    if (u &lt; 1 || u &gt; G-&gt;order || v &lt; 1 || v &gt; G-&gt;order) {
        fprintf(stderr, "Graph Error: calling addEdge() with invalid vertices %d, %d\n", u, v);
        exit(EXIT_FAILURE);
    }
    addArc(G, u, v);
    addArc(G, v, u);
    G-&gt;size--;
}

void addArc(Graph G, int u, int v) {
    if (u &lt; 1 || u &gt; G-&gt;order || v &lt; 1 || v &gt; G-&gt;order) {
        fprintf(stderr, "Graph Error: calling addArc() with invalid vertices %d, %d\n", u, v);
        exit(EXIT_FAILURE);
    }
    List adjU = G-&gt;adj[u];
    moveFront(adjU);
    while (index(adjU) &gt;= 0 &amp;&amp; get(adjU) &lt; v) {
        moveNext(adjU);
    }
    if (index(adjU) == -1) {
        append(adjU, v);
    } else {
        insertBefore(adjU, v);
    }
    G-&gt;size++;
}

void DFS(Graph G, List S) {

    if (length(S) != G-&gt;order) {
        fprintf(stderr, "DFS Error: List size does not match graph order.\n");
        exit(EXIT_FAILURE);
    }
    
    for (int i = 1; i &lt;= G-&gt;order; i++) {
</font>        G-&gt;parent[i] = NIL;
        G-&gt;discover[i] = UNDEF;
        G-&gt;finish[i] = UNDEF;
    }
    
    int time = 0;
    List temp = copyList(S);
    clear(S);
    
    for (moveFront(temp); index(temp) &gt;= 0; moveNext(temp)) {
<a name="4"></a><font color="#FF00FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match2-0.html#4" target="0"><img align="left" alt="other" border="0" src="./tm_4_4.gif"></a>

        int u = get(temp);
        if (G-&gt;discover[u] == UNDEF) {
            Visit(G, u, &amp;time, S);
        }
    }
    freeList(&amp;temp);    
}

// Other Functions
Graph transpose(Graph G) {
    Graph T = newGraph(G-&gt;order);
    for (int u = 1; u &lt;= G-&gt;order; u++) {
</font>        for (moveFront(G-&gt;adj[u]); index(G-&gt;adj[u]) &gt;= 0; moveNext(G-&gt;adj[u])) {
<a name="6"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match2-0.html#6" target="0"><img align="left" alt="other" border="0" src="./tm_1_3.gif"></a>

            int v = get(G-&gt;adj[u]);
            addArc(T, v, u);
        }
    }
    return T;
}

Graph copyGraph(Graph G) {
    Graph C = newGraph(G-&gt;order);
    for (int u = 1; u &lt;= G-&gt;order; u++) {
</font>        for (moveFront(G-&gt;adj[u]); index(G-&gt;adj[u]) &gt;= 0; moveNext(G-&gt;adj[u])) {
<a name="5"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match2-0.html#5" target="0"><img align="left" alt="other" border="0" src="./tm_0_3.gif"></a>

            int v = get(G-&gt;adj[u]);
            addArc(C, u, v);
        }
    }
    return C;
}

void printGraph(FILE* out, Graph G) {
    for (int i = 1; i &lt;= G-&gt;order; i++) {
</font>        fprintf(out, "%d: ", i);
        printList(out, G-&gt;adj[i]);
        fprintf(out, "\n");
    }
}
</pre>


</body></html>