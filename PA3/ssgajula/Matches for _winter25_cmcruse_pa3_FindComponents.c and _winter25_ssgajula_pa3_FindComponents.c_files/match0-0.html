
<!-- saved from url=(0126)file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/FindComponents.c/part_1/report/match0-0.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>/winter25/cmcruse/pa3/FindComponents.c</title>
</head>
<body bgcolor="white">
<hr>
/winter25/cmcruse/pa3/FindComponents.c<p></p><pre>/********************************************************************************
* FindComponents.c
* Program to find strongly connected components in a directed graph
********************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "Graph.h"
#include "List.h"

#define MAX_LINE_LENGTH 1024

// Helper function to wrap index operations
static int ListIndex(List L) {
    return index(L);
}

/**
 * Reads input file into array of strings
 * @param in    Input file pointer
 * @param lines Address of string array to store lines
 * @return      Number of lines read, or -1 on error
 */
<a name="1"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/FindComponents.c/part_1/report/match0-1.html#1" target="1"><img align="left" alt="other" border="0" src="./tm_1_14.gif"></a>

int readInputFile(FILE *in, char ***lines) {
    if (in == NULL || lines == NULL) {
        fprintf(stderr, "Error: Invalid input parameters\n");
        return -1;
    }

    int lineCount = 0;
    char buffer[MAX_LINE_LENGTH];
    *lines = NULL;

    // Read file line by line
    while (fgets(buffer, sizeof(buffer), in)) {
        // Remove trailing newline if present
        size_t len = strlen(buffer);
        if (len &gt; 0 &amp;&amp; buffer[len - 1] == '\n') {
            buffer[len - 1] = '\0';
        }

        // Reallocate array to hold new line
        char **temp = realloc(*lines, (lineCount + 1) * sizeof(char *));
        if (temp == NULL) {
</font>            // Clean up on allocation failure
<a name="4"></a><font color="#FF00FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/FindComponents.c/part_1/report/match0-1.html#4" target="1"><img align="left" alt="other" border="0" src="./tm_4_6.gif"></a>

            for (int i = 0; i &lt; lineCount; i++) {
                free((*lines)[i]);
            }
            free(*lines);
            *lines = NULL;
            return -1;
        }
        *lines = temp;

        // Allocate and copy the current line
        (*lines)[lineCount] = malloc(strlen(buffer) + 1);
        if ((*lines)[lineCount] == NULL) {
</font>            // Clean up on allocation failure
<a name="5"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/FindComponents.c/part_1/report/match0-1.html#5" target="1"><img align="left" alt="other" border="0" src="./tm_0_5.gif"></a>

            for (int i = 0; i &lt; lineCount; i++) {
                free((*lines)[i]);
            }
            free(*lines);
            *lines = NULL;
            return -1;
        }
        strcpy((*lines)[lineCount], buffer);
        lineCount++;
    }
    return lineCount;
}

/**
 * Finds strongly connected components in the graph
 * @param G      Original graph
 * @param GT     Transpose of the graph
 * @param S      List containing vertices in DFS finish order
 * @param SCCs   Array of Lists to store components
 * @param order  Number of vertices
 * @return       Number of strongly connected components found
 */
int findSCCs(Graph G, Graph GT, List S, List *SCCs, int order) {
</font>    int componentCount = 0;

    // Initialize Lists for each possible component
<a name="3"></a><font color="#00FFFF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/FindComponents.c/part_1/report/match0-1.html#3" target="1"><img align="left" alt="other" border="0" src="./tm_3_7.gif"></a>

    for (int i = 0; i &lt; order; i++) {
        SCCs[i] = newList();
    }

    // Process vertices in decreasing finish time order
    moveFront(S);
    while (ListIndex(S) != -1) {
        int vertex = get(S);
        // Start of new component if vertex has no parent
        if (getParent(GT, vertex) == NIL) {
            componentCount++;
        }
        append(SCCs[componentCount - 1], vertex);
</font>        moveNext(S);
    }

    return componentCount;
}

/**
 * Prints the strongly connected components
 * @param out   Output file pointer
 * @param SCCs  Array of Lists containing components
 * @param count Number of components
 */
void printSCCs(FILE *out, List *SCCs, int count) {
<a name="2"></a><font color="#0000FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/FindComponents.c/part_1/report/match0-1.html#2" target="1"><img align="left" alt="other" border="0" src="./tm_2_10.gif"></a>

    fprintf(out, "\nG contains %d strongly connected components:\n", count);
    
    // Print components in reverse order (topological sort)
    for (int i = 0; i &lt; count; i++) {
        fprintf(out, "Component %d: ", i + 1);
        moveFront(SCCs[count - i - 1]);
        
        // Print vertices in current component
        while (ListIndex(SCCs[count - i - 1]) != -1) {
            fprintf(out, "%d", get(SCCs[count - i - 1]));
            moveNext(SCCs[count - i - 1]);
</font>            if (ListIndex(SCCs[count - i - 1]) != -1) {
                fprintf(out, " ");
            }
        }
        fprintf(out, "\n");
    }
}

int main(int argc, char *argv[]) {
    // Check command line arguments
<a name="0"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/FindComponents.c/part_1/report/match0-1.html#0" target="1"><img align="left" alt="other" border="0" src="./tm_0_28.gif"></a>

    if (argc != 3) {
        fprintf(stderr, "Usage: %s &lt;input file&gt; &lt;output file&gt;\n", argv[0]);
        return 1;
    }

    // Open input file
    FILE *in = fopen(argv[1], "r");
    if (in == NULL) {
        fprintf(stderr, "Error: Cannot open input file %s\n", argv[1]);
        return 1;
    }

    // Read input file
    char **lines = NULL;
    int lineCount = readInputFile(in, &amp;lines);
    fclose(in);

    if (lineCount == -1) {
        fprintf(stderr, "Error: Failed to read input file\n");
        return 1;
    }

    // Create and build the graph
    int order = atoi(lines[0]);
    Graph G = newGraph(order);

    // Add edges until "0 0" is encountered
    int currentLine = 1;
    while (strcmp(lines[currentLine], "0 0") != 0) {
        int source, dest;
        sscanf(lines[currentLine], "%d %d", &amp;source, &amp;dest);
        addArc(G, source, dest);
        currentLine++;
    }

    // Open output file
    FILE *out = fopen(argv[2], "w");
    if (out == NULL) {
        fprintf(stderr, "Error: Cannot open output file %s\n", argv[2]);
        freeGraph(&amp;G);
        for (int i = 0; i &lt; lineCount; i++) free(lines[i]);
        free(lines);
        return 1;
    }

    // Print adjacency list
    fprintf(out, "Adjacency list representation of G:\n");
    printGraph(out, G);

    // Perform DFS and find SCCs
    List S = newList();
    for (int i = 1; i &lt;= order; i++) {
        append(S, i);
</font>    }

    DFS(G, S);                     // First DFS on G
    Graph GT = transpose(G);       // Create transpose graph
    DFS(GT, S);                   // Second DFS on transpose

    // Find and print SCCs
    List SCCs[order];
    int componentCount = findSCCs(G, GT, S, SCCs, order);
    printSCCs(out, SCCs, componentCount);

    // Clean up
    for (int i = 0; i &lt; componentCount; i++) {
        freeList(&amp;SCCs[i]);
    }
<a name="6"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_spring23/FindComponents.c/part_1/report/match0-1.html#6" target="1"><img align="left" alt="other" border="0" src="./tm_1_4.gif"></a>

    fclose(out);
    freeGraph(&amp;G);
    freeGraph(&amp;GT);
    freeList(&amp;S);
    for (int i = 0; i &lt; lineCount; i++) {
        free(lines[i]);
    }
    free(lines);

    return 0;
</font>}</pre>


</body></html>