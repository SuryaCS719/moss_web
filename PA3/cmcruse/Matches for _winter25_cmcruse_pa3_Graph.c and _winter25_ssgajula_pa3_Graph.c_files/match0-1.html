
<!-- saved from url=(0119)file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match0-1.html#3 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>/winter25/cmcruse/pa3/Graph.c</title>
</head>
<body bgcolor="white">
<hr>
/winter25/ssgajula/pa3/Graph.c<p></p><pre>//Suraj Gajula
//ssgajula
//2025 Winter CSE101 PA3
//Graph.c
//Code for Graph ADT
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include "Graph.h"
#include "List.h"

typedef struct GraphObj {
    List *neighbors;
<a name="3"></a><font color="#00FFFF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match0-0.html#3" target="0"><img align="left" alt="other" border="0" src="./tm_3_5.gif"></a>

    int *colors;
    int *parents;
    int *discovers;
    int *finishes;
    int order;
    int size;
} GraphObj;

Graph newGraph(int n) {
    Graph G = malloc(sizeof(GraphObj));
    if (G == NULL) {
        fprintf(stderr, "Graph Error: unable to allocate memory for new Graph\n");
        exit(1);
    }
    G-&gt;neighbors = malloc((n + 1) * sizeof(List));
    G-&gt;colors = malloc((n + 1) * sizeof(int));
    G-&gt;parents = malloc((n + 1) * sizeof(int));
</font>    G-&gt;discovers = malloc((n + 1) * sizeof(int));
    G-&gt;finishes = malloc((n + 1) * sizeof(int));
<a name="5"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match0-0.html#5" target="0"><img align="left" alt="other" border="0" src="./tm_0_4.gif"></a>

    if (G-&gt;neighbors == NULL || G-&gt;colors == NULL || G-&gt;parents == NULL || G-&gt;discovers == NULL || G-&gt;finishes == NULL) {
        fprintf(stderr, "Graph Error: unable to allocate memory for Graph parameters\n");
        free(G);
        exit(1);
    }
    G-&gt;order = n;
    G-&gt;size = 0;
    for (int i = 0; i &lt;= n; i++) {
        G-&gt;neighbors[i] = newList();
        G-&gt;colors[i] = 0;
</font>        G-&gt;parents[i] = NIL;
        G-&gt;discovers[i] = UNDEF;
        G-&gt;finishes[i] = UNDEF;
    }
    return G;
}

void freeGraph(Graph* pG) {
<a name="6"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match0-0.html#6" target="0"><img align="left" alt="other" border="0" src="./tm_1_2.gif"></a>

    if (pG != NULL &amp;&amp; *pG != NULL) {
        for (int i = 0; i &lt;= (*pG)-&gt;order; i++) {
            if ((*pG)-&gt;neighbors[i] != NULL) {
</font>                freeList(&amp;((*pG)-&gt;neighbors[i]));
            }
        }
        free((*pG)-&gt;neighbors);
        free((*pG)-&gt;colors);
        free((*pG)-&gt;parents);
        free((*pG)-&gt;discovers);
        free((*pG)-&gt;finishes);
        free(*pG);
        *pG = NULL;
    }
}

int getOrder(Graph G) {
    return G-&gt;order;
}

int getSize(Graph G) {
<a name="0"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match0-0.html#0" target="0"><img align="left" alt="other" border="0" src="./tm_0_24.gif"></a>

    return G-&gt;size;
}

int getParent(Graph G, int u) {
    if (u &lt; 1 || u &gt; getOrder(G)) {
        fprintf(stderr, "Graph Error: getParent() called with out-of-bounds u\n");
        exit(1);
    }
    return G-&gt;parents[u];
}

int getDiscover(Graph G, int u) {
    if (u &lt; 1 || u &gt; getOrder(G)) {
        fprintf(stderr, "Graph Error: getDiscover() called with out-of-bounds u\n");
        exit(1);
    }
    return G-&gt;discovers[u];
}

int getFinish(Graph G, int u) {
    if (u &lt; 1 || u &gt; getOrder(G)) {
        fprintf(stderr, "Graph Error: getFinish() called with out-of-bounds u\n");
        exit(1);
    }
    return G-&gt;finishes[u];
}

void addEdge(Graph G, int u, int v) {
    if (G == NULL) {
        fprintf(stderr, "Graph Error: calling addEdge() on NULL Graph reference\n");
        exit(1);
    }
    if (u &lt; 1 || u &gt; getOrder(G) || v &lt; 1 || v &gt; getOrder(G)) {
        fprintf(stderr, "Graph Error: parameters not within acceptable range\n");
        exit(1);
    }
    moveFront(G-&gt;neighbors[u]);
    while (index(G-&gt;neighbors[u]) != -1) {
        if (get(G-&gt;neighbors[u]) &gt; v) {
            insertBefore(G-&gt;neighbors[u], v);
            break;
        }
        moveNext(G-&gt;neighbors[u]);
    }
    if (index(G-&gt;neighbors[u]) == -1) {
        append(G-&gt;neighbors[u], v);
    }
    moveFront(G-&gt;neighbors[v]);
    while (index(G-&gt;neighbors[v]) != -1) {
        if (get(G-&gt;neighbors[v]) &gt; u) {
            insertBefore(G-&gt;neighbors[v], u);
            break;
        }
        moveNext(G-&gt;neighbors[v]);
    }
    if (index(G-&gt;neighbors[v]) == -1) {
</font>        append(G-&gt;neighbors[v], u);
    }
    G-&gt;size = G-&gt;size + 1;
}

<a name="1"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match0-0.html#1" target="0"><img align="left" alt="other" border="0" src="./tm_1_19.gif"></a>

void addArc(Graph G, int u, int v) {
    if (G == NULL) {
        fprintf(stderr, "Graph Error: calling addArc() on NULL Graph reference\n");
        exit(1);
    }
    if (u &lt; 1 || u &gt; getOrder(G) || v &lt; 1 || v &gt; getOrder(G)) {
        fprintf(stderr, "Graph Error: parameters not within acceptable range\n");
        exit(1);
    }
    moveFront(G-&gt;neighbors[u]);
    while (index(G-&gt;neighbors[u]) != -1) {
        if (get(G-&gt;neighbors[u]) == v) {
            return;
        }
        if (get(G-&gt;neighbors[u]) &gt; v) {
            insertBefore(G-&gt;neighbors[u], v);
            G-&gt;size++;
            return;
        }
        moveNext(G-&gt;neighbors[u]);
    }
    append(G-&gt;neighbors[u], v);
    G-&gt;size++;
}

void DFS(Graph G, List S) {
    if (G == NULL || S == NULL) {
        fprintf(stderr, "Graph Error: calling DFS() on NULL reference\n");
        exit(1);
    }
    if (length(S) != getOrder(G)) {
        fprintf(stderr, "List Error: length does not match order of Graph\n");
        exit(1);
    }
    int time = 0;
    void Visit(int u, int parent) {
        G-&gt;parents[u] = parent;
        G-&gt;colors[u] = 1;
        G-&gt;discovers[u] = ++time;
        moveFront(G-&gt;neighbors[u]);
        while (index(G-&gt;neighbors[u]) != -1) {
            int v = get(G-&gt;neighbors[u]);
</font>            if (G-&gt;colors[v] == 0) {
                Visit(v, u);
            }
            moveNext(G-&gt;neighbors[u]);
        }
        G-&gt;colors[u] = 2;
<a name="2"></a><font color="#0000FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match0-0.html#2" target="0"><img align="left" alt="other" border="0" src="./tm_2_12.gif"></a>

        G-&gt;finishes[u] = ++time;
        prepend(S, u);
    }
    for (int i = 1; i &lt;= getOrder(G); i++) {
        G-&gt;colors[i] = 0;
        G-&gt;parents[i] = NIL;
        G-&gt;discovers[i] = UNDEF;
        G-&gt;finishes[i] = UNDEF;
    }
    List T = copyList(S);
    clear(S);
    moveFront(T);
    while (index(T) != -1) {
        int u = get(T);
        if (G-&gt;colors[u] == 0) {
            Visit(u, NIL);
        }
        moveNext(T);
    }
    freeList(&amp;T);
}

Graph transpose(Graph G) {
    if (G == NULL) {
        fprintf(stderr, "Graph Error: calling transpose() on NULL Graph reference\n");
        exit(1);
    }
    Graph T = newGraph(getOrder(G));
    for (int u = 1; u &lt;= getOrder(G); u++) {
        moveFront(G-&gt;neighbors[u]);
</font>        while (index(G-&gt;neighbors[u]) != -1) {
            int v = get(G-&gt;neighbors[u]);
            addArc(T, v, u);  // Reverse the direction of the arc
<a name="4"></a><font color="#FF00FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa3_report/moss_results/winter25_winter25/Graph.c/part_1/report/match0-0.html#4" target="0"><img align="left" alt="other" border="0" src="./tm_4_5.gif"></a>

            moveNext(G-&gt;neighbors[u]);
        }
    }
    return T;
}

void printGraph(FILE* out, Graph G) {
    if (G == NULL) {
        fprintf(stderr, "Graph Error: calling printGraph() on NULL Graph reference\n");
        exit(1);
    }
    for (int i = 1; i &lt;= getOrder(G); i++) {
        fprintf(out, "%d: ", i);
        printList(out, G-&gt;neighbors[i]);
        fprintf(out, "\n");
</font>    }
}</pre>


</body></html>