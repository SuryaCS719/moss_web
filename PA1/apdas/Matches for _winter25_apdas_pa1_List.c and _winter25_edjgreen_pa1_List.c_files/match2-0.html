
<!-- saved from url=(0116)file:///Users/surya/Desktop/moss/cse101/pa1_report/moss_results/winter25_winter25/List.c/part_1/report/match2-0.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>/winter25/apdas/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr>
/winter25/apdas/pa1/List.c<p></p><pre>//-----------------------------------------------------------------------------
// List.c
// Implementation file for List ADT
//-----------------------------------------------------------------------------
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include "List.h"


// structs --------------------------------------------------------------------

// private Node type
typedef struct NodeObj* Node;

// private NodeObj type
typedef struct NodeObj{
   ListElement data;
   Node next;
   Node prev;
} NodeObj;

// private ListObj type
typedef struct ListObj{
   Node front;
   Node cursor;
   Node back;
   int length;
   int index;
} ListObj;


// Constructors-Destructors ---------------------------------------------------

// newNode()
// Returns reference to new Node object. Initializes next and data fields.
Node newNode(ListElement data){
   Node N = malloc(sizeof(NodeObj));
   assert( N!=NULL );
   N-&gt;data = data;
   N-&gt;next = NULL;
   N-&gt;prev = NULL;
   return(N);
}

// freeNode()
// Frees heap memory pointed to by *pN, sets *pN to NULL.
void freeNode(Node* pN){
   if( pN!=NULL &amp;&amp; *pN!=NULL ){
      free(*pN);
      *pN = NULL;
   }
}

// newList()
// Returns reference to new empty List object.
List newList(){
   List L;
   L = malloc(sizeof(ListObj));
   assert( L!=NULL );
   L-&gt;front = L-&gt;back = L-&gt;cursor = NULL;
   L-&gt;length = 0;
   L-&gt;index = -1;
   return(L);
}

// isEmpty()
// Returns true if L is empty, otherwise returns false.
bool isEmpty(List L){
   if( L==NULL ){
      fprintf(stderr, "List Error: calling isEmpty() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   return(L-&gt;length==0);
}

// freeList()
// Frees all heap memory associated with List *pL, and sets *pL to NULL.
void freeList(List* pL){
   if(pL!=NULL &amp;&amp; *pL!=NULL) { 
<a name="3"></a><font color="#00FFFF"><a href="file:///Users/surya/Desktop/moss/cse101/pa1_report/moss_results/winter25_winter25/List.c/part_1/report/match2-1.html#3" target="1"><img align="left" alt="other" border="0" src="./tm_3_6.gif"></a>

      while( !isEmpty(*pL) ) { 
         deleteBack(*pL); 
      }
      free(*pL);
      *pL = NULL;
   }
}


// Access functions -----------------------------------------------------------

// front()
// Returns the value at the front of L.
// Pre: !isEmpty(L)
int front(List L){
   if( L==NULL ){
      fprintf(stderr, "List Error: calling front() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if( isEmpty(L) ){
      fprintf(stderr, "List Error: calling front() on an empty List\n");
      exit(EXIT_FAILURE);
   }
   return(L-&gt;front-&gt;data);
}

// length()
// Returns the length of L.
int length(List L){
   if( L==NULL ){
      fprintf(stderr, "List Error: calling length() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   return(L-&gt;length);
}

int index(List L){
   if( L==NULL ){
      fprintf(stderr, "List Error: calling index() on NULL List reference\n");
      exit(EXIT_FAILURE);
   } 
   return(L-&gt;index);
}

int back(List L){
   if( L==NULL ){
      fprintf(stderr, "List Error: calling back() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if( isEmpty(L) ){
      fprintf(stderr, "List Error: calling back() on an empty List\n");
      exit(EXIT_FAILURE);
</font>   }
   return(L-&gt;back-&gt;data);

}

int get(List L){
   if( L==NULL ){
<a name="9"></a><font color="#FF00FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa1_report/moss_results/winter25_winter25/List.c/part_1/report/match2-1.html#9" target="1"><img align="left" alt="other" border="0" src="./tm_4_2.gif"></a>

      fprintf(stderr, "List Error: calling get() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if( isEmpty(L) ){
      fprintf(stderr, "List Error: calling get() on an empty List\n");
      exit(EXIT_FAILURE);
   }
   return(L-&gt;cursor-&gt;data);
}

// equals()
// Returns true if A is same int sequence as B, false otherwise.
bool equals(List A, List B){
   if( A==NULL || B==NULL ){
</font>      fprintf(stderr, "List Error: calling equals() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   bool eq;
   Node N, M;

   eq = ( A-&gt;length == B-&gt;length );
   N = A-&gt;front;
   M = B-&gt;front;
   while( eq &amp;&amp; N!=NULL){
      eq = ( N-&gt;data==M-&gt;data );
      N = N-&gt;next;
      M = M-&gt;next;
   }
   return eq;
}



// Manipulation procedures ----------------------------------------------------

// Append()
// Places new data at the back of L.
void clear(List L){
   while(!isEmpty(L)){
      deleteFront(L);
   }
   L-&gt;cursor = L-&gt;front = L-&gt;back = NULL;
   L-&gt;index = -1;
}

<a name="8"></a><font color="#00FFFF"><a href="file:///Users/surya/Desktop/moss/cse101/pa1_report/moss_results/winter25_winter25/List.c/part_1/report/match2-1.html#8" target="1"><img align="left" alt="other" border="0" src="./tm_3_2.gif"></a>

void set(List L, int x){
   if( L==NULL ){
      fprintf(stderr, "List Error: calling get() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if( isEmpty(L) ){
      fprintf(stderr, "List Error: calling get() on an empty List\n");
      exit(EXIT_FAILURE);
   }
   L-&gt;cursor-&gt;data = x;

}

void moveFront(List L){
</font>   if(!isEmpty(L)){
      L-&gt;cursor = L-&gt;front;
      L-&gt;index = 0;
   }
}

void moveBack(List L){
   if(!isEmpty(L)){
      L-&gt;cursor = L-&gt;back;
<a name="1"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa1_report/moss_results/winter25_winter25/List.c/part_1/report/match2-1.html#1" target="1"><img align="left" alt="other" border="0" src="./tm_1_9.gif"></a>

      L-&gt;index = L-&gt;length - 1;
   }
}

void movePrev(List L){
   if(!isEmpty(L) &amp;&amp; L-&gt;cursor != NULL &amp;&amp; L-&gt;cursor != L-&gt;front){
      L-&gt;cursor = L-&gt;cursor-&gt;prev;
      L-&gt;index = index(L) - 1;
   }
   else if(!isEmpty(L) &amp;&amp; L-&gt;cursor != NULL &amp;&amp; L-&gt;cursor == L-&gt;front){
      L-&gt;cursor = NULL;
      L-&gt;index = -1;
   }

}

void moveNext(List L){
   if(!isEmpty(L) &amp;&amp; L-&gt;cursor != NULL &amp;&amp; L-&gt;cursor != L-&gt;back){
      L-&gt;cursor = L-&gt;cursor-&gt;next;
      L-&gt;index = index(L) + 1;
   }
   else if(!isEmpty(L) &amp;&amp; L-&gt;cursor != NULL &amp;&amp; L-&gt;cursor == L-&gt;back){
      L-&gt;cursor = NULL;
      L-&gt;index = -1;
   }
}




void append(List L, ListElement data)
</font>{

<a name="0"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa1_report/moss_results/winter25_winter25/List.c/part_1/report/match2-1.html#0" target="1"><img align="left" alt="other" border="0" src="./tm_0_14.gif"></a>

   if( L==NULL ){
      fprintf(stderr, "List Error: calling Append() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   
   Node N = newNode(data);
   
   if( isEmpty(L) ) { 
      L-&gt;front = L-&gt;back = L-&gt;cursor = N; 
      L-&gt;front-&gt;next = L-&gt;front-&gt;prev = L-&gt;back-&gt;next = L-&gt;back-&gt;prev = L-&gt;cursor-&gt;next = L-&gt;cursor-&gt;prev = NULL;
   }else{ 
      L-&gt;back-&gt;next = N;
      N-&gt;prev = L-&gt;back;
      N-&gt;next = NULL; 
      L-&gt;back = N; 
   }
   L-&gt;length++;
}

void prepend(List L, ListElement data)
{

   if( L==NULL ){
      fprintf(stderr, "List Error: calling Append() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   Node N = newNode(data);

   if(L-&gt;index &gt;= 0){
      L-&gt;index++;
   }
   
   if( isEmpty(L) ) { 
      L-&gt;front = L-&gt;back = L-&gt;cursor = N; 
      L-&gt;front-&gt;next = L-&gt;front-&gt;prev = L-&gt;back-&gt;next = L-&gt;back-&gt;prev = L-&gt;cursor-&gt;next = L-&gt;cursor-&gt;prev = NULL;
   }else{ 
      L-&gt;front-&gt;prev = N;
      N-&gt;next = L-&gt;front;
      N-&gt;prev = NULL; 
      L-&gt;front = N; 
   }
   L-&gt;length++;
}


void insertBefore(List L, int x){
</font><a name="10"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa1_report/moss_results/winter25_winter25/List.c/part_1/report/match2-1.html#10" target="1"><img align="left" alt="other" border="0" src="./tm_0_1.gif"></a>

   

   if( L==NULL ){
      fprintf(stderr, "List Error: calling insertBefore() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if( isEmpty(L) ){
      fprintf(stderr, "List Error: calling insertBefore() on an empty List\n");
      exit(EXIT_FAILURE);
   }
   
   if(L-&gt;cursor != NULL &amp;&amp; L-&gt;index != 0){
</font>      Node N = newNode(x);
      L-&gt;cursor-&gt;prev-&gt;next = N;
<a name="11"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa1_report/moss_results/winter25_winter25/List.c/part_1/report/match2-1.html#11" target="1"><img align="left" alt="other" border="0" src="./tm_1_1.gif"></a>

      N-&gt;prev = L-&gt;cursor-&gt;prev;
      L-&gt;cursor-&gt;prev = N;
      N-&gt;next = L-&gt;cursor;
      L-&gt;length = L-&gt;length + 1;
</font>      L-&gt;index = L-&gt;index + 1;
   }
<a name="6"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa1_report/moss_results/winter25_winter25/List.c/part_1/report/match2-1.html#6" target="1"><img align="left" alt="other" border="0" src="./tm_1_4.gif"></a>

   else{
      prepend(L, x);
      /*N-&gt;prev = L-&gt;cursor-&gt;prev;
      L-&gt;cursor-&gt;prev = N;
      N-&gt;next = L-&gt;cursor;
      L-&gt;length = L-&gt;length + 1;
      L-&gt;index = L-&gt;index + 1;
      */
   }
}  

void insertAfter(List L, int x){

   if( L==NULL ){
      fprintf(stderr, "List Error: calling insertAfter() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if(isEmpty(L) ){
      fprintf(stderr, "List Error: calling insertAFter() on an empty List\n");
      exit(EXIT_FAILURE);
   }


   if(L-&gt;cursor == L-&gt;back){
      append(L, x);
   }
   else if(L-&gt;cursor != NULL){
      Node N = newNode(x);
      L-&gt;cursor-&gt;next-&gt;prev = N;
      N-&gt;next = L-&gt;cursor-&gt;next;
</font>      L-&gt;cursor-&gt;next = N;
      N-&gt;prev = L-&gt;cursor;
      L-&gt;length = L-&gt;length + 1;
   }
   
}  


// Deletes data at front of L.
// Pre: !isEmpty(Q)
<a name="2"></a><font color="#0000FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa1_report/moss_results/winter25_winter25/List.c/part_1/report/match2-1.html#2" target="1"><img align="left" alt="other" border="0" src="./tm_2_8.gif"></a>

void deleteFront(List L){

   if( L==NULL ){
      fprintf(stderr, "List Error: calling DeleteFront() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if( isEmpty(L) ){
      fprintf(stderr, "List Error: calling DeleteFront() on an empty List\n");
      exit(EXIT_FAILURE);
   }

   Node N = NULL;
   N = L-&gt;front;

   if( length(L)&gt;1 ) { 
      L-&gt;front = L-&gt;front-&gt;next; 
      L-&gt;front-&gt;prev = NULL;
   }else{ 
      L-&gt;front = L-&gt;back = L-&gt;cursor = NULL;
   }
   if (L-&gt;cursor == N){
      L-&gt;index = -1;
      L-&gt;cursor = NULL;
   }
   else{
      L-&gt;index--;
   }
   L-&gt;length--;
   freeNode(&amp;N);
}

void deleteBack(List L){
   if( L==NULL ){
      fprintf(stderr, "List Error: calling DeleteBack() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if( isEmpty(L) ){
      fprintf(stderr, "List Error: calling DeleteBack() on an empty List\n");
      exit(EXIT_FAILURE);
   }

   Node N = NULL;
</font>   if (L-&gt;cursor == L-&gt;back){
      L-&gt;cursor = NULL;
      L-&gt;index = -1;
   }
   N = L-&gt;back;
   if( length(L)&gt;1 ) { 
      L-&gt;back = L-&gt;back-&gt;prev;
<a name="7"></a><font color="#0000FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa1_report/moss_results/winter25_winter25/List.c/part_1/report/match2-1.html#7" target="1"><img align="left" alt="other" border="0" src="./tm_2_3.gif"></a>

      L-&gt;back-&gt;next = NULL; 
   }else{ 
      L-&gt;front = L-&gt;back = NULL; 
   }
   L-&gt;length--;
   freeNode(&amp;N);
}

void delete(List L){
   if( L==NULL ){
      fprintf(stderr, "List Error: calling Delete() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if( isEmpty(L) ){
      fprintf(stderr, "List Error: calling Delete() on an empty List\n");
      exit(EXIT_FAILURE);
   }
   if(L-&gt;index &lt; 0){
      fprintf(stderr, "List Error: calling Delete() on an invalid index\n");
      exit(EXIT_FAILURE);
   }

   if(L-&gt;length == 1){
</font><a name="12"></a><font color="#0000FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa1_report/moss_results/winter25_winter25/List.c/part_1/report/match2-1.html#12" target="1"><img align="left" alt="other" border="0" src="./tm_2_1.gif"></a>

      Node N = NULL;
      N = L-&gt;cursor;
      L-&gt;front = L-&gt;back = L-&gt;cursor = NULL;
      L-&gt;length--;
</font><a name="5"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa1_report/moss_results/winter25_winter25/List.c/part_1/report/match2-1.html#5" target="1"><img align="left" alt="other" border="0" src="./tm_0_5.gif"></a>

      freeNode(&amp;N);
      L-&gt;cursor = NULL;
   }
   else if (L-&gt;cursor == L-&gt;front){
      deleteFront(L);
   }
   else if (L-&gt;cursor == L-&gt;back){
      deleteBack(L);
   }
   else{
      Node N = NULL;
      N = L-&gt;cursor;
      L-&gt;cursor-&gt;next-&gt;prev = L-&gt;cursor-&gt;prev;
      L-&gt;cursor-&gt;prev-&gt;next = L-&gt;cursor-&gt;next;
      L-&gt;length--;
      freeNode(&amp;N);
      L-&gt;cursor = NULL;
</font>      
   }
   
}


// Other Functions ------------------------------------------------------------

// printList()
// Prints a string representation of L consisting of a space separated list 
// of ints to stdout.
<a name="4"></a><font color="#FF00FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa1_report/moss_results/winter25_winter25/List.c/part_1/report/match2-1.html#4" target="1"><img align="left" alt="other" border="0" src="./tm_4_6.gif"></a>

void printList(FILE* out, List L){
  
  if( L==NULL ){
      fprintf(stderr, "List Error: calling printList() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
  
   moveFront(L);
   
   int x = 0;
   while(index(L) &gt;= 0){
      //printf("index: %d\n", L-&gt;index);
      x = get(L);
      fprintf(out, "%d", x);
      if(index(L) &lt; length(L) - 1){
         fprintf(out, " ");
      }
      moveNext(L);
   }
}

List copyList(List L){
   if( L==NULL ){
      fprintf(stderr, "List Error: calling CopyList() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   
   int startingCursor = index(L);

   List Q = newList();
   moveFront(L);

  while(L-&gt;cursor != NULL){
   append(Q, L-&gt;cursor-&gt;data);
   moveNext(L);
</font>  }
  
  Q-&gt;cursor = NULL;
  moveFront(L);

  for(int i = 0; i &lt; startingCursor; i++){
   moveNext(L);
  }

  return Q;

}
</pre>


</body></html>