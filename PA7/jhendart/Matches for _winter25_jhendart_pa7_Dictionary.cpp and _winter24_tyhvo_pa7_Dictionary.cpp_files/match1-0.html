
<!-- saved from url=(0063)http://moss.stanford.edu/results/9/265210756074/match1-0.html#0 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/jhendart/pa7/Dictionary.cpp</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter25/jhendart/pa7/Dictionary.cpp<p></p><pre>/*
Programming assignment 7

Joshua Hendarto
jhendart@ucsc.edu
Dictionary.cpp
    Implements the Binary Search Tree ADT and defines the functions used.it implements 
    the binary search trees and includes functions for insertion, deletion, retrieval, and iteration 
    over the pairs.
*/


#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;
#include "Dictionary.h"

// Private Constructor --------------------------------------------------------

Dictionary::Node::Node(keyType k, valType v)
{
    key = k;
    val = v;
    parent = nullptr;
    left = nullptr;
    right = nullptr;
}

// Helper Functions (Optional) ---------------------------------------------
void Dictionary::inOrderString(std::string &amp;s, Node *R) const
{
    if (R != nullptr)
    {
        inOrderString(s, R-&gt;left);
        s += R-&gt;key + " : " + std::to_string(R-&gt;val) + "\n";
        inOrderString(s, R-&gt;right);
    }
}

void Dictionary::preOrderString(std::string &amp;s, Node *R) const
{
    if (R != nullptr)
    {
        s += R-&gt;key + "\n";
<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/9/265210756074/match1-1.html#2" target="1"><img src="./tm_2_5.gif" alt="other" border="0" align="left"></a>

        preOrderString(s, R-&gt;left);
        preOrderString(s, R-&gt;right);
    }
}

void Dictionary::preOrderCopy(Node *R, Node *N)
{
    if (R != nullptr)
    {
        this-&gt;setValue(R-&gt;key, R-&gt;val);
        preOrderCopy(R, N-&gt;left);
        preOrderCopy(R, N-&gt;right);
    }
}

void Dictionary::postOrderDelete(Node *R)
{
    if (R != nullptr)
    {
        postOrderDelete(R-&gt;left);
        postOrderDelete(R-&gt;right);
</font>        delete R;
    }
}

Dictionary::Node *Dictionary::search(Node *R, keyType k) const
{
    if (R == nullptr || R-&gt;key == k)
    {
        return R;
    }
    if (k &lt; R-&gt;key)
    {
        return search(R-&gt;left, k);
    }
    return search(R-&gt;right, k);
}

Dictionary::Node *Dictionary::findMin(Node *R)
{
    if (R == nullptr)
    {
        return nullptr;
    }
    while (R-&gt;left != nil)
    {
        R = R-&gt;left;
    }
    return R;
}

Dictionary::Node *Dictionary::findMax(Node *R)
{
    if (R == nullptr)
    {
        return nullptr;
    }
    while (R-&gt;right != nil)
    {
        R = R-&gt;right;
    }
    return R;
}

Dictionary::Node *Dictionary::findNext(Node *R)
{
    if (R-&gt;right != nullptr)
    {
        return findMin(R-&gt;right);
    }
    Node *y = R-&gt;parent;
    while (y != nullptr &amp;&amp; R == y-&gt;right)
    {
        R = y;
        y = y-&gt;parent;
    }
    return y;
}

Dictionary::Node *Dictionary::findPrev(Node *R)
{
    if (R-&gt;left != nullptr)
    {
        return findMax(R-&gt;left);
    }
    Node *y = R-&gt;parent;
    while (y != nullptr &amp;&amp; R == y-&gt;left)
    {
        R = y;
        y = y-&gt;parent;
    }
    return y;
}

void Dictionary::Transplant(Node *u, Node *v)
{
    if (u-&gt;parent == nullptr)
    {
        root = v;
    }
    else if (u == u-&gt;parent-&gt;left)
    {
        u-&gt;parent-&gt;left = v;
    }
    else
    {
<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/9/265210756074/match1-1.html#3" target="1"><img src="./tm_3_5.gif" alt="other" border="0" align="left"></a>

        u-&gt;parent-&gt;right = v;
    }
    if (v != nullptr)
    {
        v-&gt;parent = u-&gt;parent;
    }
}

void Dictionary::insert(Node *z)
{
    if (z == nullptr)
    {
        std::cerr &lt;&lt; "Dictionary Error: cannot insert() nil node\n";
        exit(EXIT_FAILURE);
    }

    Node *y = nullptr;
    Node *x = root;
    while (x != nullptr)
    {
        y = x;
        if (z-&gt;key &lt; x-&gt;key)
</font>        {
            x = x-&gt;left;
        }
        else
        {
            x = x-&gt;right;
        }
    }
    z-&gt;parent = y;
    if (y == nullptr)
    {
        root = z;
    }
<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/9/265210756074/match1-1.html#4" target="1"><img src="./tm_4_4.gif" alt="other" border="0" align="left"></a>

    else if (z-&gt;key &lt; y-&gt;key)
    {
        y-&gt;left = z;
    }
    else
    {
        y-&gt;right = z;
    }
    num_pairs++;
}

void Dictionary::deleteNode(Node *z)
{
    if (z-&gt;right == nullptr)
    {
        Transplant(z, z-&gt;left);
    }
    else if (z-&gt;left == nullptr)
    {
        Transplant(z, z-&gt;right);
</font>    }
    else
    {
        Node *y = findMin(z-&gt;right);
        if (y-&gt;parent != z)
        {
            Transplant(y, y-&gt;right);
            y-&gt;right = z-&gt;right;
<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/9/265210756074/match1-1.html#1" target="1"><img src="./tm_1_8.gif" alt="other" border="0" align="left"></a>

            y-&gt;right-&gt;parent = y;
        }
        Transplant(z, y);
        y-&gt;left = z-&gt;left;
        y-&gt;left-&gt;parent = y;
    }
    delete z;
}

// Class Constructors &amp; Destructors ----------------------------------------

Dictionary::Dictionary()
{
    nil = nullptr;
    root = nullptr;
    current = nullptr;
    num_pairs = 0;
}

Dictionary::Dictionary(const Dictionary &amp;D)
{
    root = nullptr;
    preOrderCopy(root, D.root);
    num_pairs = D.num_pairs;
    current = D.current;
    nil = D.nil;
}

Dictionary::~Dictionary()
{
    clear();
    delete nil;
}

// Access functions --------------------------------------------------------

int Dictionary::size() const
{
    return num_pairs;
}

bool Dictionary::contains(keyType k) const
</font>{
    return search(root, k) != nullptr;
}

valType &amp;Dictionary::getValue(keyType k) const
{
    Node *node = search(root, k);
    if (node == nullptr)
        throw std::invalid_argument("Key not found");
    else
        return node-&gt;val;
}

<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/9/265210756074/match1-1.html#0" target="1"><img src="./tm_0_33.gif" alt="other" border="0" align="left"></a>

bool Dictionary::hasCurrent() const
{
    return current != nullptr;
}

keyType Dictionary::currentKey() const
{
    if (hasCurrent())
        return current-&gt;key;
    else
        throw std::invalid_argument("Current key not found");
}

valType &amp;Dictionary::currentVal() const
{
    if (hasCurrent())
        return current-&gt;val;
    else
        throw std::invalid_argument("Current value not found");
}

// Manipulation procedures -------------------------------------------------

void Dictionary::clear()
{
    postOrderDelete(root);
    num_pairs = 0;
    root = nullptr;
    current = nullptr;
}

void Dictionary::setValue(keyType k, valType v)
{
    Node *x = root;
    while (x != nil)
    {
        if (k &lt; x-&gt;key)
        {
            x = x-&gt;left;
        }
        else if (k &gt; x-&gt;key)
        {
            x = x-&gt;right;
        }
        else
        {
            x-&gt;val = v;
            return;
        }
    }
    Node *N = new Node(k, v);
    insert(N);
}

void Dictionary::remove(keyType k)
{
    Node *N = search(root, k);
    if (current == N)
    {
        current = nullptr;
    }
    if (N != nullptr)
    {
        num_pairs--;
        deleteNode(N);
    }
    else
    {
        throw std::invalid_argument("Current key not found");
    }
}

void Dictionary::begin()
{
    current = findMin(root);
}

void Dictionary::end()
{
    current = findMax(root);
}

void Dictionary::next()
{
    if (hasCurrent())
        current = findNext(current);
    else
        throw std::invalid_argument("Current key not found");
}

void Dictionary::prev()
{
    if (hasCurrent())
        current = findPrev(current);
    else
        throw std::invalid_argument("Current key not found");
}

// Other Functions ---------------------------------------------------------

std::string Dictionary::to_string() const
{
    std::string s = "";
    inOrderString(s, root);
    return s;
}

std::string Dictionary::pre_string() const
{
    std::string s = "";
    preOrderString(s, root);
    return s;
}

bool Dictionary::equals(const Dictionary &amp;D) const
{
    return to_string() == D.Dictionary::to_string();
}

// Overloaded Operators ----------------------------------------------------

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;stream, Dictionary &amp;D)
{
    return stream &lt;&lt; D.Dictionary::to_string();
}

bool operator==(const Dictionary &amp;A, const Dictionary &amp;B)
{
    return A.equals(B);
}

Dictionary &amp;Dictionary::operator=(const Dictionary &amp;D)
{
    if (this != &amp;D)
    {
        Dictionary temp;
        temp.root = nullptr;
        temp.preOrderCopy(temp.root, D.root);
        temp.num_pairs = D.num_pairs;
        temp.current = D.current;
        temp.nil = D.nil;
        std::swap(root, temp.root);
        std::swap(num_pairs, temp.num_pairs);
        std::swap(current, temp.current);
</font>        std::swap(nil, temp.nil);
    }
    return *this;
}
</pre>



</body></html>