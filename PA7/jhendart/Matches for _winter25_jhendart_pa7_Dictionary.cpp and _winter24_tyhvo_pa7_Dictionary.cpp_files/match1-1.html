
<!-- saved from url=(0061)http://moss.stanford.edu/results/9/265210756074/match1-1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/jhendart/pa7/Dictionary.cpp</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter24/tyhvo/pa7/Dictionary.cpp<p></p><pre>/*
Programming Assignment 7 (pa7)
Tyler Vo
tyhvo@ucsc.edu

Dictionary.cpp implements all the functions declared in the header file Dictionary.h. This C++ code 
provides an implementation of a dictionary data structure using a binary search tree. The Dictionary 
class allows for key-value pairs to be stored, retrieved, and manipulated efficiently. It includes 
functions for insertion, deletion, retrieval, and iteration over the pairs. The implementation employs 
helper functions for tree traversal and manipulation, ensuring correct behavior.
*/

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;
#include "Dictionary.h"


// Private Constructor --------------------------------------------------------

// Node constructor
Dictionary::Node::Node(keyType k, valType v){
    key = k;
    val = v;
    parent = nullptr;
    left = nullptr;
    right = nullptr;
}


// Helper Functions (Optional) ---------------------------------------------

// inOrderString()
// Appends a string representation of the tree rooted at R to string s. The
// string appended consists of: "key : value \n" for each key-value pair in
// tree R, arranged in order by keys.
void Dictionary::inOrderString(std::string&amp; s, Node* R) const {
    if (R != nullptr) {
        inOrderString(s, R-&gt;left);
        s += R-&gt;key + " : " + std::to_string(R-&gt;val) + "\n";
        inOrderString(s, R-&gt;right);
    }
}

// preOrderString()
// Appends a string representation of the tree rooted at R to s. The appended
// string consists of keys only, separated by "\n", with the order determined
// by a pre-order tree walk.
void Dictionary::preOrderString(std::string&amp; s, Node* R) const {
    if (R != nullptr) {
        s += R-&gt;key + "\n";
<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/9/265210756074/match1-0.html#2" target="0"><img src="./tm_2_5.gif" alt="other" border="0" align="left"></a>

        preOrderString(s, R-&gt;left);
        preOrderString(s, R-&gt;right);
    }
}

// preOrderCopy()
// Recursively inserts a deep copy of the subtree rooted at R into this 
// Dictionary. Recursion terminates at N.
void Dictionary::preOrderCopy(Node* R, Node* N) {
    if (R != nullptr) {
        this-&gt;setValue(R-&gt;key, R-&gt;val);
        preOrderCopy(R, N-&gt;left);
        preOrderCopy(R, N-&gt;right);
    }
}

// postOrderDelete()
// Deletes all Nodes in the subtree rooted at R.
void Dictionary::postOrderDelete(Node* R) {
    if (R != nullptr) {
        postOrderDelete(R-&gt;left);
        postOrderDelete(R-&gt;right);
</font>        delete R;
    }
}

// search()
// Searches the subtree rooted at R for a Node with key==k. Returns
// the address of the Node if it exists, returns nil otherwise.
Dictionary::Node* Dictionary::search(Node* R, keyType k) const {
    if (R == nullptr || R-&gt;key == k) {
        return R;
    }
    if (k &lt; R-&gt;key) {
        return search(R-&gt;left, k);
    }
    return search(R-&gt;right, k);
}

// findMin()
// If the subtree rooted at R is not empty, returns a pointer to the 
// leftmost Node in that subtree, otherwise returns nil.
Dictionary::Node* Dictionary::findMin(Node* R) {
    if (R == nullptr) {
        return nullptr;
    }
    while (R-&gt;left != nil) {
        R = R-&gt;left;
    }
    return R;
}

// findMax()
// If the subtree rooted at R is not empty, returns a pointer to the 
// rightmost Node in that subtree, otherwise returns nil.
Dictionary::Node* Dictionary::findMax(Node* R) {
    if (R == nullptr) {
        return nullptr;
    }
    while (R-&gt;right != nil) {
        R = R-&gt;right;
    }
    return R;
}

// findNext()
// If N does not point to the rightmost Node, returns a pointer to the
// Node after N in an in-order tree walk.  If N points to the rightmost 
// Node, or is nil, returns nil. 
Dictionary::Node* Dictionary::findNext(Node* R) {
    if (R-&gt;right != nullptr) {
        return findMin(R-&gt;right);
    }
    Node* y = R-&gt;parent;
    while (y != nullptr &amp;&amp; R == y-&gt;right) {
        R = y;
        y = y-&gt;parent;
    }
    return y;
}

// findPrev()
// If N does not point to the leftmost Node, returns a pointer to the
// Node before N in an in-order tree walk.  If N points to the leftmost 
// Node, or is nil, returns nil.
Dictionary::Node* Dictionary::findPrev(Node* R) {
    if (R-&gt;left != nullptr) {
        return findMax(R-&gt;left);
    }
    Node* y = R-&gt;parent;
    while (y != nullptr &amp;&amp; R == y-&gt;left) {
        R = y;
        y = y-&gt;parent;
    }
    return y;
}

// Transplant()
// Replaces the subtree rooted at Node U with the subtree rooted at Node V.
void Dictionary::Transplant(Node* u, Node* v) {
    if (u-&gt;parent == nullptr) {
        root = v;
    } else if (u == u-&gt;parent-&gt;left) {
        u-&gt;parent-&gt;left = v;
    } else {
<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/9/265210756074/match1-0.html#3" target="0"><img src="./tm_3_5.gif" alt="other" border="0" align="left"></a>

        u-&gt;parent-&gt;right = v;
    }
    if (v != nullptr) {
        v-&gt;parent = u-&gt;parent; // Update parent pointer of v
    }
}

// insert()
// Inserts a new Node with key==k and val==v into the subtree rooted at R.
void Dictionary::insert(Node* z) {
    if (z == nullptr) {
        // Handle the case when z is null
        std::cerr &lt;&lt; "Dictionary Error: cannot insert() nil node\n";
        exit(EXIT_FAILURE);
    }

    Node* y = nullptr;
    Node* x = root;
    while (x != nullptr) {
        y = x;
        if (z-&gt;key &lt; x-&gt;key) {
</font>            x = x-&gt;left;
        } else {
            x = x-&gt;right;
        }
    }
    z-&gt;parent = y;
    if (y == nullptr) {
        root = z; // tree T was empty
<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/9/265210756074/match1-0.html#4" target="0"><img src="./tm_4_4.gif" alt="other" border="0" align="left"></a>

    } else if (z-&gt;key &lt; y-&gt;key) {
        y-&gt;left = z;
    } else {
        y-&gt;right = z;
    }
    num_pairs++;
}

// delete()
// Deletes Node Z from the subtree rooted at R.
void Dictionary::deleteNode(Node* z) {
    if (z-&gt;left == nullptr) {
        Transplant(z, z-&gt;right);
    } else if (z-&gt;right == nullptr) {
        Transplant(z, z-&gt;left);
</font>    } else {
        Node* y = findMin(z-&gt;right);
        if (y-&gt;parent != z) {
            Transplant(y, y-&gt;right);
            y-&gt;right = z-&gt;right;
<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/9/265210756074/match1-0.html#1" target="0"><img src="./tm_1_8.gif" alt="other" border="0" align="left"></a>

            y-&gt;right-&gt;parent = y;
        }
        Transplant(z, y);
        y-&gt;left = z-&gt;left;
        y-&gt;left-&gt;parent = y;
    }
    delete z;
}

// Class Constructors &amp; Destructors ----------------------------------------

// Dictionary()
Dictionary::Dictionary() {
    nil = nullptr;
    root = nullptr;
    current = nullptr;
    num_pairs = 0;
}

// Copy constructor
Dictionary::Dictionary(const Dictionary&amp; D) {
    root = nullptr;
    preOrderCopy(root, D.root);
    num_pairs = D.num_pairs;
    current = D.current;
    nil = D.nil;
}

// Destructor
Dictionary::~Dictionary() {
    clear();
    delete nil;
}


// Access functions --------------------------------------------------------

// size()
// Returns the size of this Dictionary.
int Dictionary::size() const {
    return num_pairs;
}

// contains()
// Returns true if there exists a pair such that key==k, and returns false
// otherwise.
bool Dictionary::contains(keyType k) const {
</font>    return search(root, k) != nullptr;
}

// getValue()
// Returns a reference to the value corresponding to key k.
// Pre: contains(k)
valType&amp; Dictionary::getValue(keyType k) const {
    Node* node = search(root, k);
    if (node != nullptr)
        return node-&gt;val;
    else
        throw std::invalid_argument("Key not found");
}

// hasCurrent()
// Returns true if the current iterator is defined, and returns false 
// otherwise.
<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/9/265210756074/match1-0.html#0" target="0"><img src="./tm_0_33.gif" alt="other" border="0" align="left"></a>

bool Dictionary::hasCurrent() const {
    return current != nullptr;
}

// currentKey()
// Returns the current key.
// Pre: hasCurrent()
keyType Dictionary::currentKey() const {
    if (hasCurrent())
        return current-&gt;key;
    else
        throw std::invalid_argument("Current key not found");
}

// currentVal()
// Returns a reference to the current value.
// Pre: hasCurrent()
valType&amp; Dictionary::currentVal() const {
    if (hasCurrent())
        return current-&gt;val;
    else
        throw std::invalid_argument("Current value not found");
}


// Manipulation procedures -------------------------------------------------

// clear()
// Resets this Dictionary to the empty state, containing no pairs.
void Dictionary::clear() {
    postOrderDelete(root);
    num_pairs = 0;
    root = nullptr;
    current = nullptr;
}

// setValue()
// If a pair with key==k exists, overwrites the corresponding value with v,
// otherwise inserts the new pair (k, v).
void Dictionary::setValue(keyType k, valType v) {
    Node *x = root;
    while (x != nil) {
        if (k &lt; x-&gt;key) {
            x = x-&gt;left;
        } else if (k &gt; x-&gt;key) {
            x = x-&gt;right;
        } else {
            x-&gt;val = v;
            return;
        }
    }
    // Key was not in Dictionary
    Node *N = new Node(k, v);
    insert(N);
}

// remove()
// Deletes the pair for which key==k. If that pair is current, then current
// becomes undefined.
// Pre: contains(k).
void Dictionary::remove(keyType k) {
    Node *N = search(root, k);
    if (current == N) {
        current = nullptr;
    }
    if (N != nullptr) {
        num_pairs--;
        deleteNode(N);
    } else {
        throw std::invalid_argument("Current key not found");
    }
}

// begin()
// If non-empty, places current iterator at the first (key, value) pair
// (as defined by the order operator &lt; on keys), otherwise does nothing.
void Dictionary::begin() {
    current = findMin(root);
}

// end()
// If non-empty, places current iterator at the last (key, value) pair
// (as defined by the order operator &lt; on keys), otherwise does nothing.
void Dictionary::end() {
    current = findMax(root);
}

// next()
// If the current iterator is not at the last pair, advances current
// to the next pair (as defined by the order operator &lt; on keys). If
// the current iterator is at the last pair, makes current undefined.
// Pre: hasCurrent()
void Dictionary::next() {
    if (hasCurrent())
        current = findNext(current);
    else
        throw std::invalid_argument("Current key not found");
}

// prev()
// If the current iterator is not at the first pair, advances current
// to the previous pair (as defined by the order operator &lt; on keys). If
// the current iterator is at the first pair, makes current undefined.
// Pre: hasCurrent()
void Dictionary::prev() {
    if (hasCurrent())
        current = findPrev(current);
    else
        throw std::invalid_argument("Current key not found");
}


// Other Functions ---------------------------------------------------------

// to_string()
// Returns a string representation of this Dictionary. Consecutive (key, value)
// pairs are separated by a newline "\n" character, and the items key and value 
// are separated by the sequence space-colon-space " : ". The pairs are arranged 
// in order, as defined by the order operator &lt;.
std::string Dictionary::to_string() const {
    std::string s = "";
    inOrderString(s, root);
    return s;
}

// pre_string()
// Returns a string consisting of all keys in this Dictionary. Consecutive
// keys are separated by newline "\n" characters. The key order is given
// by a pre-order tree walk.
std::string Dictionary::pre_string() const {
    std::string s = "";
    preOrderString(s, root);
    return s;
}

// equals()
// Returns true if and only if this Dictionary contains the same (key, value)
// pairs as Dictionary D.
bool Dictionary::equals(const Dictionary&amp; D) const {
    return to_string() == D.Dictionary::to_string();
}


// Overloaded Operators ----------------------------------------------------

// operator&lt;&lt;()
// Inserts string representation of Dictionary D into stream, as defined by
// member function to_string().
std::ostream&amp; operator&lt;&lt;( std::ostream&amp; stream, Dictionary&amp; D ) {
    return stream &lt;&lt; D.Dictionary::to_string();
}

// operator==()
// Returns true if and only if Dictionary A equals Dictionary B, as defined
// by member function equals().
bool operator==( const Dictionary&amp; A, const Dictionary&amp; B ) {
    return A.equals(B);
}

// operator=()
// Overloads the assignment operator.
Dictionary&amp; Dictionary::operator=(const Dictionary&amp; D) {
    if (this != &amp;D) {
        // Create a temporary Dictionary object and perform a deep copy
        Dictionary temp;
        temp.root = nullptr;
        temp.preOrderCopy(temp.root, D.root);
        temp.num_pairs = D.num_pairs;
        temp.current = D.current;
        temp.nil = D.nil;

        // Swap the contents of the temporary Dictionary with the current one
        std::swap(root, temp.root);
        std::swap(num_pairs, temp.num_pairs);
        std::swap(current, temp.current);
</font>        std::swap(nil, temp.nil);
    }
    return *this;
}

</pre>



</body></html>