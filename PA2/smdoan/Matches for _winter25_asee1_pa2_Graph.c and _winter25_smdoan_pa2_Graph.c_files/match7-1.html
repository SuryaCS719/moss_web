
<!-- saved from url=(0117)file:///Users/surya/Desktop/moss/cse101/pa2_report/moss_results/winter25_winter25/Graph.c/part_1/report/match7-1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>/winter25/asee1/pa2/Graph.c</title>
</head>
<body bgcolor="white">
<hr>
/winter25/smdoan/pa2/Graph.c<p></p><pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include "Graph.h"

// private struct, not exported 
<a name="7"></a><font color="#0000FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa2_report/moss_results/winter25_winter25/Graph.c/part_1/report/match7-0.html#7" target="0"><img align="left" alt="other" border="0" src="./tm_2_2.gif"></a>

typedef struct GraphObj {
    List* adjLists;      // Array of adjacency lists for each vertex
    List vertexColor;     // Color array for vertices (WHITE, GRAY, BLACK)
    List vertexParent;    // Parent array for each vertex
    List vertexDist;      // Distance array from the source vertex
    int numVertices;      // Total number of vertices in the graph
    int numEdges;         // Total number of edges in the graph
    int lastSource;       // Last source vertex used in BFS
} GraphObj;

// Constructors-Destructors
Graph newGraph(int n) {
    Graph g = (Graph)malloc(sizeof(GraphObj));
</font><a name="0"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa2_report/moss_results/winter25_winter25/Graph.c/part_1/report/match7-0.html#0" target="0"><img align="left" alt="other" border="0" src="./tm_0_30.gif"></a>

    g-&gt;adjLists = (List*)calloc(n + 1, sizeof(List));  // Create adjacency lists for each vertex
    for (int i = 1; i &lt;= n; i++) {
        g-&gt;adjLists[i] = newList();
    }
    g-&gt;vertexColor = newList();
    g-&gt;vertexParent = newList();
    g-&gt;vertexDist = newList();
    for (int i = 1; i &lt;= n; i++) {
        append(g-&gt;vertexColor, WHITE);
        append(g-&gt;vertexDist, INF);
        append(g-&gt;vertexParent, NIL);
    }
    g-&gt;numVertices = n;
    g-&gt;numEdges = 0;
    g-&gt;lastSource = NIL;
    return g;
}

void freeGraph(Graph* pG) {
    if (pG != NULL &amp;&amp; *pG != NULL) {
        for (int i = 1; i &lt;= (*pG)-&gt;numVertices; i++) {
            freeList(&amp;((*pG)-&gt;adjLists[i]));
        }
        freeList(&amp;((*pG)-&gt;vertexColor));
        freeList(&amp;((*pG)-&gt;vertexParent));
        freeList(&amp;((*pG)-&gt;vertexDist));
        free((*pG)-&gt;adjLists);
        free(*pG);
        *pG = NULL;
    }
}

// Access functions
int getOrder(Graph G) {
    return G-&gt;numVertices;
}

int getSize(Graph G) {
    return G-&gt;numEdges;
}

int getSource(Graph G) {
    return G-&gt;lastSource;
}

int getParent(Graph G, int u) {
    if (G-&gt;lastSource == NIL) {
        return NIL;
    }
    List parentList = G-&gt;vertexParent;
    moveFront(parentList);
    while (index(parentList) != u) {
        moveNext(parentList);
    }
    return get(parentList);
}

int getDist(Graph G, int u) {
    if (G-&gt;lastSource == NIL) {
        return INF;
    }
    List distList = G-&gt;vertexDist;
    moveFront(distList);
    while (index(distList) != u) {
        moveNext(distList);
    }
    return get(distList);
}

void getPath(List L, Graph G, int u) {
    if (u == getSource(G)) {
        append(L, u);
        return;
    }
    List path = newList();
    append(path, u);
    int parent = getParent(G, u);
    append(path, parent);
    while (parent != getSource(G) &amp;&amp; parent != NIL) {
        parent = getParent(G, parent);
        append(path, parent);
    }
    if (parent == NIL &amp;&amp; u != getSource(G)) {
</font><a name="2"></a><font color="#0000FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa2_report/moss_results/winter25_winter25/Graph.c/part_1/report/match7-0.html#2" target="0"><img align="left" alt="other" border="0" src="./tm_2_9.gif"></a>

        append(L, NIL);
    } else {
        moveBack(path);
        while (index(path) &gt;= 0) {
            append(L, get(path));
            movePrev(path);
        }
    }
    freeList(&amp;path);
}

// Manipulation procedures
void makeNull(Graph G) {
    clear(G-&gt;vertexColor);
    clear(G-&gt;vertexParent);
    clear(G-&gt;vertexDist);
    for (int i = 1; i &lt;= G-&gt;numVertices; i++) {
        clear(G-&gt;adjLists[i]);
    }
    G-&gt;numVertices = 0;
    G-&gt;lastSource = NIL;
}

void addEdge(Graph G, int u, int v) {
    if (u == v) return;  // Prevent self-loops
    append(G-&gt;adjLists[u], v);
    append(G-&gt;adjLists[v], u);  // Undirected graph, so add both ways
    G-&gt;numEdges++;
</font>}

void addArc(Graph G, int u, int v) {
    if (u == v) return;  // Prevent self-loops
    append(G-&gt;adjLists[u], v);  // Directed graph, add only one way
    G-&gt;numEdges++;
}

// BFS implementation
<a name="1"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa2_report/moss_results/winter25_winter25/Graph.c/part_1/report/match7-0.html#1" target="0"><img align="left" alt="other" border="0" src="./tm_1_13.gif"></a>

void BFS(Graph G, int s) {
    maintainGraph(G);  // Ensure adjacency lists are sorted
    G-&gt;lastSource = s;
    moveFront(G-&gt;vertexColor);
    moveFront(G-&gt;vertexDist);
    moveFront(G-&gt;vertexParent);
    for (int i = 1; i &lt;= G-&gt;numVertices; i++) {
        set(G-&gt;vertexColor, WHITE);
        set(G-&gt;vertexDist, INF);
        set(G-&gt;vertexParent, NIL);
        moveNext(G-&gt;vertexColor);
        moveNext(G-&gt;vertexDist);
        moveNext(G-&gt;vertexParent);
    }
    moveFront(G-&gt;vertexColor);
    moveFront(G-&gt;vertexDist);
    moveFront(G-&gt;vertexParent);
    while (index(G-&gt;vertexColor) != s) {
        moveNext(G-&gt;vertexColor);
        moveNext(G-&gt;vertexDist);
        moveNext(G-&gt;vertexParent);
    }
    set(G-&gt;vertexColor, GRAY);
    set(G-&gt;vertexDist, 0);
    set(G-&gt;vertexParent, NIL);
    List queue = newList();
    append(queue, s);
    while (length(queue) &gt; 0) {
        int x = front(queue);
        deleteFront(queue);
        moveFront(G-&gt;adjLists[x]);
</font>        while (index(G-&gt;adjLists[x]) &gt;= 0) {
            int y = get(G-&gt;adjLists[x]);
            int distX = getDist(G, x);
<a name="3"></a><font color="#00FFFF"><a href="file:///Users/surya/Desktop/moss/cse101/pa2_report/moss_results/winter25_winter25/Graph.c/part_1/report/match7-0.html#3" target="0"><img align="left" alt="other" border="0" src="./tm_3_9.gif"></a>

            moveFront(G-&gt;vertexColor);
            moveFront(G-&gt;vertexDist);
            moveFront(G-&gt;vertexParent);
            while (index(G-&gt;vertexColor) != y) {
                moveNext(G-&gt;vertexColor);
                moveNext(G-&gt;vertexDist);
                moveNext(G-&gt;vertexParent);
            }
            if (get(G-&gt;vertexColor) == WHITE) {
                set(G-&gt;vertexColor, GRAY);
                set(G-&gt;vertexDist, distX + 1);
                set(G-&gt;vertexParent, x);
                append(queue, y);
            }
            moveNext(G-&gt;adjLists[x]);
        }
        moveFront(G-&gt;vertexColor);
        while (index(G-&gt;vertexColor) != x) {
            moveNext(G-&gt;vertexColor);
        }
        set(G-&gt;vertexColor, BLACK);
    }
    freeList(&amp;queue);
}

void maintainGraph(Graph G) {
</font><a name="4"></a><font color="#FF00FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa2_report/moss_results/winter25_winter25/Graph.c/part_1/report/match7-0.html#4" target="0"><img align="left" alt="other" border="0" src="./tm_4_5.gif"></a>

    for (int i = 1; i &lt;= G-&gt;numVertices; i++) {
        if (length(G-&gt;adjLists[i]) == 0) continue;
        List sortedList = newList();
        moveFront(G-&gt;adjLists[i]);
        append(sortedList, get(G-&gt;adjLists[i]));
        moveNext(G-&gt;adjLists[i]);
        while (index(G-&gt;adjLists[i]) &gt;= 0) {
            moveFront(sortedList);
            while (index(sortedList) &gt;= 0 &amp;&amp; get(sortedList) &lt; get(G-&gt;adjLists[i])) {
</font><a name="5"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa2_report/moss_results/winter25_winter25/Graph.c/part_1/report/match7-0.html#5" target="0"><img align="left" alt="other" border="0" src="./tm_0_4.gif"></a>

                moveNext(sortedList);
            }
            if (index(sortedList) &lt; 0) {
                append(sortedList, get(G-&gt;adjLists[i]));
            } else {
                insertBefore(sortedList, get(G-&gt;adjLists[i]));
            }
            moveNext(G-&gt;adjLists[i]);
        }
        freeList(&amp;(G-&gt;adjLists[i]));
        G-&gt;adjLists[i] = sortedList;
</font>    }
}

void printGraph(FILE* out, Graph G) {
    for (int i = 1; i &lt;= getOrder(G); i++) {
        fprintf(out, "%d:", i);
        moveFront(G-&gt;adjLists[i]);
        while (index(G-&gt;adjLists[i]) &gt;= 0) {
            fprintf(out, " %d", get(G-&gt;adjLists[i]));
            moveNext(G-&gt;adjLists[i]);
        }
        fprintf(out, "\n");
    }
}

void debugGraph(FILE* out, Graph G) {
<a name="6"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa2_report/moss_results/winter25_winter25/Graph.c/part_1/report/match7-0.html#6" target="0"><img align="left" alt="other" border="0" src="./tm_1_3.gif"></a>

    fprintf(out, "Graph Order: %d, Graph Size: %d, Source: %d\n", G-&gt;numVertices, G-&gt;numEdges, G-&gt;lastSource);
    moveFront(G-&gt;vertexColor);
    moveFront(G-&gt;vertexParent);
    moveFront(G-&gt;vertexDist);
</font>    for (int i = 1; i &lt;= G-&gt;numVertices; i++) {
        fprintf(out, "Vertex %d: Color=%d, Parent=%d, Distance=%d\n", i, get(G-&gt;vertexColor), get(G-&gt;vertexParent), get(G-&gt;vertexDist));
        moveNext(G-&gt;vertexColor);
        moveNext(G-&gt;vertexParent);
        moveNext(G-&gt;vertexDist);
    }
}
</pre>


</body></html>