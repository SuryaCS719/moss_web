
<!-- saved from url=(0117)file:///Users/surya/Desktop/moss/cse101/pa2_report/moss_results/winter25_winter25/Graph.c/part_1/report/match3-0.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>/winter25/bguo10/pa2/Graph.c</title>
</head>
<body bgcolor="white">
<hr>
/winter25/bguo10/pa2/Graph.c<p></p><pre>//-----------------------------------------------------------------------------
// Belle Guo
// bguo10
// 2025 Winter CSE101 PA2
// Graph.c 
// Implementation file for Graph ADT
//-----------------------------------------------------------------------------
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;
#include"Graph.h"

<a name="3"></a><font color="#00FFFF"><a href="file:///Users/surya/Desktop/moss/cse101/pa2_report/moss_results/winter25_winter25/Graph.c/part_1/report/match3-1.html#3" target="1"><img align="left" alt="other" border="0" src="./tm_3_10.gif"></a>

typedef struct GraphObj{
	List* neighbors;
	List color;
	List parent;
	List distance;
	int order;
	int size;
	int source;
} GraphObj;

/*** Constructors-Destructors ***/
Graph newGraph(int n){
	Graph g = (GraphObj *)malloc(1 * sizeof(GraphObj));
	g-&gt;neighbors = (List*)calloc(n+1, sizeof(List));

	for(int i = 0; i &lt;=n; i++){
		g-&gt;neighbors[i] = newList();
	}
	g-&gt;distance = newList();
	g-&gt;color = newList();
	g-&gt;parent = newList();

	for(int i = 0; i &lt;= n; i++){
		append(g-&gt;parent, NIL);
		append(g-&gt;color, WHITE);
		append(g-&gt;distance, INF);
	}
	g-&gt;size = 0;
</font>	g-&gt;order = n;
	g-&gt;source = NIL;
	return g;
}

void freeGraph(Graph* pG){
<a name="0"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa2_report/moss_results/winter25_winter25/Graph.c/part_1/report/match3-1.html#0" target="1"><img align="left" alt="other" border="0" src="./tm_0_26.gif"></a>

	if(pG != NULL &amp;&amp; *pG != NULL){
		for(int i = 0; i &lt;= (*pG)-&gt;order; i++){
			freeList(&amp;((*pG)-&gt;neighbors[i]));
		}
		freeList(&amp;((*pG)-&gt;distance));
		freeList(&amp;((*pG)-&gt;color));
		freeList(&amp;((*pG)-&gt;parent));
		free((*pG)-&gt;neighbors);
		free(*pG);
		*pG = NULL;
	}
}


/*** Access functions ***/
int getOrder(Graph G){
	return G-&gt;order;
}

int getSize(Graph G){
	return G-&gt;size;
}

int getSource(Graph G){
	return G-&gt;source;
}
int getParent(Graph G, int u){
    if(G-&gt;source == NIL){
        return NIL;
    }
    List parent = G-&gt;parent;
    moveFront(parent);
    while(index(parent) != u){
        moveNext(parent);
    }
    return get(parent);
}

int getDist(Graph G, int u){
	if(G-&gt;source == NIL){
		return INF;
	}
	List dist = G-&gt;distance;
	moveFront(dist);
	while(index(dist) != u){
		moveNext(dist);
	}
	return get(dist);
}

void getPath(List L, Graph G, int u){
	if(u == getSource(G)){
		append(L, u);
		return;
	}
	List newL = newList();
	append(newL, u);
	int p = getParent(G, u);
	append(newL, p);
	while(p != getSource(G) &amp;&amp; p != NIL){
		p = getParent(G, p);
		append(newL, p);
	}
	if(p == NIL){
		append(L, NIL);
	}
	else {
		moveBack(newL);
		while (index(newL) &gt;= 0){
			append(L, get(newL));
			movePrev(newL);
		}
	}
	freeList(&amp;newL);
}

/*** Manipulation procedures ***/
void makeNull(Graph G){
	clear(G-&gt;parent);
	clear(G-&gt;distance);
	clear(G-&gt;color);
	for(int i = 0; i &lt;= G-&gt;order; i++){
		clear(G-&gt;neighbors[i]);
	}
	G-&gt;source = NIL;
</font>	G-&gt;order = 0;
}

<a name="4"></a><font color="#FF00FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa2_report/moss_results/winter25_winter25/Graph.c/part_1/report/match3-1.html#4" target="1"><img align="left" alt="other" border="0" src="./tm_4_3.gif"></a>

void addEdge(Graph G, int u, int v){
	if(u == v){
		return;
	}
	append(G-&gt;neighbors[u], v);
	append(G-&gt;neighbors[v], u);
	G-&gt;size += 1;
</font>}

void addArc(Graph G, int u, int v){
	if(u == v){
		return;
	}
	append(G-&gt;neighbors[u], v);
	G-&gt;size+=1;
}

void BFS(Graph G, int s){
	maintainGraph(G);
	G-&gt;source = s;
	if (length(G-&gt;color) &gt; 0) moveFront(G-&gt;color);
	if (length(G-&gt;distance) &gt; 0) moveFront(G-&gt;distance);
<a name="1"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa2_report/moss_results/winter25_winter25/Graph.c/part_1/report/match3-1.html#1" target="1"><img align="left" alt="other" border="0" src="./tm_1_26.gif"></a>

	if (length(G-&gt;parent) &gt; 0) moveFront(G-&gt;parent);

	for(int i = 0; i &lt;= G-&gt;order; i++){
		set(G-&gt;color, WHITE);
		set(G-&gt;distance, INF);
		set(G-&gt;parent, NIL);
		moveNext(G-&gt;color);
		moveNext(G-&gt;distance);
		moveNext(G-&gt;parent);
	}
	moveFront(G-&gt;color);
	moveFront(G-&gt;distance);
	moveFront(G-&gt;parent);
	while (index(G-&gt;color) != s){
		moveNext(G-&gt;color);
		moveNext(G-&gt;distance);
		moveNext(G-&gt;parent);
	}
	set(G-&gt;color, GRAY);
	set(G-&gt;distance, 0);
	set(G-&gt;parent, NIL);
	List queue = newList();
	append(queue, s);
       while(length(queue) &gt; 0){
	       int x = front(queue);
	       deleteFront(queue);
	       moveFront(G-&gt;neighbors[x]);
	       while (index(G-&gt;neighbors[x]) &gt;= 0){
		       int y = get(G-&gt;neighbors[x]);
		       moveFront(G-&gt;distance);
		       while(index(G-&gt;distance) != x){
			       moveNext(G-&gt;distance);
		       }
		       int x_dist = get(G-&gt;distance);
		       moveFront(G-&gt;color);
		       moveFront(G-&gt;distance);
		       moveFront(G-&gt;parent);
		       while(index(G-&gt;color) != y){
			       moveNext(G-&gt;color);
			       moveNext(G-&gt;distance);
			       moveNext(G-&gt;parent);
		       }
		       if(get(G-&gt;color) == WHITE){
			       set(G-&gt;color, GRAY);
			       set(G-&gt;distance, x_dist + 1);
			       set(G-&gt;parent, x);
			       append(queue, y);
		       }
		       moveNext(G-&gt;neighbors[x]);
	       }
	       moveFront(G-&gt;color);
	       while (index(G-&gt;color) != x){
		       moveNext(G-&gt;color);
	       }
	       set(G-&gt;color, BLACK);
       }
       freeList(&amp;queue);
}
/*** Other operations ***/
void printGraph(FILE* out, Graph G){
</font><a name="2"></a><font color="#0000FF"><a href="file:///Users/surya/Desktop/moss/cse101/pa2_report/moss_results/winter25_winter25/Graph.c/part_1/report/match3-1.html#2" target="1"><img align="left" alt="other" border="0" src="./tm_2_19.gif"></a>

	for(int i = 1; i &lt;= getOrder(G); i++){
		moveFront(G-&gt;neighbors[i]);
		fprintf(out, "%d: ", i);
		while(index(G-&gt;neighbors[i]) &gt;= 0){
			int neighbor = get(G-&gt;neighbors[i]);
			fprintf(out,"%d ", neighbor);
			moveNext(G-&gt;neighbors[i]);
		}
		fprintf(out, "\n");
	}
}

void maintainGraph(Graph G){
    for(int i = 1; i &lt;= getOrder(G); i++){
        if(length(G-&gt;neighbors[i]) == 0){
            continue;
	}
        List L = newList();
        moveFront(G-&gt;neighbors[i]);
        append(L, get(G-&gt;neighbors[i]));
        moveNext(G-&gt;neighbors[i]);
        while(index(G-&gt;neighbors[i]) &gt;= 0){
            moveFront(L);
            while(index(L) &gt;= 0){
                if(get(L) &gt; get(G-&gt;neighbors[i])){
                    break;
                }
                moveNext(L);
            }
            if(index(L) &lt; 0){
                append(L, get(G-&gt;neighbors[i]));
            }else{
                insertBefore(L, get(G-&gt;neighbors[i]));
            }
            moveNext(G-&gt;neighbors[i]);
        }
        freeList(&amp;(G-&gt;neighbors[i]));
        G-&gt;neighbors[i] = L;
</font>    }
}
</pre>


</body></html>