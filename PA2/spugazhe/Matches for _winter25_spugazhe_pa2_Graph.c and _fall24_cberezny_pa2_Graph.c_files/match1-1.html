
<!-- saved from url=(0115)file:///Users/surya/Desktop/moss/cse101/pa2_report/moss_results/winter25_fall24/Graph.c/part_1/report/match1-1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>/winter25/spugazhe/pa2/Graph.c</title>
</head>
<body bgcolor="white">
<hr>
/fall24/cberezny/pa2/Graph.c<p></p><pre>/***
* Cole Berezny
* cberezny
* 2024 Fall CSE101 PA2
* Graph.c
* Implements the Graph ADT with functions for graph  manipulation (edges and arcs, breadth first search, etc.).
***/ 

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;

#include"Graph.h"

<a name="1"></a><font color="#00FF00"><a href="file:///Users/surya/Desktop/moss/cse101/pa2_report/moss_results/winter25_fall24/Graph.c/part_1/report/match1-0.html#1" target="0"><img align="left" alt="other" border="0" src="./tm_1_41.gif"></a>

typedef struct GraphObj{
    List* neighbors;
    List color;      
    List parent;
    List distance;
    int order;
    int size; 
    int source;
} GraphObj;


/*** Constructors-Destructors ***/ 
Graph newGraph(int n){
    Graph g = (GraphObj *)malloc(1 * sizeof(GraphObj));
    g-&gt;neighbors = (List*)calloc(n + 1, sizeof(List));

    for(int i = 0; i &lt;= n; i++){
        g-&gt;neighbors[i] = newList();
    }
    g-&gt;color = newList();
    g-&gt;parent = newList();
    g-&gt;distance = newList();
    for(int i = 0; i &lt;= n; i++){
        append(g-&gt;color, WHITE);
        append(g-&gt;distance, INF);
        append(g-&gt;parent, NIL);
    }
    g-&gt;order = n;
    g-&gt;size = 0;
    g-&gt;source = NIL;
    return g;
}

void freeGraph(Graph* pG){
    if(pG != NULL &amp;&amp; *pG != NULL){
        for(int i = 0; i &lt;= (*pG)-&gt;order; i++){
            freeList(&amp;((*pG)-&gt;neighbors[i]));
        }
        freeList(&amp;((*pG)-&gt;color));
        freeList(&amp;((*pG)-&gt;parent));
        freeList(&amp;((*pG)-&gt;distance));
        free((*pG)-&gt;neighbors);
        free(*pG);
        *pG = NULL;
    }
}

/*** Access functions ***/
int getOrder(Graph G){
    return G-&gt;order;
}

int getSize(Graph G){
    return G-&gt;size;
}

int getSource(Graph G){
    return G-&gt;source;
}

int getParent(Graph G, int u){
    if(G-&gt;source == NIL){
        return NIL;
    }
    List parent = G-&gt;parent;
    moveFront(parent);
    while(index(parent) != u){
        moveNext(parent);
    }
    return get(parent);
}

int getDist(Graph G, int u){
    if(G-&gt;source == NIL){
        return INF;
    }
    List dist = G-&gt;distance;
    moveFront(dist);
    while(index(dist) != u){
        moveNext(dist);
    }
    return get(dist);
}

// Appends to the List L the vertices of a shortest path in G from 
// source to u, or appends to L the value NIL if no such path exists.
// Precondition: 1 &lt;= u &lt;= getOrder(G), getSource(G) != NIL, BFS called first
void getPath(List L, Graph G, int u){
    if(u == getSource(G)){
        append(L, u);
        return;
    }
    List newL = newList();
    append(newL, u);
    int p = getParent(G,u);
    append(newL, p);
    while(p != getSource(G) &amp;&amp; p != NIL){
        p = getParent(G, p);
        append(newL, p);
    }
    if(p == NIL){
        append(L, NIL);
    }else{
        moveBack(newL);
        while (index(newL) &gt;= 0)
        {
            append(L,get(newL));
            movePrev(newL);
        }
    }
    freeList(&amp;newL);
}

/*** Manipulation procedures ***/
void makeNull(Graph G){
    clear(G-&gt;color);
    clear(G-&gt;parent);
    clear(G-&gt;distance);
    for(int i = 0; i &lt;= G-&gt;order; i ++){
        clear(G-&gt;neighbors[i]);
    }
    G-&gt;order = 0;
    G-&gt;source = NIL;
}


void addEdge(Graph G, int u, int v){
    if(u == v){
        return;
    }
    append(G-&gt;neighbors[u], v);
    append(G-&gt;neighbors[v], u);
    G-&gt;size += 1;
</font>}

void addArc(Graph G, int u, int v){
    if(u == v){
        return;
    }
    append(G-&gt;neighbors[u], v);
    G-&gt;size += 1;
}

// From Pseudo-code/GraphAlgorithms (in case needed)
<a name="0"></a><font color="#FF0000"><a href="file:///Users/surya/Desktop/moss/cse101/pa2_report/moss_results/winter25_fall24/Graph.c/part_1/report/match1-0.html#0" target="0"><img align="left" alt="other" border="0" src="./tm_0_54.gif"></a>

void BFS(Graph G, int s){
    maintainGraph(G);
    G-&gt;source = s;
    moveFront(G-&gt;color);
    moveFront(G-&gt;distance);
    moveFront(G-&gt;parent);
    for(int i = 0; i &lt;= G-&gt;order; i++){
        set(G-&gt;color, WHITE);
        set(G-&gt;distance, INF);
        set(G-&gt;parent, NIL);
        moveNext(G-&gt;color);
        moveNext(G-&gt;distance);
        moveNext(G-&gt;parent);
    }
    moveFront(G-&gt;color);
    moveFront(G-&gt;distance);
    moveFront(G-&gt;parent);
    while (index(G-&gt;color) != s)
    {
        moveNext(G-&gt;color);
        moveNext(G-&gt;distance);
        moveNext(G-&gt;parent);
    }
    set(G-&gt;color, GRAY);
    set(G-&gt;distance, 0);
    set(G-&gt;parent, NIL);
    List queue = newList();
    append(queue, s);
    // Loop until queue is empty
    while(length(queue) &gt; 0){
        int x = front(queue);
        deleteFront(queue);
        moveFront(G-&gt;neighbors[x]);
        // Iterate each adjecency of x
        while (index(G-&gt;neighbors[x]) &gt;= 0){
            int y = get(G-&gt;neighbors[x]);
            // Get the distance from x to source
            moveFront(G-&gt;distance);
            while(index(G-&gt;distance) != x){
                moveNext(G-&gt;distance);
            }
            int x_dist = get(G-&gt;distance);
            // Move cursor to the proper index
            moveFront(G-&gt;color);
            moveFront(G-&gt;distance);
            moveFront(G-&gt;parent);
            while(index(G-&gt;color) != y){
                moveNext(G-&gt;color);
                moveNext(G-&gt;distance);
                moveNext(G-&gt;parent);
            }
            if(get(G-&gt;color) == WHITE){
                set(G-&gt;color, GRAY);
                set(G-&gt;distance, x_dist + 1);
                set(G-&gt;parent, x);
                append(queue, y);
            }
            moveNext(G-&gt;neighbors[x]);
        }
        moveFront(G-&gt;color);
        while (index(G-&gt;color) != x)
        {
            moveNext(G-&gt;color);
        }
        set(G-&gt;color, BLACK);
    }
    freeList(&amp;queue);
}

/*** Other operations ***/

// Debugs graph
void debugGraph(FILE* out, Graph G){
    fprintf(out, "order: %d, size: %d, source: %d\n", G-&gt;order, G-&gt;size, G-&gt;source);
    moveFront(G-&gt;color);
    moveFront(G-&gt;parent);
    moveFront(G-&gt;distance);
    moveNext(G-&gt;color);
    moveNext(G-&gt;parent);
    moveNext(G-&gt;distance);
    for(int i = 1; i &lt;= G-&gt;order; i++){
        fprintf(out, "%d's properties :\n", i);
        fprintf(out, "\t");
        fprintf(out ,"color: %d, parent: %d, distance: %d\n", get(G-&gt;color), get(G-&gt;parent), get(G-&gt;distance));
        moveNext(G-&gt;color);
        moveNext(G-&gt;parent);
        moveNext(G-&gt;distance);
    }
}

// Prints graph stuff
void printGraph(FILE* out, Graph G){
    for(int i = 1; i &lt;= getOrder(G); i++){
        moveFront(G-&gt;neighbors[i]);
        fprintf(out, "%d:", i);
        while(index(G-&gt;neighbors[i]) &gt;= 0){
            int neighbor = get(G-&gt;neighbors[i]);
            fprintf(out, " %d", neighbor);
            moveNext(G-&gt;neighbors[i]);
        }
        fprintf(out, "\n");
    }
}

// Maintains graph in correct order
void maintainGraph(Graph G){
    for(int i = 1; i &lt;= getOrder(G); i++){
        if(length(G-&gt;neighbors[i]) == 0){
            continue;
        }        
        List L = newList();
        moveFront(G-&gt;neighbors[i]);
        append(L, get(G-&gt;neighbors[i]));
        moveNext(G-&gt;neighbors[i]);
        while(index(G-&gt;neighbors[i]) &gt;= 0){
            moveFront(L);
            while(index(L) &gt;= 0){
                if(get(L) &gt; get(G-&gt;neighbors[i])){
                    break;
                }
                moveNext(L);
            }
            if(index(L) &lt; 0){
                append(L, get(G-&gt;neighbors[i]));
            }else{
                insertBefore(L, get(G-&gt;neighbors[i]));
            }
            moveNext(G-&gt;neighbors[i]);
        }
        freeList(&amp;(G-&gt;neighbors[i]));
        G-&gt;neighbors[i] = L;
</font>    }
}
</pre>


</body></html>