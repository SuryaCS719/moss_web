
<!-- saved from url=(0062)http://moss.stanford.edu/results/7/6005093619200/match0-1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/avbandel/pa4/Matrix.c</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/spring23/hhuan143/pa4/Matrix.c<p></p><pre>/*
*James Huang, hhuan143
*2023 spring CSE101 PA#4
*Matrix.c
*writes the functions for Matrix.h
*/

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;
#include &lt;math.h&gt;
#include "Matrix.h"

typedef struct EntryObj *Entry;

typedef struct EntryObj {
    int col;
    double val;
} EntryObj;

typedef struct MatrixObj {
    int size;
    int NNZ;
    List *row;
} MatrixObj;

// constructor for Entry
Entry newEntry(int column, double value) {
    Entry E = malloc(sizeof(EntryObj));
    E-&gt;col = column; 
    E-&gt;val = value; 
    return E;
}

void deleteEntry(Entry *pE) {
<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/7/6005093619200/match0-0.html#3" target="0"><img src="./tm_3_4.gif" alt="other" border="0" align="left"></a>

    if (pE != NULL &amp;&amp; *pE != NULL){
        free(*pE);
        *pE = NULL;
    }
}


// newMatrix()
// Returns a reference to a new nXn Matrix object in the zero state.
Matrix newMatrix(int n){ 
	if (n &lt; 0){
		printf("Matrix Error: calling newMatrix() on size zero\n");
        exit(EXIT_FAILURE);
	}
	Matrix M;
	M = malloc(sizeof(MatrixObj));
	assert(M != NULL);
	M-&gt;size = n;
	M-&gt;NNZ = 0;//need this? 
	M-&gt;row = malloc(sizeof(List) * (n+1));
	for (int i = 1; i &lt;= n; i++){
		M-&gt;row[i] = newList();
	}
	return M;
</font>}

// freeMatrix()
// Frees heap memory associated with *pM, sets *pM to NULL.
void freeMatrix(Matrix* pM){
	if (pM != NULL &amp;&amp; *pM != NULL){
        makeZero(*pM);
        free(*pM);
        *pM = NULL;
    }
}
// Access functions
// size()
// Return the size of square Matrix M.
int size(Matrix M){
	if (M == NULL){
		printf("Matrix Error: calling size() on NULL matrix\n");
        exit(EXIT_FAILURE);
	}
	return M-&gt;size; 
}
// NNZ()
// Return the number of non-zero elements in M.
int NNZ(Matrix M){
	if (M == NULL){
		printf("Matrix Error: calling NNZ() on NULL matrix\n");
        exit(EXIT_FAILURE);
	}
<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/7/6005093619200/match0-0.html#0" target="0"><img src="./tm_0_60.gif" alt="other" border="0" align="left"></a>

	return M-&gt;NNZ; 
}
// equals()
// Return true (1) if matrices A and B are equal, false (0) otherwise.
int equals(Matrix A, Matrix B){
	if( A==NULL || B==NULL ){
      printf("Matrix Error: calling equals() on NULL Matrix reference\n");
      exit(EXIT_FAILURE);
    }
    if (A-&gt;size != B-&gt;size){
    	return 0;
    }
    Entry x, y;
    //List c, d;
    for (int i = 1; i &lt;= A-&gt;size; i++){
    	moveFront(A-&gt;row[i]);
    	moveFront(B-&gt;row[i]);
    	if (length(A-&gt;row[i]) == length(B-&gt;row[i])){
    		while(index(A-&gt;row[i]) &gt;= 0 &amp;&amp; index(B-&gt;row[i]) &gt;= 0){
    			x = (Entry)get(A-&gt;row[i]);
                y = (Entry)get(B-&gt;row[i]);
                if (x-&gt;val != y-&gt;val){
                	return 0;
                }
                if (x-&gt;col != y-&gt;col){
                    return 0;
                }
                moveNext(A-&gt;row[i]);
                moveNext(B-&gt;row[i]);
    		}
    	}else{
    		return 0;
    	}
    }
    return 1;
}
// Manipulation procedures
// makeZero()
// Re-sets M to the zero Matrix state.
void makeZero(Matrix M){
    if(M == NULL){
      printf("Matrix Error: calling makeZero() on NULL Matrix reference\n");
      exit(EXIT_FAILURE);
    }
    M-&gt;NNZ = 0;
    Entry E;
    for (int i = 1; i &lt;= M-&gt;size; i++){
        for (moveFront(M-&gt;row[i]);index(M-&gt;row[i]) &gt;= 0; moveNext(M-&gt;row[i])){
            E = (Entry)get(M-&gt;row[i]);
            deleteEntry(&amp;E); 
        }
        clear(M-&gt;row[i]);
    }

}
// changeEntry()
// Changes the ith row, jth column of M to the value x.
// Pre: 1&lt;=i&lt;=size(M), 1&lt;=j&lt;=size(M)
void changeEntry(Matrix M, int i, int j, double x){
    if (M == NULL){
        printf("Matrix Error: calling changeEntry() on NULL Matrix reference\n");
        exit(EXIT_FAILURE);
    }
    if (i &gt; M-&gt;size || i &lt; 1){
        printf("Matrix Error: calling changeEntry() on invalid i value\n");
        exit(EXIT_FAILURE);
    }
    if (j &gt; M-&gt;size || j &lt; 1){
        printf("Matrix Error: calling changeEntry() on invalid j value\n");
        exit(EXIT_FAILURE);
    }
    List L = M-&gt;row[i];
    if (length(L) == 0){
        if (x != 0){
            Entry E = newEntry(j, x);
            append(L, E);
            M-&gt;NNZ++;
        }
    }else{
        for (moveFront(L); index(L) &gt;= 0; moveNext(L)){
            Entry E = (Entry)get(L);
            if (E-&gt;col == j){
                if (x != 0){
                    Entry E = (Entry)get(L);
                    E-&gt;val = x;
                }else{
                    Entry E = (Entry)get(L);
                    deleteEntry(&amp;E);
                    delete(L);
                    M-&gt;NNZ--;
                }
                break;
            }else if(E-&gt;col &gt; j){
                if (x != 0){
                    Entry E = newEntry(j, x);
                    insertBefore(L, E);
                    M-&gt;NNZ++;
                }
                break;
            }
        }
        if (index(L) == -1){
            if (x != 0){
                Entry E = newEntry(j, x);
                append(L, E);
                M-&gt;NNZ++;
            }
        }
    }
}
// Matrix Arithmetic operations
// copy()
// Returns a reference to a new Matrix object having the same entries as A.
Matrix copy(Matrix A){
    if (A == NULL){
        printf("Matrix Error: calling copy() on NULL matrix reference\n");
        exit(EXIT_FAILURE);
    }
    int col;
    double val;
    Matrix M = newMatrix(A-&gt;size);
    M-&gt;NNZ = A-&gt;NNZ;
    for (int i = 1;i &lt;= A-&gt;size; i++){
        for (moveFront(A-&gt;row[i]); index(A-&gt;row[i]) &gt;= 0; moveNext(A-&gt;row[i])){
            Entry E = (Entry)get(A-&gt;row[i]);
            col = E-&gt;col;
            val = E-&gt;val;
            Entry copy = newEntry(col, val);
            append(M-&gt;row[i], copy);
        }
    }
    return M;

}
// transpose()
// Returns a reference to a new Matrix object representing the transpose
// of A.
Matrix transpose(Matrix A){
    if (A == NULL){
        printf("Matrix Error: calling transpose() on NULL matrix reference\n");
        exit(EXIT_FAILURE);
    }
    Matrix T = newMatrix(A-&gt;size);
    double val;
    int j;
    T-&gt;NNZ = A-&gt;NNZ;
    for (int i = 1; i &lt;= A-&gt;size; i++){
        for (moveFront(A-&gt;row[i]); index(A-&gt;row[i]) &gt;= 0; moveNext(A-&gt;row[i])){
            Entry E = (Entry)get(A-&gt;row[i]);
            j = E-&gt;col;
            val = E-&gt;val;
            Entry copy = newEntry(i, val);
            append(T-&gt;row[j], copy);
        }
    }
    return T;
}
// scalarMult()
// Returns a reference to a new Matrix object representing xA.
Matrix scalarMult(double x, Matrix A){
    if (A == NULL){
        printf("Matrix Error: calling scalarMult() on NULL matrix reference\n");
        exit(EXIT_FAILURE);
    }
    Matrix M = newMatrix(A-&gt;size);
    int col;
    double val;
    if (x == 0 || A-&gt;NNZ == 0){
        return M;
    }
    for (int i = 1; i &lt;= A-&gt;size; i++){
        for (moveFront(A-&gt;row[i]); index(A-&gt;row[i]) &gt;= 0; moveNext(A-&gt;row[i])){
            Entry E = (Entry)get(A-&gt;row[i]);
            col = E-&gt;col;
            val = E-&gt;val * (x);
            Entry copy = newEntry(col, val);
            append(M-&gt;row[i], copy);
            M-&gt;NNZ++;
        }
    }
    return M;
}
// sum()
// Returns a reference to a new Matrix object representing A+B.
// pre: size(A)==size(B)
void vecSum(List A, List B, List C, int sign){
    double x, y, z;
    Entry a, b;
    moveFront(A);
    moveFront(B);
    while (index(A) &gt;= 0 &amp;&amp; index(B) &gt;= 0){
        a = get(A);
        b = get(B);
        x = a-&gt;val;
        y = (sign) * b-&gt;val;
        if (a-&gt;col == b-&gt;col){
            z = x + y;
            if (z != 0){
                Entry new = newEntry(a-&gt;col, z);
                append(C, new);
            }
            moveNext(A);
            moveNext(B);
        }else if (a-&gt;col &lt; b-&gt;col){
            Entry new = newEntry(a-&gt;col, x);
            append(C, new);
            moveNext(A);
        }else{
            Entry new = newEntry(b-&gt;col, y);
            append(C, new);
            moveNext(B);
        }

    }
    while (index(A) &gt;= 0){
        a = get(A);
        Entry new = newEntry(a-&gt;col, a-&gt;val);
        append(C, new);
        moveNext(A);
    }
    while (index(B) &gt;= 0){
        b = get(B);
        Entry new = newEntry(b-&gt;col, (sign) * b-&gt;val);
        append(C, new);
        moveNext(B);
    }
}
Matrix sum(Matrix A, Matrix B){
    if (A == NULL || B == NULL){
        printf("Matrix Error: calling sum() on NULL matrix reference\n");
        exit(EXIT_FAILURE);
    }
    if (A-&gt;size != B-&gt;size){
        printf("Matrix Error: calling sum() on different size matrices\n");
        exit(EXIT_FAILURE);
    }
    Matrix M = newMatrix(A-&gt;size);
    if (equals(A, B) == 1){
        return scalarMult(2, A);
</font>    }else{
<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/7/6005093619200/match0-0.html#2" target="0"><img src="./tm_2_12.gif" alt="other" border="0" align="left"></a>

        for (int i = 1; i &lt;= M-&gt;size; i++){
            vecSum(A-&gt;row[i], B-&gt;row[i], M-&gt;row[i], 1);
            M-&gt;NNZ += length(M-&gt;row[i]);
        }
    }
    return M;
}
// diff()
// Returns a reference to a new Matrix object representing A-B.
// pre: size(A)==size(B)
Matrix diff(Matrix A, Matrix B){
    if (A == NULL || B == NULL){
        printf("Matrix Error: calling sum() on NULL matrix reference\n");
        exit(EXIT_FAILURE);
    }
    if (A-&gt;size != B-&gt;size){
        printf("Matrix Error: calling sum() on different size matrices\n");
        exit(EXIT_FAILURE);
    }
    Matrix M = newMatrix(A-&gt;size);
    if (equals(A, B)){
        makeZero(M);
        return M;
    }else{
        for (int i = 1; i &lt;= M-&gt;size; i++){
            vecSum(A-&gt;row[i], B-&gt;row[i], M-&gt;row[i], -1);
            M-&gt;NNZ += length(M-&gt;row[i]);
        }
    }
    return M;
}
// product()
// Returns a reference to a new Matrix object representing AB
// pre: size(A)==size(B)
double vecDot(List A, List B){
    double x = 0.0;
    Entry a, b; 
    moveFront(A); 
    moveFront(B);
    while (index(A) &gt;= 0 &amp;&amp; index(B) &gt;= 0){
        //printf("meow\n");
        a = (Entry)get(A);
        b = (Entry)get(B);
        if (a-&gt;col == b-&gt;col){
            x += a-&gt;val * b-&gt;val;
</font>            moveNext(A);
            moveNext(B);
        }else if (a-&gt;col &lt; b-&gt;col){
<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/7/6005093619200/match0-0.html#1" target="0"><img src="./tm_1_13.gif" alt="other" border="0" align="left"></a>

            moveNext(A);
        }else{
            moveNext(B);
        }

    }
    return x;
}
Matrix product(Matrix A, Matrix B){
    if (A == NULL || B == NULL){
        printf("Matrix Error: calling sum() on NULL matrix reference\n");
        exit(EXIT_FAILURE);
    }
    if (A-&gt;size != B-&gt;size){
        printf("Matrix Error: calling sum() on different size matrices\n");
        exit(EXIT_FAILURE);
    }
    Matrix M = newMatrix(A-&gt;size);
    Matrix T = transpose(B);
    double x; 
    for (int i = 1; i &lt;= A-&gt;size; i++){
        for (int j = 1; j &lt;= A-&gt;size; j++){
            if (length(A-&gt;row[i]) == 0){
                break;
            }
            x = vecDot(A-&gt;row[i], T-&gt;row[j]);
            if (x != 0.0){
                Entry new = newEntry(j, x);
                append(M-&gt;row[i], new);
                M-&gt;NNZ++;

            }
        }
    }
    freeMatrix(&amp;T);
    return M;
}
// printMatrix()
// Prints a string representation of Matrix M to filestream out. Zero rows
// are not printed. Each non-zero row is represented as one line consisting
// of the row number, followed by a colon, a space, then a space separated
// list of pairs "(col, val)" giving the column numbers and non-zero values
// in that row. The double val will be rounded to 1 decimal point.
void printMatrix(FILE* out, Matrix M){
    Entry E;
    for (int i = 1; i &lt;= M-&gt;size; i++){
        if (length(M-&gt;row[i]) != 0){
            fprintf(out, "%d:", i);
            for (moveFront(M-&gt;row[i]); index(M-&gt;row[i]) &gt;= 0; moveNext(M-&gt;row[i])){
                E = (Entry)get(M-&gt;row[i]);
                fprintf(out, "(%d, %.1f) ", E-&gt;col, E-&gt;val);
            }
            if (index(M-&gt;row[i]) == -1){
</font>                fprintf(out, "\n");
            }
        }
    }
}



</pre>



</body></html>