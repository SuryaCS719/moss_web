
<!-- saved from url=(0062)http://moss.stanford.edu/results/7/6005093619200/match0-0.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/avbandel/pa4/Matrix.c</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter25/avbandel/pa4/Matrix.c<p></p><pre>/*
*Bayo Bandele
*avbandel
*2025 Winter CSE101 PA#4
*Matrix.c
*Writes the functions from Matrix.h
*/

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;
#include &lt;math.h&gt;
#include "Matrix.h"

typedef struct EntryObj *Entry;

typedef struct EntryObj {
    int col;
    double val;
} EntryObj;

typedef struct MatrixObj {
    int size;
    int NNZ;
    List *row;
} MatrixObj;


Entry newEntry(int column, double value) {
    Entry D = malloc(sizeof(EntryObj));
    D-&gt;col = column; 
    D-&gt;val = value; 
    return D;
}

void deleteEntry(Entry *pE) {
<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/7/6005093619200/match0-1.html#3" target="1"><img src="./tm_3_4.gif" alt="other" border="0" align="left"></a>

    if (pE != NULL &amp;&amp; *pE != NULL){
        free(*pE);
        *pE = NULL;
    }
}



Matrix newMatrix(int n){ 
	if (n &lt; 0){
		printf("Matrix Error\n");
        exit(EXIT_FAILURE);
	}
	Matrix A;
	A = malloc(sizeof(MatrixObj));
	assert(A != NULL);
	A-&gt;size = n;
	A-&gt;NNZ = 0;//need this? 
	A-&gt;row = malloc(sizeof(List) * (n+1));
	for (int i = 1; i &lt;= n; i++){
		A-&gt;row[i] = newList();
	}
	return A;
</font>}

// Frees heap memory associated with *pM, sets *pM to NULL.
void freeMatrix(Matrix* pM){
    if (pM != NULL &amp;&amp; *pM != NULL){
        // Free all entries inside the row lists
        for (int i = 1; i &lt;= (*pM)-&gt;size; i++){
            List L = (*pM)-&gt;row[i];
            for (moveFront(L); index(L) &gt;= 0; moveNext(L)){
                Entry E = (Entry)get(L);
                deleteEntry(&amp;E);
            }
            freeList(&amp;((*pM)-&gt;row[i])); // Free the list 
        }
        free((*pM)-&gt;row); // Free the array 
        free(*pM);  // Free the Matrix 
        *pM = NULL;
    }
}

int size(Matrix M){
	if (M == NULL){
		printf("Matrix Error: NULL matrix\n");
        exit(EXIT_FAILURE);
	}
	return M-&gt;size; 
}

int NNZ(Matrix M){
	if (M == NULL){
		printf("Matrix Error: NULL matrix\n");
        exit(EXIT_FAILURE);
	}
<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/7/6005093619200/match0-1.html#0" target="1"><img src="./tm_0_58.gif" alt="other" border="0" align="left"></a>

	return M-&gt;NNZ; 
}

int equals(Matrix A, Matrix B){
	if( A==NULL || B==NULL ){
      printf("Matrix Error:  NULL Matrix\n");
      exit(EXIT_FAILURE);
    }
    if (A-&gt;size != B-&gt;size){
    	return 0;
    }
    Entry x, y;
    for (int i = 1; i &lt;= A-&gt;size; i++){
    	moveFront(A-&gt;row[i]);
    	moveFront(B-&gt;row[i]);
    	if (length(A-&gt;row[i]) == length(B-&gt;row[i])){
    		while(index(A-&gt;row[i]) &gt;= 0 &amp;&amp; index(B-&gt;row[i]) &gt;= 0){
    			x = (Entry)get(A-&gt;row[i]);
                y = (Entry)get(B-&gt;row[i]);
                if (x-&gt;val != y-&gt;val){
                	return 0;
                }
                if (x-&gt;col != y-&gt;col){
                    return 0;
                }
                moveNext(A-&gt;row[i]);
                moveNext(B-&gt;row[i]);
    		}
    	}else{
    		return 0;
    	}
    }
    return 1;
}


void makeZero(Matrix M){
    if(M == NULL){
      printf("Matrix Error: NULL Matrix\n");
      exit(EXIT_FAILURE);
    }
    M-&gt;NNZ = 0;
    Entry E;
    for (int i = 1; i &lt;= M-&gt;size; i++){
        for (moveFront(M-&gt;row[i]);index(M-&gt;row[i]) &gt;= 0; moveNext(M-&gt;row[i])){
            E = (Entry)get(M-&gt;row[i]);
            deleteEntry(&amp;E); 
        }
        clear(M-&gt;row[i]);
    }

}

void changeEntry(Matrix M, int i, int j, double x){
    if (M == NULL){
        printf("Matrix Error: NULL Matrix\n");
        exit(EXIT_FAILURE);
    }
    if (i &gt; M-&gt;size || i &lt; 1){
        printf("Matrix Error: invalid i value\n");
        exit(EXIT_FAILURE);
    }
    if (j &gt; M-&gt;size || j &lt; 1){
        printf("Matrix Error: invalid j value\n");
        exit(EXIT_FAILURE);
    }
    List L = M-&gt;row[i];
    if (length(L) == 0){
        if (x != 0){
            Entry E = newEntry(j, x);
            append(L, E);
            M-&gt;NNZ++;
        }
    }else{
        for (moveFront(L); index(L) &gt;= 0; moveNext(L)){
            Entry E = (Entry)get(L);
            if (E-&gt;col == j){
                if (x != 0){
                    Entry E = (Entry)get(L);
                    E-&gt;val = x;
                }else{
                    Entry E = (Entry)get(L);
                    deleteEntry(&amp;E);
                    delete(L);
                    M-&gt;NNZ--;
                }
                break;
            }else if(E-&gt;col &gt; j){
                if (x != 0){
                    Entry E = newEntry(j, x);
                    insertBefore(L, E);
                    M-&gt;NNZ++;
                }
                break;
            }
        }
        if (index(L) == -1){
            if (x != 0){
                Entry E = newEntry(j, x);
                append(L, E);
                M-&gt;NNZ++;
            }
        }
    }
}

Matrix copy(Matrix A){
    if (A == NULL){
        printf("Matrix Error: NULL matrix reference\n");
        exit(EXIT_FAILURE);
    }
    int col;
    double val;
    Matrix M = newMatrix(A-&gt;size);
    M-&gt;NNZ = A-&gt;NNZ;
    for (int i = 1;i &lt;= A-&gt;size; i++){
        for (moveFront(A-&gt;row[i]); index(A-&gt;row[i]) &gt;= 0; moveNext(A-&gt;row[i])){
            Entry E = (Entry)get(A-&gt;row[i]);
            col = E-&gt;col;
            val = E-&gt;val;
            Entry copy = newEntry(col, val);
            append(M-&gt;row[i], copy);
        }
    }
    return M;

}

Matrix transpose(Matrix A){
    if (A == NULL){
        printf("Matrix Error: NULL matrix reference\n");
        exit(EXIT_FAILURE);
    }
    Matrix T = newMatrix(A-&gt;size);
    double val;
    int j;
    T-&gt;NNZ = A-&gt;NNZ;
    for (int i = 1; i &lt;= A-&gt;size; i++){
        for (moveFront(A-&gt;row[i]); index(A-&gt;row[i]) &gt;= 0; moveNext(A-&gt;row[i])){
            Entry E = (Entry)get(A-&gt;row[i]);
            j = E-&gt;col;
            val = E-&gt;val;
            Entry copy = newEntry(i, val);
            append(T-&gt;row[j], copy);
        }
    }
    return T;
}

Matrix scalarMult(double x, Matrix A){
    if (A == NULL){
        printf("Matrix Error: NULL matrix reference\n");
        exit(EXIT_FAILURE);
    }
    Matrix M = newMatrix(A-&gt;size);
    int col;
    double val;
    if (x == 0 || A-&gt;NNZ == 0){
        return M;
    }
    for (int i = 1; i &lt;= A-&gt;size; i++){
        for (moveFront(A-&gt;row[i]); index(A-&gt;row[i]) &gt;= 0; moveNext(A-&gt;row[i])){
            Entry E = (Entry)get(A-&gt;row[i]);
            col = E-&gt;col;
            val = E-&gt;val * (x);
            Entry copy = newEntry(col, val);
            append(M-&gt;row[i], copy);
            M-&gt;NNZ++;
        }
    }
    return M;
}

void vecSum(List A, List B, List C, int sign){
    double x, y, z;
    Entry a, b;
    moveFront(A);
    moveFront(B);
    while (index(A) &gt;= 0 &amp;&amp; index(B) &gt;= 0){
        a = get(A);
        b = get(B);
        x = a-&gt;val;
        y = (sign) * b-&gt;val;
        if (a-&gt;col == b-&gt;col){
            z = x + y;
            if (z != 0){
                Entry new = newEntry(a-&gt;col, z);
                append(C, new);
            }
            moveNext(A);
            moveNext(B);
        }else if (a-&gt;col &lt; b-&gt;col){
            Entry new = newEntry(a-&gt;col, x);
            append(C, new);
            moveNext(A);
        }else{
            Entry new = newEntry(b-&gt;col, y);
            append(C, new);
            moveNext(B);
        }

    }
    while (index(A) &gt;= 0){
        a = get(A);
        Entry new = newEntry(a-&gt;col, a-&gt;val);
        append(C, new);
        moveNext(A);
    }
    while (index(B) &gt;= 0){
        b = get(B);
        Entry new = newEntry(b-&gt;col, (sign) * b-&gt;val);
        append(C, new);
        moveNext(B);
    }
}
Matrix sum(Matrix A, Matrix B){
    if (A == NULL || B == NULL){
        printf("Matrix Error: NULL matrix reference\n");
        exit(EXIT_FAILURE);
    }
    if (A-&gt;size != B-&gt;size){
        printf("Matrix Error: different size matrices\n");
        exit(EXIT_FAILURE);
    }
    Matrix M = newMatrix(A-&gt;size);
    if (equals(A, B) == 1){
        Matrix temp = scalarMult(2, A);
</font>        freeMatrix(&amp;M); // Free allocated M before returning
        return temp;
    }else{
<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/7/6005093619200/match0-1.html#2" target="1"><img src="./tm_2_11.gif" alt="other" border="0" align="left"></a>

        for (int i = 1; i &lt;= M-&gt;size; i++){
            vecSum(A-&gt;row[i], B-&gt;row[i], M-&gt;row[i], 1);
            M-&gt;NNZ += length(M-&gt;row[i]);
        }
    }
    return M;
}


Matrix diff(Matrix A, Matrix B){
    if (A == NULL || B == NULL){
        printf("Matrix Error: NULL matrix reference\n");
        exit(EXIT_FAILURE);
    }
    if (A-&gt;size != B-&gt;size){
        printf("Matrix Error: different size matrices\n");
        exit(EXIT_FAILURE);
    }
    Matrix M = newMatrix(A-&gt;size);
    if (equals(A, B)){
        makeZero(M);
        return M;
    }else{
        for (int i = 1; i &lt;= M-&gt;size; i++){
            vecSum(A-&gt;row[i], B-&gt;row[i], M-&gt;row[i], -1);
            M-&gt;NNZ += length(M-&gt;row[i]);
        }
    }
    return M;
}

double vecDot(List A, List B){
    double x = 0.0;
    Entry a, b; 
    moveFront(A); 
    moveFront(B);
    while (index(A) &gt;= 0 &amp;&amp; index(B) &gt;= 0){
        //printf("meow\n");
        a = (Entry)get(A);
        b = (Entry)get(B);
        if (a-&gt;col == b-&gt;col){
            x += a-&gt;val * b-&gt;val;
</font>            moveNext(A);
            moveNext(B);
        }else if (a-&gt;col &lt; b-&gt;col){
<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/7/6005093619200/match0-1.html#1" target="1"><img src="./tm_1_13.gif" alt="other" border="0" align="left"></a>

            moveNext(A);
        }else{
            moveNext(B);
        }

    }
    return x;
}
Matrix product(Matrix A, Matrix B){
    if (A == NULL || B == NULL){
        printf("Matrix Error: NULL matrix reference\n");
        exit(EXIT_FAILURE);
    }
    if (A-&gt;size != B-&gt;size){
        printf("Matrix Error: different size matrices\n");
        exit(EXIT_FAILURE);
    }
    Matrix M = newMatrix(A-&gt;size);
    Matrix T = transpose(B);
    double x; 
    for (int i = 1; i &lt;= A-&gt;size; i++){
        for (int j = 1; j &lt;= A-&gt;size; j++){
            if (length(A-&gt;row[i]) == 0){
                break;
            }
            x = vecDot(A-&gt;row[i], T-&gt;row[j]);
            if (x != 0.0){
                Entry new = newEntry(j, x);
                append(M-&gt;row[i], new);
                M-&gt;NNZ++;

            }
        }
    }
    freeMatrix(&amp;T);
    return M;
}

void printMatrix(FILE* out, Matrix M){
    Entry E;
    for (int i = 1; i &lt;= M-&gt;size; i++){
        if (length(M-&gt;row[i]) != 0){
            fprintf(out, "%d:", i);
            for (moveFront(M-&gt;row[i]); index(M-&gt;row[i]) &gt;= 0; moveNext(M-&gt;row[i])){
                E = (Entry)get(M-&gt;row[i]);
                fprintf(out, "(%d, %.1f) ", E-&gt;col, E-&gt;val);
            }
            if (index(M-&gt;row[i]) == -1){
</font>                fprintf(out, "\n");
            }
        }
    }
}
</pre>



</body></html>