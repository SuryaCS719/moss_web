
<!-- saved from url=(0062)http://moss.stanford.edu/results/6/5655424630708/match0-1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/aagarw43/pa4/Matrix.c</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/fall23/gealgome/pa4/Matrix.c<p></p><pre>#include "List.h"
#include "Matrix.h"
#include "stdlib.h"

<a name="9"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/6/5655424630708/match0-0.html#9" target="0"><img src="./tm_4_2.gif" alt="other" border="0" align="left"></a>

typedef struct EntryObj* Entry;

typedef struct EntryObj{
    double data;
    int index;
} EntryObj;

// Create a entry of data d, and index i.
Entry newEntry(double d, int i){
    Entry E = malloc(sizeof(EntryObj));
    E-&gt;data = d;
    E-&gt;index = i;
    return E;
}

void freeEntry(Entry* pE){
</font>    if(pE != NULL &amp;&amp; *pE != NULL){
        free(*pE);
        *pE = NULL;
<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/6/5655424630708/match0-0.html#2" target="0"><img src="./tm_2_13.gif" alt="other" border="0" align="left"></a>

        pE = NULL;
    }
}

typedef struct MatrixObj{
    // Rows in matrix, each row is a List ADT which contains sevral entrys.
    List* rows;
    // The size of square Matrix
    int size;
    // The Number of None Zero element
    int nnz;        
}MatrixObj;

Matrix newMatrix(int n){
    Matrix M = malloc(sizeof(MatrixObj));
    M-&gt;rows = calloc(n + 1, sizeof(List));
    for(int i = 0; i &lt;= n; i++){
        M-&gt;rows[i] = newList();

    }
    M-&gt;size = n;
    M-&gt;nnz = 0;
    return M;
}


void moveCursor(List L, int i){
    while(((Entry)get(L))-&gt;index != i){
        if(index(L) == -1) moveFront(L);
        if(((Entry)get(L))-&gt;index &lt; i) moveNext(L);
        if(((Entry)get(L))-&gt;index &gt; i) movePrev(L);
    }
}
Entry getEntry(Matrix M ,int i, int j){
    List row = M-&gt;rows[i];
    for(moveFront(row); index(row) &gt;= 0; moveNext(row)){
        Entry E = get(row);
        if(E-&gt;index == j){
            return E;
        }
    }
    return NULL;
}

void freeMatrix(Matrix* pM){
    if(pM != NULL &amp;&amp; *pM != NULL){
        for(int i = 0; i &lt;= size(*pM); i++){
            List row = (*pM)-&gt;rows[i];
            for(moveFront(row); index(row) &gt;= 0; moveNext(row)){
                Entry E = get(row);
                freeEntry(&amp;E);
            }
            freeList(&amp;((*pM)-&gt;rows[i]));
        }
        free((*pM)-&gt;rows);
        free((*pM));
        *pM = NULL;
</font>        pM = NULL;
    }
}

<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/6/5655424630708/match0-0.html#0" target="0"><img src="./tm_0_19.gif" alt="other" border="0" align="left"></a>

int size(Matrix M){
    return M-&gt;size;
}

int NNZ(Matrix M){
    return M-&gt;nnz;
}

bool equalsEntry(Entry A, Entry B){
    return A-&gt;data == B-&gt;data &amp;&amp; A-&gt;index == B-&gt;index;
}

bool equalsRow(List A, List B){
    for(moveFront(A), moveFront(B); index(A) &gt;=0 &amp;&amp; index(B) &gt;= 0; moveNext(A), moveNext(B)){
        Entry a = get(A);
        Entry b = get(B);
        if(!equalsEntry(a, b)){
            return false;
        }
    }
    return true;
}

int equals(Matrix A, Matrix B){
    if(A-&gt;size != B-&gt;size || A-&gt;nnz != B-&gt;nnz){
        return 0;
    }
    for(int i = 0; i &lt;= size(A); i++){
        if(!equalsRow(A-&gt;rows[i], A-&gt;rows[i])){
            return 0;
        }
    }
    return 1;
}

void makeZero(Matrix M){
    for(int i = 0; i &lt; size(M); i++){
        List row = M-&gt;rows[i];
        while(length(row) &gt; 0){
            deleteFront(row);
        }
    }
    M-&gt;nnz = 0;
}

// If M doesn't have ith row, jth column Entry, create a new Entry and insert it into the proper position
// If M have ith row, jth column Entry, then change the value of such Entry.
void changeEntry(Matrix M, int i, int j, double x){
    Entry E = getEntry(M, i, j);
    if(E == NULL){  // M_ij doesn't exist.
        if(x == 0){
            return;
        }
        List row = M-&gt;rows[i];
        // move cursor of ith row to a proper position for inserting a new Entry.
        for(moveFront(row); index(row) &gt;= 0; moveNext(row)){
            if(((Entry)get(row))-&gt;index &gt; j){
                break;
            }
        }
        // append a new Entry to a proper position in ith row.
        if(index(row) &gt;= 0){
            insertBefore(row, newEntry(x, j));
        }else{
            append(M-&gt;rows[i], newEntry(x, j));
        }
        // Change NNZ field
        M-&gt;nnz ++;
    }else{  // M_ij exist.
        // Change NNZ field
        if(x == 0){
            moveCursor(M-&gt;rows[i], j);
            freeEntry(&amp;E);
            delete(M-&gt;rows[i]);
            M-&gt;nnz -= 1;
            return;
        }
        E-&gt;data = x;
    }
}

Matrix copy(Matrix A){
    Matrix copyA = newMatrix(size(A));
    copyA-&gt;nnz = NNZ(A);
    for(int i = 0; i &lt;= size(A); i++){
</font>        List row = A-&gt;rows[i];
<a name="8"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/6/5655424630708/match0-0.html#8" target="0"><img src="./tm_3_3.gif" alt="other" border="0" align="left"></a>

        for(moveFront(row); index(row) &gt;= 0; moveNext(row)){
            Entry E = get(row);
            append(copyA-&gt;rows[i], newEntry(E-&gt;data, E-&gt;index));
        }
    }
    return copyA;
}

Matrix transpose(Matrix A){
    Matrix T = newMatrix(size(A));
    T-&gt;nnz = NNZ(A);
    for(int i = 0; i &lt;= size(A); i++){
</font><a name="6"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/6/5655424630708/match0-0.html#6" target="0"><img src="./tm_1_3.gif" alt="other" border="0" align="left"></a>

        List row = A-&gt;rows[i];
        for(moveFront(row); index(row) &gt;= 0; moveNext(row)){
            Entry E = get(row);
            append(T-&gt;rows[E-&gt;index], newEntry(E-&gt;data, i));
        }
    }
    return T;
}

Matrix scalarMult(double x, Matrix A){
    Matrix scalarA = newMatrix(size(A));
    scalarA-&gt;nnz = NNZ(A);
    for(int i = 0; i &lt;= size(A); i++){
</font>        List row = A-&gt;rows[i];
<a name="5"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/6/5655424630708/match0-0.html#5" target="0"><img src="./tm_0_4.gif" alt="other" border="0" align="left"></a>

        for(moveFront(row); index(row) &gt;= 0; moveNext(row)){
            Entry E = get(row);
            append(scalarA-&gt;rows[i], newEntry(x * E-&gt;data, E-&gt;index));
            if(x == 0){
                scalarA-&gt;nnz -= 1;
            }
        }
    }
    return scalarA;
}

Matrix sum(Matrix A, Matrix B){
    B = copy(B);
    Matrix sumAB = newMatrix(size(A));
    for(int i = 0; i &lt;= size(A); i++){
</font>        List rowA = A-&gt;rows[i];
<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/6/5655424630708/match0-0.html#1" target="0"><img src="./tm_1_14.gif" alt="other" border="0" align="left"></a>

        List rowB = B-&gt;rows[i];
        for(moveFront(rowA), moveFront(rowB); index(rowA) &gt;= 0 &amp;&amp; index(rowB) &gt;= 0; ){
            Entry E_A = get(rowA);
            Entry E_B = get(rowB);
            if(E_A-&gt;index == E_B-&gt;index){
                append(sumAB-&gt;rows[i], newEntry(E_A-&gt;data + E_B-&gt;data, E_A-&gt;index));
                if(E_A-&gt;data + E_B-&gt;data == 0){
                    deleteBack(sumAB-&gt;rows[i]);
                    sumAB-&gt;nnz -= 1;
                }
                moveNext(rowA);
                moveNext(rowB);
            }else if (E_A-&gt;index &lt; E_B-&gt;index){
                append(sumAB-&gt;rows[i], newEntry(E_A-&gt;data, E_A-&gt;index));
                moveNext(rowA);
            }else if (E_A-&gt;index &gt; E_B-&gt;index){
                append(sumAB-&gt;rows[i], newEntry(E_B-&gt;data, E_B-&gt;index));
                moveNext(rowB);
            }
            sumAB-&gt;nnz += 1;
        }
        while (index(rowA) &gt;= 0){
            Entry E_A = get(rowA);
            append(sumAB-&gt;rows[i], newEntry(E_A-&gt;data, E_A-&gt;index));
            sumAB-&gt;nnz += 1;
            moveNext(rowA);
        }
        while (index(rowB) &gt;= 0){
            Entry E_B = get(rowB);
            append(sumAB-&gt;rows[i], newEntry(E_B-&gt;data, E_B-&gt;index));
            sumAB-&gt;nnz += 1;
            moveNext(rowB);
        }
    }
    freeMatrix(&amp;B);
    return sumAB;
}

Matrix diff(Matrix A, Matrix B){
    B = copy(B);
    Matrix diffAB = newMatrix(size(A));
    for(int i = 0; i &lt;= size(A); i++){
</font>        List rowA = A-&gt;rows[i];
<a name="7"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/6/5655424630708/match0-0.html#7" target="0"><img src="./tm_2_3.gif" alt="other" border="0" align="left"></a>

        List rowB = B-&gt;rows[i];
        for(moveFront(rowA), moveFront(rowB); index(rowA) &gt;= 0 &amp;&amp; index(rowB) &gt;= 0; ){
            Entry E_A = get(rowA);
            Entry E_B = get(rowB);
            if(E_A-&gt;index == E_B-&gt;index){
                append(diffAB-&gt;rows[i], newEntry(E_A-&gt;data - E_B-&gt;data, E_A-&gt;index));
                if(E_A-&gt;data - E_B-&gt;data == 0){
</font>                    deleteBack(sumAB-&gt;rows[i]);
<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/6/5655424630708/match0-0.html#4" target="0"><img src="./tm_4_11.gif" alt="other" border="0" align="left"></a>

                    diffAB-&gt;nnz -= 1;
                }
                moveNext(rowA);
                moveNext(rowB);
            }else if (E_A-&gt;index &lt; E_B-&gt;index){
                append(diffAB-&gt;rows[i], newEntry(E_A-&gt;data, E_A-&gt;index));
                moveNext(rowA);
            }else if (E_A-&gt;index &gt; E_B-&gt;index){
                append(diffAB-&gt;rows[i], newEntry(0 - E_B-&gt;data, E_B-&gt;index));
                moveNext(rowB);
            }
            diffAB-&gt;nnz += 1;
        }
        // Append the rest Entry in rowA or rowB
        while (index(rowA) &gt;= 0){
            Entry E_A = get(rowA);
            append(diffAB-&gt;rows[i], newEntry(E_A-&gt;data, E_A-&gt;index));
            diffAB-&gt;nnz += 1;
            moveNext(rowA);
        }
        while (index(rowB) &gt;= 0){
            Entry E_B = get(rowB);
            append(diffAB-&gt;rows[i], newEntry(0 - E_B-&gt;data, E_B-&gt;index));
            diffAB-&gt;nnz += 1;
            moveNext(rowB);
        }
    }
    freeMatrix(&amp;B);
    return diffAB;
}

// Helper function
double vectorDot(List P, List Q){
    double result = 0.0;
    for(moveFront(P), moveFront(Q); index(P) &gt;= 0 &amp;&amp; index(Q) &gt;= 0; ){
        Entry p = get(P);
        Entry q = get(Q);
</font>        if(p-&gt;index == q-&gt;index){
            result += p-&gt;data * q-&gt;data;
            moveNext(P);
            moveNext(Q);
<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/6/5655424630708/match0-0.html#3" target="0"><img src="./tm_3_13.gif" alt="other" border="0" align="left"></a>

        }else if (p-&gt;index &lt; q-&gt;index){
            moveNext(P);
        }else if(p-&gt;index &gt; q-&gt;index){
            moveNext(Q);
        }
    }
    return result;
}

Matrix product(Matrix A, Matrix B){
    Matrix newB = transpose(B);
    Matrix productAB = newMatrix(size(A));
    for(int i = 1; i &lt;= size(A); i++){
        for(int j = 1; j &lt;= size(A); j++){
            // moveCursor(A-&gt;rows[i], j);
            // moveCursor(B-&gt;rows[i], j);
            // Entry aEntry = get(A-&gt;rows[i]);
            // Entry bEntry = get(B-&gt;rows[i]);
            double product = vectorDot(A-&gt;rows[i], newB-&gt;rows[j]);
            if(product != 0.0){
                append(productAB-&gt;rows[i], newEntry(product, j));
                productAB-&gt;nnz += 1;
            }
        }
    }
    freeMatrix(&amp;newB);
    return productAB;
}

// Helper function for printMatrix
void cat(FILE* out, List L){
    moveFront(L);
    while(index(L) &gt;= 0){
        Entry E = get(L);
        if(E-&gt;data != 0) fprintf(out, "(%d, %.1lf) ", E-&gt;index, E-&gt;data);
        moveNext(L);
    }
}

void printMatrix(FILE* out, Matrix M){
    for(int i = 0; i &lt;= size(M); i++){
        moveFront(M-&gt;rows[i]);
        while(index(M-&gt;rows[i]) &gt;= 0){
            if(((Entry)get(M-&gt;rows[i]))-&gt;data != 0.0){
                fprintf(out, "%d: ", i);
                cat(out, M-&gt;rows[i]);
                fprintf(out, "\n");
                break;
            }
            moveNext(M-&gt;rows[i]);
        }
    }
    fprintf(out, "\n");
</font>}</pre>



</body></html>