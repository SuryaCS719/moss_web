
<!-- saved from url=(0062)http://moss.stanford.edu/results/9/1362601866453/match1-0.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/jaddao/pa4/Matrix.c</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter25/jaddao/pa4/Matrix.c<p></p><pre>/***
* Jack Dao
* 2051991
* 2025 Winter CSE101 PA4 
* Matrix.c 
* Source file for Matrix ADT 
***/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include "Matrix.h"
#include "List.h"

<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/9/1362601866453/match1-1.html#1" target="1"><img src="./tm_1_44.gif" alt="other" border="0" align="left"></a>

typedef struct MatrixObj {
		List *rows;
		int size;
		int NNZ;
} MatrixObj;

typedef struct EntryObj {
		int column;
		double value;
} EntryObj;


Matrix newMatrix(int n) {
		if (n &lt; 0){
				printf("N cannot be less than 0.\n");
				exit(1);
		}
		Matrix M = malloc(sizeof(MatrixObj));
		M-&gt;rows = malloc((n+1) * sizeof(List));
		M-&gt;size = n;
		M-&gt;NNZ = 0;
		for (int i = 0; i &lt; n+1; i++){
				M-&gt;rows[i] = newList();
		}
		return M;
}

Entry newEntry(int column, double value) {
		if (column &lt; 0){
				printf("Column cannot be less than 0.\n");
				exit(1);
		}
		Entry c = malloc(sizeof(EntryObj));
		c-&gt;value = value;
		c-&gt;column = column;
		return c;
}


void freeEntry(Entry* pC) {
		if (pC != NULL &amp;&amp; *pC != NULL) {
				free(*pC);
				*pC = NULL;
		}
}

void freeMatrix(Matrix *pM) {
		if (pM != NULL &amp;&amp; *pM != NULL) {
				for (int i = 0; i &lt; (*pM)-&gt;size + 1; i++){
						List row = ((*pM)-&gt;rows[i]);
						if (row == NULL) {continue;}
						for (moveFront(row); index(row) &gt;= 0; moveNext(row)) {
								Entry c = get(row);
								freeEntry(&amp;c);
						}
						freeList(&amp;(*pM)-&gt;rows[i]);
				}
				free((*pM)-&gt;rows);
				free(*pM);
				*pM = NULL;
		}		
}

int size(Matrix M) {
		if (M == NULL) {
				exit(1);
		}
		return M-&gt;size;
}

int NNZ(Matrix M) {
		if (M == NULL) {
				printf("M is NULL\n");
				exit(1);
		}
		int count = 0;
		for (int i = 0; i &lt; M-&gt;size; i++) {
				count += length(M-&gt;rows[i]);
		}
		return count;
}

int equals(Matrix A, Matrix B) {
		if (A == NULL || B == NULL){
				printf("Either A or B is NULL\n");
				exit(1);
		}
		if (A-&gt;size != B-&gt;size) {
				return 0;
		}
		for (int i = 0; i &lt; A-&gt;size; i++) {

				moveFront(A-&gt;rows[i]);
				moveFront(B-&gt;rows[i]);
				if (length(A-&gt;rows[i]) != length(B-&gt;rows[i])){
						return 0;
				}
				while(index(A-&gt;rows[i]) &gt;= 0){
						Entry c1 = (Entry)get(A-&gt;rows[i]);
						Entry c2 = (Entry)get(B-&gt;rows[i]);
						if (c1-&gt;value != c2-&gt;value){
								return 0;
						}
						moveNext(A-&gt;rows[i]);
						moveNext(B-&gt;rows[i]);
				}
		}
		return 1;

}

void makeZero(Matrix M) {
		if (M == NULL){
				printf("M is null\n");
				exit(1);
		}
		for (int i = 0; i &lt; M-&gt;size; i++) {
				List row = M-&gt;rows[i];
				for (moveFront(row); index(row) &gt;= 0; moveNext(row)){
						Entry c = get(row);
						freeEntry(&amp;c);
				}
				freeList(&amp;row);
				M-&gt;rows[i] = newList();
		}
}


int exists(Matrix M, int i, int j) {
		if ((i &gt; M-&gt;size || i &lt;= 0) || (j &gt; M-&gt;size || j &lt;= 0)){
				printf("Invalid (i, j)\n");

exit(1);
		}
		if (length(M-&gt;rows[i-1]) != 0) {
				moveFront(M-&gt;rows[i-1]);
				while (index(M-&gt;rows[i-1]) &gt;= 0){
						Entry current = get(M-&gt;rows[i-1]);
						if (current-&gt;column == j){
								return index(M-&gt;rows[i-1]);
						}
						moveNext(M-&gt;rows[i-1]);
				}
		}
		return -1;
}

void changeEntry(Matrix M, int i, int j, double x) {
		if (M == NULL){
				printf("M is null\n");
				exit(1);
		}
		if ((i &gt; M-&gt;size || i &lt;= 0) || (j &gt; M-&gt;size || j &lt;= 0)) {
				printf("Invalid (i, j)\n");
				exit(1);
		}
		List row = M-&gt;rows[i-1];
		if (x != 0){
				Entry c = newEntry(j, x);
				
				if (length(row) == 0) {
						append(row, c);
				} else {
						for (moveFront(row); index(row) &gt;= 0; moveNext(row)) {
								Entry current = (Entry)get(row);
								if (j == current-&gt;column) {
										insertBefore(row, c);
										freeEntry(¤t);
										delete(row);
								} else if (j &lt; current-&gt;column) {
										insertBefore(row, c);
										break;
								} else if (index(row) == length(row) - 1){
										append(row, c);
										break;
								}
						}
				} M-&gt;NNZ++;
		}
		else {
				for (moveFront(row); index(row) &gt;= 0; moveNext(row)) {
						Entry current = (Entry)get(row);
						if (current-&gt;column == j) {
								freeEntry(¤t);
								delete(row);
								M-&gt;NNZ--;
								break;
						}
				}
		}
		return;

}

Matrix copy(Matrix A) {
		Matrix N = newMatrix(A-&gt;size);
		for (int i = 0; i &lt; A-&gt;size; i++) {
				for (moveFront(A-&gt;rows[i]); index(A-&gt;rows[i]) &gt;= 0; moveNext(A-&gt;rows[i])) {
</font><a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/9/1362601866453/match1-1.html#2" target="1"><img src="./tm_2_4.gif" alt="other" border="0" align="left"></a>

						Entry current = (Entry)get(A-&gt;rows[i]);
						Entry c = newEntry(current-&gt;column, current-&gt;value);
						append(N-&gt;rows[i], c);
						N-&gt;NNZ += 1;
						if (N-&gt;NNZ == A-&gt;NNZ) {
								return N;
						}
				}
		}
		return N;
}

Matrix transpose(Matrix A) {
		Matrix M = newMatrix(A-&gt;size);
		for (int i = 0; i &lt; A-&gt;size; i++) { 
				for (moveFront(A-&gt;rows[i]); index(A-&gt;rows[i]) &gt;= 0; moveNext(A-&gt;rows[i])) {
</font><a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/9/1362601866453/match1-1.html#0" target="1"><img src="./tm_0_48.gif" alt="other" border="0" align="left"></a>

						Entry current = (Entry)get(A-&gt;rows[i]);
						int currentColumn = current-&gt;column;
						changeEntry(M, currentColumn, i+1, current-&gt;value);
				}
		}
		return M;
}

Matrix scalarMult(double x, Matrix A) {
		Matrix M = newMatrix(A-&gt;size);
		for (int i = 0; i &lt; A-&gt;size; i++){
				for (moveFront(A-&gt;rows[i]); index(A-&gt;rows[i]) &gt;= 0; moveNext(A-&gt;rows[i])) {
						Entry current = (Entry)get(A-&gt;rows[i]);
						changeEntry(M, i+1, current-&gt;column, current-&gt;value * x);
						if (NNZ(A) == M-&gt;NNZ) {
								return M;
						}
				}
		}
		return M;
}


List oper(List P, List Q, bool add) {
		List L = newList();
		moveFront(P);
		moveFront(Q);
		while(index(P) &gt;= 0 || index(Q) &gt;= 0) {
				if (index(P) &gt;= 0 &amp;&amp; index(Q) &gt;= 0) {
						Entry a = (Entry) get(P);
						Entry b = (Entry) get(Q);
						if (a-&gt;column &gt; b-&gt;column){
								append(L, newEntry(b-&gt;column, (add ? 1.0 : -1.0) * b-&gt;value));
								moveNext(Q);
						} else if (a-&gt;column &lt; b-&gt;column) {
								append(L, newEntry(a-&gt;column, a-&gt;value));
								moveNext(P);
						} else if (a-&gt;column == b-&gt;column) {
								if ((add &amp;&amp; a-&gt;value + b-&gt;value != 0) || (!add &amp;&amp; a-&gt;value - b-&gt;value != 0)) {
										append(L, newEntry(a-&gt;column, (add ? a-&gt;value + b-&gt;value : a-&gt;value - b-&gt;value)));
								}
								moveNext(P);
								moveNext(Q);
						}
				} else if (index(P) &gt;= 0) {
						Entry a = (Entry) get(P);
						append(L, newEntry(a-&gt;column, a-&gt;value));
						moveNext(P);
				} else {
						Entry b = (Entry) get(Q);
						append(L, newEntry(b-&gt;column, (add ? 1.0 : -1.0) * b-&gt;value));
						moveNext(Q);
				}
		}
		return L;
}



Matrix sum(Matrix A, Matrix B) {
		if (A == NULL || B == NULL){
				printf("A and/or B are NULL.\n");
				exit(1);
		}
		if (A-&gt;size != B-&gt;size){
				printf("A and B are different sizes.\n");
				exit(1);
		}

		if (A == B || equals(A, B)){
				return scalarMult(2, A);
		}
		Matrix M = malloc(sizeof(MatrixObj));
		M-&gt;rows = malloc((A-&gt;size+1) * sizeof(List));
		M-&gt;size = A-&gt;size;
		M-&gt;NNZ = 0;
		for (int i = 0; i &lt; A-&gt;size+1; i++)
		{
				M-&gt;rows[i] = oper(A-&gt;rows[i], B-&gt;rows[i], true);
		}
		return M;
		
}

Matrix diff(Matrix A, Matrix B) {
		if (A == NULL || B == NULL) {
				printf("A and/or B are null.\n");
				exit(1);
		}
		if (A-&gt;size != B-&gt;size){
				printf("A and B are different sizes.\n");
				exit(1);
		}
		Matrix M = malloc(sizeof(MatrixObj));
		M-&gt;rows = malloc((A-&gt;size+1) * sizeof(List));
		M-&gt;size = A-&gt;size;
		M-&gt;NNZ = 0;

		for (int i = 0; i &lt; A-&gt;size+1; i++) {
				M-&gt;rows[i] = oper(A-&gt;rows[i], B-&gt;rows[i], false);
		}
		return M;

}

Matrix product(Matrix A, Matrix B) {
		if (A == NULL || B == NULL) {
				printf("A and/or B are NULL.\n");
				exit(1);
		}
		if (A-&gt;size != B-&gt;size) {
				printf("A and B are different sizes.\n");
				exit(1);
		}

		Matrix T = transpose(B);
		Matrix M = newMatrix(A-&gt;size);

		for (int i = 0; i &lt; A-&gt;size; i++){
				List row = A-&gt;rows[i];
				if (length(row) != 0) {
						for (int j =0; j &lt; T-&gt;size; j++) {
								List row2 = T-&gt;rows[j];
								if (length(row2) != 0) {
										double dp = vectorDot(row, row2);
										changeEntry(M, i+1, j+1, dp);
								}
						}
				}
		}
		freeMatrix(&amp;T);
		return M;
}

void printMatrix(FILE* out, Matrix M) {
		for (int i = 0; i &lt; M-&gt;size; i++) {
				List row = M-&gt;rows[i];
				if (length(row) == 0) {
						continue;
				}
				fprintf(out, "%d: ", i+1);
				for (moveFront(row); index(row) &gt;= 0; moveNext(row)) {
							Entry current = (Entry)get(row);
							fprintf(out, "(%d, %0.1f) ", current-&gt;column, current-&gt;value);
				}
				fprintf(out, "\n");
		}
}

double vectorDot(List P, List Q){
		double dotProduct = 0;
		for (moveFront(P); index(P) &gt;= 0; moveNext(P)) {
				Entry pC = (Entry)get(P);
				for (moveFront(Q); index(Q) &gt;= 0; moveNext(Q)) {
						Entry qC = (Entry)get(Q);
						if (pC-&gt;column == qC-&gt;column) {
								dotProduct += pC-&gt;value * qC-&gt;value;
								break;
						}
				}
		}
		return dotProduct;
</font>}
</pre>



</body></html>