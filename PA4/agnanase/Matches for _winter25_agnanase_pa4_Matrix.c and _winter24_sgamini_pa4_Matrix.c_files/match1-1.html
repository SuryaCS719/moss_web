
<!-- saved from url=(0063)http://moss.stanford.edu/results/1/337524917881/match1-1.html#2 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/agnanase/pa4/Matrix.c</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter24/sgamini/pa4/Matrix.c<p></p><pre>//-----------------------------------------------------------------------------
// Name: Sasank Gamini
// CruzID: sgamini
// Assignment: pa4
// File: Matrix.c
// Source file for Matrix ADT
//-----------------------------------------------------------------------------
#include "Matrix.h"

typedef struct EntryObj {
    int column;
    double value;
} EntryObj;
typedef EntryObj* Entry;

// MatrixObj definition
typedef struct MatrixObj {
    int size;
    int nnz;
    List* rows;
} MatrixObj;


//Constructors and Destructors for Structs -----------------------------------------------
// newEntry()
// constructor for Entry type
Entry newEntry(int c, double v) {
    Entry E = malloc(sizeof(EntryObj));
    E-&gt;column = c;
    E-&gt;value = v;
    return E;
}

// freeEntry()
// destructor for Entry type
void freeEntry(Entry* pE) {
    if (pE != NULL &amp;&amp; *pE != NULL) {
        free(*pE);
        *pE = NULL;
    }
}

// newMatrix()
// Returns a reference to a new nXn Matrix object in the zero state.
Matrix newMatrix(int n){
<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/1/337524917881/match1-0.html#4" target="0"><img src="./tm_4_2.gif" alt="other" border="0" align="left"></a>

    Matrix M = malloc(sizeof(MatrixObj));
    M-&gt;size = n;
    M-&gt;nnz = 0;
    M-&gt;rows = malloc(n * sizeof(List));
    for(int i = 0; i &lt; n; i++){
        M-&gt;rows[i] = newList();
</font>    }
    return M;
}

// freeMatrix()
// Frees heap memory associated with *pM, sets *pM to NULL.
void freeMatrix(Matrix* pM){
    if (pM != NULL &amp;&amp; *pM != NULL) {
        for (int i = 0; i &lt; (*pM)-&gt;size; i++) {
<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/1/337524917881/match1-0.html#3" target="0"><img src="./tm_3_5.gif" alt="other" border="0" align="left"></a>

            List row = (*pM)-&gt;rows[i];
            moveFront(row);
            while(index(row) &gt;= 0){
                Entry E = (Entry)get(row);
                freeEntry(&amp;E);
                moveNext(row);
            }
            clear(row);
            freeList(&amp;row);
        }
    }
    free((*pM)-&gt;rows);
    free(*pM);
    *pM = NULL;
}



// Access functions ------------------------------------------------------------------
// size()
// Return the size of square Matrix M.
int size(Matrix M){
    return M-&gt;size;
}

// NNZ()
// Return the number of non-zero elements in M.
int NNZ(Matrix M){
    return M-&gt;nnz;
}

// equals()
// Return true (1) if matrices A and B are equal, false (0) otherwise.
int equals(Matrix A, Matrix B){
    if(size(A) != size(B)){
        return 0;
    }
    for(int i = 0; i &lt; size(A); i++){
        List rowA = A-&gt;rows[i];
</font>        List rowB = B-&gt;rows[i];
        if(length(rowA) != length(rowB)){
            return 0;
        }
        moveFront(rowA);
        moveFront(rowB);
        while(index(rowA) &gt;= 0 &amp;&amp; index(rowB) &gt;= 0){
            Entry EA = (Entry)get(rowA);
            Entry EB = (Entry)get(rowB);

<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/1/337524917881/match1-0.html#1" target="0"><img src="./tm_1_14.gif" alt="other" border="0" align="left"></a>

            if(EA-&gt;column != EB-&gt;column || EA-&gt;value != EB-&gt;value){
                return 0;
            }

            moveNext(rowA);
            moveNext(rowB);
        }
    }
    return 1;

}



// Manipulation procedures ----------------------------------------------------
// makeZero()
// Re-sets M to the zero Matrix state.
void makeZero(Matrix M){
    for(int i = 0; i &lt; size(M); i++){
        List row = M-&gt;rows[i];
        moveFront(row);
        while(index(row) &gt;= 0){
            Entry E = (Entry)get(row);
            freeEntry(&amp;E);
            moveNext(row);
        }
        clear(M-&gt;rows[i]);
    }
    M-&gt;nnz = 0;
}

// changeEntry()
// Changes the ith row, jth column of M to the value x.
// Pre: 1&lt;=i&lt;=size(M), 1&lt;=j&lt;=size(M)
void changeEntry(Matrix M, int i, int j, double x){
    //check pre
    if((1 &lt;= i &amp;&amp; i &lt;= size(M)) &amp;&amp; (1 &lt;= j  &amp;&amp; j &lt;= size(M))){
        List row = M-&gt;rows[i-1];
        moveFront(row);
        while(index(row) &gt;= 0){
            Entry E = (Entry)get(row);
            //if the element to replace is a non zero entry
            if(E-&gt;column == j) {
                if(x == 0.0) {
                    freeEntry(&amp;E);
                    delete(row);
                    M-&gt;nnz--;
                } 
                else {
                    E-&gt;value = x;
                }
                return;
            }
            //if the element to replace is a zero and it is not at the end, 
            //need to create a new list element entry before
            else if(E-&gt;column &gt; j) {
                if (x != 0.0){
                    insertBefore(row, newEntry(j, x));
                    M-&gt;nnz++;
                    return;
                }
            }
            moveNext(row);
        }
        //if it doesn't go through any of the conditions above, then the row is all zero elements,
        //or the last element in the row is a zero
        if(x != 0.0){
            append(row, newEntry(j, x));
            M-&gt;nnz++;
        }
    }
}



// Matrix Arithmetic operations -------------------------------------------------
// copy()
// Returns a reference to a new Matrix object having the same entries as A.
Matrix copy(Matrix A){
    Matrix copy = newMatrix(size(A));
    for(int i = 0; i &lt; size(A); i++){
        List row = A-&gt;rows[i];
</font>        moveFront(row);
        while(index(row) &gt;= 0){
            Entry E = (Entry)get(row);
            //changeEntry(Matrix M, int i, int j, double x)
<a name="5"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/1/337524917881/match1-0.html#5" target="0"><img src="./tm_0_2.gif" alt="other" border="0" align="left"></a>

            changeEntry(copy, i+1, E-&gt;column, E-&gt;value);
            moveNext(row);
        }
    }
    return copy;
}

// transpose()
// Returns a reference to a new Matrix object representing the transpose
// of A.
Matrix transpose(Matrix A){
    Matrix transpose = newMatrix(size(A));
    for(int i = 0; i &lt; size(A); i++){
        List row = A-&gt;rows[i];
</font>        moveFront(row);
        while(index(row) &gt;= 0){
            Entry E = (Entry)get(row);
<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/1/337524917881/match1-0.html#0" target="0"><img src="./tm_0_43.gif" alt="other" border="0" align="left"></a>

            changeEntry(transpose, E-&gt;column, i+1, E-&gt;value);
            moveNext(row);
        }
    }
    return transpose;
}
// scalarMult()
// Returns a reference to a new Matrix object representing xA.
Matrix scalarMult(double x, Matrix A){
    Matrix scalar = newMatrix(size(A));
    for(int i = 0; i &lt; size(A); i++){
        List row = A-&gt;rows[i];
        moveFront(row);
        while(index(row) &gt;= 0){
            Entry E = (Entry)get(row);
            changeEntry(scalar, i+1, E-&gt;column, (x*E-&gt;value));
            moveNext(row);
        }
    }
    return scalar;

}

//sum helper fn
void add(List L1, List L2, List* S){
    moveFront(L1);
    moveFront(L2);
    while(index(L1) &gt;= 0 &amp;&amp; index(L2) &gt;= 0){
        Entry E1 = (Entry)get(L1);
        Entry E2 = (Entry)get(L2);
        if(E1-&gt;column &lt; E2-&gt;column){
            append(*S, newEntry(E1-&gt;column, E1-&gt;value));
            moveNext(L1);
        }
        else if(E2-&gt;column &lt; E1-&gt;column){
            append(*S, newEntry(E2-&gt;column, E2-&gt;value));
            moveNext(L2);
        }
        else{
            if((E2-&gt;value + E1-&gt;value) != 0){
                append(*S, newEntry(E2-&gt;column, (E2-&gt;value + E1-&gt;value)));
            }
            moveNext(L1);
            moveNext(L2);
        }
    }
    while(index(L1) &gt;= 0){
        Entry E1 = (Entry)get(L1);
        append(*S, newEntry(E1-&gt;column, E1-&gt;value));
        moveNext(L1);
    }
    while(index(L2) &gt;= 0){
        Entry E2 = (Entry)get(L2);
        append(*S, newEntry(E2-&gt;column, E2-&gt;value));
        moveNext(L2);
    }
}
// sum()
// Returns a reference to a new Matrix object representing A+B.
// pre: size(A)==size(B)
Matrix sum(Matrix A, Matrix B){
    if(size(A) == size(B)){
        //if its the same matrix passed twice
        Matrix Bcopy;
        if(A == B){
            Bcopy = copy(B);
        }
        List rowB;
        Matrix sum = newMatrix(size(A));
        for(int i = 0; i &lt; size(A); i++){
            List rowA = A-&gt;rows[i];
            if(A == B){
                rowB = Bcopy-&gt;rows[i];
            }
            else{
                rowB = B-&gt;rows[i];
            }
            List rowSum = sum-&gt;rows[i];
            add(rowA, rowB, &amp;rowSum);
            sum-&gt;nnz += length(rowSum);
            //printMatrix(stdout, sum);
            //printList(stdout, rowSum);
            //printf("NNZ: %d\n", NNZ(sum));

        }
        if(A == B){
            freeMatrix(&amp;Bcopy);
        }
        return sum;
    }
    else{
        fprintf(stderr, "Error: calling sum() on Matrices that are not the same size\n");
        exit(1);
    }
}

//diff helper fn
void subtract(List L1, List L2, List* S){
    moveFront(L1);
    moveFront(L2);
    while(index(L1) &gt;= 0 &amp;&amp; index(L2) &gt;= 0){
        Entry E1 = (Entry)get(L1);
        Entry E2 = (Entry)get(L2);
        if(E1-&gt;column &lt; E2-&gt;column){
            append(*S, newEntry(E1-&gt;column, E1-&gt;value));
            moveNext(L1);
        }
        else if(E2-&gt;column &lt; E1-&gt;column){
            append(*S, newEntry(E2-&gt;column, (-1 * E2-&gt;value)));
            moveNext(L2);
        }
        else{
            if((E1-&gt;value - E2-&gt;value) != 0){
                append(*S, newEntry(E2-&gt;column, (E1-&gt;value - E2-&gt;value)));
            }
            moveNext(L1);
            moveNext(L2);
        }
    }
    while(index(L1) &gt;= 0){
        Entry E1 = (Entry)get(L1);
        append(*S, newEntry(E1-&gt;column, E1-&gt;value));
        moveNext(L1);
    }
    while(index(L2) &gt;= 0){
        Entry E2 = (Entry)get(L2);
        append(*S, newEntry(E2-&gt;column, (-1 * E2-&gt;value)));
        moveNext(L2);
    }
}
// diff()
// Returns a reference to a new Matrix object representing A-B.
// pre: size(A)==size(B)
Matrix diff(Matrix A, Matrix B){
    if(size(A) == size(B)){
        Matrix diff = newMatrix(size(A));
        for(int i = 0; i &lt; size(A); i++){
            List rowA = A-&gt;rows[i];
            List rowB = B-&gt;rows[i];
            List rowDiff = diff-&gt;rows[i];
            subtract(rowA, rowB, &amp;rowDiff);
            diff-&gt;nnz += length(rowDiff);
        }
        return diff;
    }
    else{
        fprintf(stderr, "Error: calling diff() on Matrices that are not the same size\n");
        exit(1);
    }
}

//product helper fn
double vectorDot(List L1, List L2){
    double dot = 0.0;
    moveFront(L1);
    moveFront(L2);
    while(index(L1) &gt;= 0 &amp;&amp; index(L2) &gt;= 0){
</font>        Entry E1 = (Entry)get(L1);
        Entry E2 = (Entry)get(L2);
        if(E1-&gt;column &lt; E2-&gt;column){
            moveNext(L1);
        }
        else if(E2-&gt;column &lt; E1-&gt;column){
            moveNext(L2);
        }
        else{
<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/1/337524917881/match1-0.html#2" target="0"><img src="./tm_2_11.gif" alt="other" border="0" align="left"></a>

            dot += (E1-&gt;value * E2-&gt;value);
            moveNext(L1);
            moveNext(L2);
        }
    }
    return dot;
}
// product()
// Returns a reference to a new Matrix object representing AB
// pre: size(A)==size(B)
Matrix product(Matrix A, Matrix B){
    if(size(A) != size(B)){
        fprintf(stderr, "Error: calling product() on Matrices that are not the same size\n");
        exit(1);
    }

    Matrix product = newMatrix(size(A));
    Matrix BT = transpose(B);
    for(int i = 0; i &lt; size(A); i++){
        List rowA = A-&gt;rows[i];
        for(int j = 0; j &lt; size(BT); j++){
            List rowBT = BT-&gt;rows[j];
            double pval = vectorDot(rowA, rowBT);
            changeEntry(product, i+1, j+1, pval);
        }
    }
    //freeing BT
    makeZero(BT);
    freeMatrix(&amp;BT);
    return product;
}

// printMatrix()
// Prints a string representation of Matrix M to filestream out. Zero rows
// are not printed. Each non-zero row is represented as one line consisting
// of the row number, followed by a colon, a space, then a space separated
// list of pairs "(col, val)" giving the column numbers and non-zero values
// in that row. The double val will be rounded to 1 decimal point.
void printMatrix(FILE* out, Matrix M){
    for (int i = 0; i &lt; size(M); i++) {
        List row = M-&gt;rows[i];
        //if row is empty skip iteration
        if (length(row) == 0){
            continue;
        }

        fprintf(out, "%d: ", i+1);
        //printing each entry in the row
        moveFront(row);
        while (index(row) &gt;= 0) {
            Entry E = (Entry)get(row);
            fprintf(out, "(%d, %.1f) ", E-&gt;column, E-&gt;value);
</font>            moveNext(row);
        }
        fprintf(out, "\n");
    }
}</pre>



</body></html>