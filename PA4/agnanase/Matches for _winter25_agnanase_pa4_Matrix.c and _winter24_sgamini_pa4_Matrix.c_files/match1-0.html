
<!-- saved from url=(0063)http://moss.stanford.edu/results/1/337524917881/match1-0.html#1 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/agnanase/pa4/Matrix.c</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter25/agnanase/pa4/Matrix.c<p></p><pre>/***
* Arti Gnanasekar
* agnanase 
* 2025 Fall CSE101 PA4  
* Matrix.c
* implements the functions present in Matrix.h to develop sparsing matrix
***/ 

#include "Matrix.h"

typedef struct EntryObj {
    int column;
    double value;
} EntryObj;
typedef EntryObj* Entry;

// MatrixObj definition
typedef struct MatrixObj {
    int size;
    int nnz;
    List* rows;
} MatrixObj;


/*** Constructors-Destructors ***/
// creates a new entry and is a contructor for the new entry type
Entry newEntry(int c, double v) {
    Entry E = malloc(sizeof(EntryObj));
    E-&gt;column = c;
    E-&gt;value = v;
    return E;
}

// frees entry and is a deconstructor for the entry type
void freeEntry(Entry* pE) {
    if (pE != NULL &amp;&amp; *pE != NULL) {
        free(*pE);
        *pE = NULL;
    }
}

//returns a new reference for a matrix that is nxn in a zero state. 
Matrix newMatrix(int n){
<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/1/337524917881/match1-1.html#4" target="1"><img src="./tm_4_2.gif" alt="other" border="0" align="left"></a>

    Matrix M = malloc(sizeof(MatrixObj));
    M-&gt;size = n;
    M-&gt;nnz = 0;
    M-&gt;rows = malloc(n * sizeof(List));
    for(int i = 0; i &lt; n; i++){
        M-&gt;rows[i] = newList();
</font>    }
    return M;
}

// Frees heap memory associated with *pM, sets *pM to NULL for the freeMatrix
void freeMatrix(Matrix* pM){
    if (pM != NULL &amp;&amp; *pM != NULL) {
        for (int i = 0; i &lt; (*pM)-&gt;size; i++) {
<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/1/337524917881/match1-1.html#3" target="1"><img src="./tm_3_5.gif" alt="other" border="0" align="left"></a>

            List row = (*pM)-&gt;rows[i];
            moveFront(row);
            while(index(row) &gt;= 0){
                Entry E = (Entry)get(row);
                freeEntry(&amp;E);
                moveNext(row);
            }
            clear(row);
            freeList(&amp;row);
        }
    }
    free((*pM)-&gt;rows);
    free(*pM);
    *pM = NULL;
}

/*** Access Functions ***/
//returns the size of the square Matrix M
int size(Matrix M){
    return M-&gt;size;
}


//returns the number of non-zero elements in M - NNZ
int NNZ(Matrix M){
    return M-&gt;nnz;
}

// return true if matrices A and B are equal, false otherwise (true is 1 and false is 0)
int equals(Matrix A, Matrix B){
    if(size(A) != size(B)){
        return 0;
    }
    for(int i = 0; i &lt; size(A); i++){
        List rowA = A-&gt;rows[i];
</font>        List rowB = B-&gt;rows[i];
        if(length(rowA) != length(rowB)){
            return 0;
        }
        moveFront(rowA);
        moveFront(rowB);
        while(index(rowA) &gt;= 0 &amp;&amp; index(rowB) &gt;= 0){
            Entry EA = (Entry)get(rowA);
            Entry EB = (Entry)get(rowB);

<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/1/337524917881/match1-1.html#1" target="1"><img src="./tm_1_14.gif" alt="other" border="0" align="left"></a>

            if(EA-&gt;column != EB-&gt;column || EA-&gt;value != EB-&gt;value){
                return 0;
            }

            moveNext(rowA);
            moveNext(rowB);
        }
    }
    return 1;

}

/*** Manipulation Structures ***/
// re-establishes M to the 0 matrix state 
void makeZero(Matrix M){
    for(int i = 0; i &lt; size(M); i++){
        List row = M-&gt;rows[i];
        moveFront(row);
        while(index(row) &gt;= 0){
            Entry E = (Entry)get(row);
            freeEntry(&amp;E);
            moveNext(row);
        }
        clear(M-&gt;rows[i]);
    }
    M-&gt;nnz = 0;
}

//changes a specific row (i) and a specific column (j) of the matrix M to the certain value (x)
//precondition:  1&lt;=i&lt;=size(M), 1&lt;=j&lt;=size(M)
void changeEntry(Matrix M, int i, int j, double x){
    //check pre
    if((1 &lt;= i &amp;&amp; i &lt;= size(M)) &amp;&amp; (1 &lt;= j  &amp;&amp; j &lt;= size(M))){
        List row = M-&gt;rows[i-1];
        moveFront(row);
        while(index(row) &gt;= 0){
            Entry E = (Entry)get(row);
            //if the element to replace is a non zero entry
            if(E-&gt;column == j) {
                if(x == 0.0) {
                    freeEntry(&amp;E);
                    delete(row);
                    M-&gt;nnz--;
                } 
                else {
                    E-&gt;value = x;
                }
                return;
            }
            //if the element to replace is a zero and it is not at the end, 
            //need to create a new list element entry before
            else if(E-&gt;column &gt; j) {
                if (x != 0.0){
                    insertBefore(row, newEntry(j, x));
                    M-&gt;nnz++;
                    return;
                }
            }
            moveNext(row);
        }
        //if it doesn't go through any of the conditions above, then the row is all zero elements,
        //or the last element in the row is a zero
        if(x != 0.0){
            append(row, newEntry(j, x));
            M-&gt;nnz++;
        }
    }
}

/*** Matrix Arithmetic Structures ***/

//returns a reference to a new Matrix Object having the same enteries as A
Matrix copy(Matrix A){
    Matrix copy = newMatrix(size(A));
    for(int i = 0; i &lt; size(A); i++){
        List row = A-&gt;rows[i];
</font>        moveFront(row);
        while(index(row) &gt;= 0){
            Entry E = (Entry)get(row);
            //changeEntry(Matrix M, int i, int j, double x)
<a name="5"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/1/337524917881/match1-1.html#5" target="1"><img src="./tm_0_2.gif" alt="other" border="0" align="left"></a>

            changeEntry(copy, i+1, E-&gt;column, E-&gt;value);
            moveNext(row);
        }
    }
    return copy;
}
// transpose function returns a reference to a new Matrix object representing the transpose of matrix A
Matrix transpose(Matrix A){
    Matrix transpose = newMatrix(size(A));
    for(int i = 0; i &lt; size(A); i++){
        List row = A-&gt;rows[i];
</font>        moveFront(row);
        while(index(row) &gt;= 0){
            Entry E = (Entry)get(row);
<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/1/337524917881/match1-1.html#0" target="1"><img src="./tm_0_43.gif" alt="other" border="0" align="left"></a>

            changeEntry(transpose, E-&gt;column, i+1, E-&gt;value);
            moveNext(row);
        }
    }
    return transpose;
}
// scalar mulitplication function returns a reference to a new Matrix object representing xA.
Matrix scalarMult(double x, Matrix A){
    Matrix scalar = newMatrix(size(A));
    for(int i = 0; i &lt; size(A); i++){
        List row = A-&gt;rows[i];
        moveFront(row);
        while(index(row) &gt;= 0){
            Entry E = (Entry)get(row);
            changeEntry(scalar, i+1, E-&gt;column, (x*E-&gt;value));
            moveNext(row);
        }
    }
    return scalar;

}

//sum function
void add(List L1, List L2, List* S){
    moveFront(L1);
    moveFront(L2);
    while(index(L1) &gt;= 0 &amp;&amp; index(L2) &gt;= 0){
        Entry E1 = (Entry)get(L1);
        Entry E2 = (Entry)get(L2);
        if(E1-&gt;column &lt; E2-&gt;column){
            append(*S, newEntry(E1-&gt;column, E1-&gt;value));
            moveNext(L1);
        }
        else if(E2-&gt;column &lt; E1-&gt;column){
            append(*S, newEntry(E2-&gt;column, E2-&gt;value));
            moveNext(L2);
        }
        else{
            if((E2-&gt;value + E1-&gt;value) != 0){
                append(*S, newEntry(E2-&gt;column, (E2-&gt;value + E1-&gt;value)));
            }
            moveNext(L1);
            moveNext(L2);
        }
    }
    while(index(L1) &gt;= 0){
        Entry E1 = (Entry)get(L1);
        append(*S, newEntry(E1-&gt;column, E1-&gt;value));
        moveNext(L1);
    }
    while(index(L2) &gt;= 0){
        Entry E2 = (Entry)get(L2);
        append(*S, newEntry(E2-&gt;column, E2-&gt;value));
        moveNext(L2);
    }
}
// sum function returns a reference to a new Matrix object representing A+B.
// precondition: size(A)==size(B)
Matrix sum(Matrix A, Matrix B){
    if(size(A) == size(B)){
        //if its the same matrix passed twice
        Matrix Bcopy;
        if(A == B){
            Bcopy = copy(B);
        }
        List rowB;
        Matrix sum = newMatrix(size(A));
        for(int i = 0; i &lt; size(A); i++){
            List rowA = A-&gt;rows[i];
            if(A == B){
                rowB = Bcopy-&gt;rows[i];
            }
            else{
                rowB = B-&gt;rows[i];
            }
            List rowSum = sum-&gt;rows[i];
            add(rowA, rowB, &amp;rowSum);
            sum-&gt;nnz += length(rowSum);

        }
        if(A == B){
            freeMatrix(&amp;Bcopy);
        }
        return sum;
    }
    else{
        fprintf(stderr, "Error: calling sum() on Matrices that are not the same size\n");
        exit(1);
    }
}

//difference function
void subtract(List L1, List L2, List* S){
    moveFront(L1);
    moveFront(L2);
    while(index(L1) &gt;= 0 &amp;&amp; index(L2) &gt;= 0){
        Entry E1 = (Entry)get(L1);
        Entry E2 = (Entry)get(L2);
        if(E1-&gt;column &lt; E2-&gt;column){
            append(*S, newEntry(E1-&gt;column, E1-&gt;value));
            moveNext(L1);
        }
        else if(E2-&gt;column &lt; E1-&gt;column){
            append(*S, newEntry(E2-&gt;column, (-1 * E2-&gt;value)));
            moveNext(L2);
        }
        else{
            if((E1-&gt;value - E2-&gt;value) != 0){
                append(*S, newEntry(E2-&gt;column, (E1-&gt;value - E2-&gt;value)));
            }
            moveNext(L1);
            moveNext(L2);
        }
    }
    while(index(L1) &gt;= 0){
        Entry E1 = (Entry)get(L1);
        append(*S, newEntry(E1-&gt;column, E1-&gt;value));
        moveNext(L1);
    }
    while(index(L2) &gt;= 0){
        Entry E2 = (Entry)get(L2);
        append(*S, newEntry(E2-&gt;column, (-1 * E2-&gt;value)));
        moveNext(L2);
    }
}
// difference function which returns a reference to a new Matrix object representing A-B.
// precondition: size(A)==size(B)
Matrix diff(Matrix A, Matrix B){
    if(size(A) == size(B)){
        Matrix diff = newMatrix(size(A));
        for(int i = 0; i &lt; size(A); i++){
            List rowA = A-&gt;rows[i];
            List rowB = B-&gt;rows[i];
            List rowDiff = diff-&gt;rows[i];
            subtract(rowA, rowB, &amp;rowDiff);
            diff-&gt;nnz += length(rowDiff);
        }
        return diff;
    }
    else{
        fprintf(stderr, "Error: calling diff() on Matrices that are not the same size\n");
        exit(1);
    }
}

// product function
double vectorDot(List L1, List L2){
    double dot = 0.0;
    moveFront(L1);
    moveFront(L2);
    while(index(L1) &gt;= 0 &amp;&amp; index(L2) &gt;= 0){
</font>        Entry E1 = (Entry)get(L1);
        Entry E2 = (Entry)get(L2);
        if(E1-&gt;column &lt; E2-&gt;column){
            moveNext(L1);
        }
        else if(E2-&gt;column &lt; E1-&gt;column){
            moveNext(L2);
        }
        else{
<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/1/337524917881/match1-1.html#2" target="1"><img src="./tm_2_11.gif" alt="other" border="0" align="left"></a>

            dot += (E1-&gt;value * E2-&gt;value);
            moveNext(L1);
            moveNext(L2);
        }
    }
    return dot;
}
// returns a product reference to a new Matrix object representing AB
// precondition: size(A)==size(B)
Matrix product(Matrix A, Matrix B){
    if(size(A) != size(B)){
        fprintf(stderr, "Error: calling product() on Matrices that are not the same size\n");
        exit(1);
    }

    Matrix product = newMatrix(size(A));
    Matrix BT = transpose(B);
    for(int i = 0; i &lt; size(A); i++){
        List rowA = A-&gt;rows[i];
        for(int j = 0; j &lt; size(BT); j++){
            List rowBT = BT-&gt;rows[j];
            double pval = vectorDot(rowA, rowBT);
            changeEntry(product, i+1, j+1, pval);
        }
    }
    //freeing BT
    makeZero(BT);
    freeMatrix(&amp;BT);
    return product;
}

void printMatrix(FILE* out, Matrix M){
    for (int i = 0; i &lt; size(M); i++) {
        List row = M-&gt;rows[i];
        //if row is empty skip iteration
        if (length(row) == 0){
            continue;
        }

        fprintf(out, "%d: ", i+1);
        //printing each entry in the row
        moveFront(row);
        while (index(row) &gt;= 0) {
            Entry E = (Entry)get(row);
            fprintf(out, "(%d, %.1f) ", E-&gt;column, E-&gt;value);
</font>            moveNext(row);
        }
        fprintf(out, "\n");
    }
}
</pre>



</body></html>