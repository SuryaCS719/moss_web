
<!-- saved from url=(0062)http://moss.stanford.edu/results/9/8328711968819/match1-0.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/aaychen/pa4/Matrix.c</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter25/aaychen/pa4/Matrix.c<p></p><pre>/***
 * Aaron Chen
 * aaychen
 * 2025 Winter CSE 101 PA4
 * Matrix.c
 * Implementation file for Matrix ADT
 ***/

#include "Matrix.h"
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;

typedef struct EntryObj *Entry;

typedef struct EntryObj {
	int col;
	double data;
} EntryObj;

typedef struct MatrixObj {
	int size;
	int nnz;
	List *row;
} MatrixObj;

Entry newEntry(int col, double data) {
	Entry E = malloc(sizeof(EntryObj));
	assert(E != NULL);
	E-&gt;col = col;
	E-&gt;data = data;
	return E;
}

void freeEntry(Entry *pE) {
	if (pE != NULL &amp;&amp; *pE != NULL) {
		free(*pE);
<a name="8"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-1.html#8" target="1"><img src="./tm_3_3.gif" alt="other" border="0" align="left"></a>

		*pE = NULL;
	}
}

// newMatrix()
// Returns a reference to a new nXn Matrix object in the zero state.
Matrix newMatrix(int n) {
	Matrix M = malloc(sizeof(MatrixObj));
	assert(M != NULL);
	M-&gt;size = n;
	M-&gt;row = calloc(n + 1, sizeof(List *));
	for (int i = 1; i &lt; n + 1; i++) {
		M-&gt;row[i] = newList();
	}
	M-&gt;nnz = 0;
	return M;
}

// freeMatrix()
// Frees heap memory associated with *pM, sets *pM to NULL.
</font><a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-1.html#3" target="1"><img src="./tm_3_13.gif" alt="other" border="0" align="left"></a>

void freeMatrix(Matrix* pM) {
	if (pM != NULL &amp;&amp; *pM != NULL) {
		makeZero(*pM);
		for (int i = 1; i &lt; size(*pM) + 1; i++) {
			freeList(&amp;((*pM)-&gt;row[i]));
		}
		free((*pM)-&gt;row);
		(*pM)-&gt;row = NULL;
		free(*pM);
		*pM = NULL;
	}
}

// Access functions
// size()
// Return the size of square Matrix M.
int size(Matrix M) {
	if (M == NULL) {
		printf("Matrix Error: calling size() on NULL Matrix.\n");
		exit(EXIT_FAILURE);
	}
	return M-&gt;size;
}

// NNZ()
// Return the number of non-zero elements in M.
int NNZ(Matrix M) {
	if (M == NULL) {
		printf("Matrix Error: calling NNZ() on NULL Matrix.\n");
		exit(EXIT_FAILURE);
	}
	return M-&gt;nnz;
}

// equals()
// Return true (1) if matrices A and B are equal, false (0) otherwise.
int equals(Matrix A, Matrix B) {
	if (A-&gt;size != B-&gt;size || A-&gt;nnz != B-&gt;nnz) {
		return 0;
	}

	if (A == NULL || B == NULL) {
		printf("Matrix Error: calling equals() on NULL Matrix.\n");
		exit(EXIT_FAILURE);
	}
	
	Entry entryA;
	Entry entryB;
	for (int i = 1; i &lt; size(A) + 1; i++) {
		moveFront(A-&gt;row[i]);
		moveFront(B-&gt;row[i]);
		while (index(A-&gt;row[i]) != -1 &amp;&amp; index(B-&gt;row[i]) != -1) {
			entryA = get(A-&gt;row[i]);
			entryB = get(B-&gt;row[i]);
			if (entryA-&gt;col != entryB-&gt;col || entryA-&gt;data != entryB-&gt;data) {
				return 0;
</font>			}
			moveNext(A-&gt;row[i]);
			moveNext(B-&gt;row[i]);
		}
	}
	return 1;
}

// Manipulation procedures
// makeZero()
// Re-sets M to the zero Matrix state.
<a name="7"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-1.html#7" target="1"><img src="./tm_2_4.gif" alt="other" border="0" align="left"></a>

void makeZero(Matrix M) {
	if (M == NULL) {
		printf("Matrix Error: calling makeZero() on NULL Matrix.\n");
		exit(EXIT_FAILURE);
	}
	Entry entry;
	for (int i = 1; i &lt; size(M) + 1; i++) {
		moveFront(M-&gt;row[i]);
		while (index(M-&gt;row[i]) != -1) {
			entry = get(M-&gt;row[i]);
			freeEntry(&amp;entry);
			moveNext(M-&gt;row[i]);
		}
		clear(M-&gt;row[i]);
	}
	M-&gt;nnz = 0;
}

// changeEntry()
// Changes the ith row, jth column of M to the value x.
// Pre: 1&lt;=i&lt;=size(M), 1&lt;=j&lt;=size(M)
</font><a name="11"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-1.html#11" target="1"><img src="./tm_1_1.gif" alt="other" border="0" align="left"></a>

void changeEntry(Matrix M, int i, int j, double x) {
	if (M == NULL) {
		printf("Matrix Error: calling changeEntry() on NULL Matrix.\n");
		exit(EXIT_FAILURE);
	}
	if (i &lt; 1 || i &gt; size(M)) {
		printf("Matrix error: calling changeEntry() with i out of range\n");
</font>		exit(EXIT_FAILURE);
	}
	if (j &lt; 1 || j &gt; size(M)) {
		printf("Matrix error: calling changeEntry() with j out of range\n");
<a name="5"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-1.html#5" target="1"><img src="./tm_0_6.gif" alt="other" border="0" align="left"></a>

		exit(EXIT_FAILURE);
	}
	List rowi = M-&gt;row[i];
	moveFront(rowi);
	Entry entry;
	Entry n;

	while (index(rowi) != -1) {
		entry = get(rowi);
		if (entry-&gt;col == j) {
			if (x == 0) {
				M-&gt;nnz--;
				freeEntry(&amp;entry);
				delete (rowi);
				return;
			} else {
				entry-&gt;data = x;
				return;
			}
		}
		if (entry-&gt;col &gt; j) {
			if (x != 0) {
				M-&gt;nnz++;
				n = newEntry(j, x);
				insertBefore(rowi, n);
			}
			return;
		}
		moveNext(rowi);
	}
	if (x != 0) {
		n = newEntry(j, x);
		append(rowi, n);
		M-&gt;nnz++;
</font>	}
}

// Matrix Arithmetic operations
// copy()
// Returns a reference to a new Matrix object having the same entries as A.
<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-1.html#1" target="1"><img src="./tm_1_14.gif" alt="other" border="0" align="left"></a>

Matrix copy(Matrix A) {
	Matrix B = newMatrix(size(A));
	Entry n;
	Entry entry;
	List rowi;
	for (int i = 1; i &lt; size(B) + 1; i++) {
		rowi = A-&gt;row[i];
		moveFront(rowi);
		while (index(rowi) != -1) {
			entry = get(rowi);
			n = newEntry(entry-&gt;col, entry-&gt;data);
			append(B-&gt;row[i], n);
			moveNext(rowi);
		}
	}
	B-&gt;nnz = A-&gt;nnz;
	return B;
}

// transpose()
// Returns a reference to a new Matrix object representing the transpose
// of A.
Matrix transpose(Matrix A) {
	Matrix B = newMatrix(size(A));
	Entry entry;
	Entry n;
	List rowi;
	for (int i = 1; i &lt; size(B) + 1; i++) {
		rowi = A-&gt;row[i];
		moveFront(rowi);
		while (index(rowi) != -1) {
			if (index(rowi) != -1) {
				entry = get(rowi);
				n = newEntry(i, entry-&gt;data);
				append(B-&gt;row[entry-&gt;col], n);
				moveNext(rowi);
			}
		}
	}
	B-&gt;nnz = A-&gt;nnz;
	return B;
}

// scalarMult()
// Returns a reference to a new Matrix object representing xA.
Matrix scalarMult(double x, Matrix A) {
	Matrix B = newMatrix(size(A));
	Entry entry;
	Entry n;
	List rowi;
	for (int i = 1; i &lt; size(B) + 1; i++) {
		rowi = A-&gt;row[i];
		moveFront(rowi);
		while (index(rowi) != -1) {
			entry = get(rowi);
			n = newEntry(entry-&gt;col, x * (entry-&gt;data));
			append(B-&gt;row[i], n);
			moveNext(rowi);
		}
	}
</font><a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-1.html#0" target="1"><img src="./tm_0_15.gif" alt="other" border="0" align="left"></a>

	B-&gt;nnz = A-&gt;nnz;
	return B;
}

// helper function for Matrix sum and Matrix diff
List sumDiff(List A, List B, int isAdd) {
	List sum = newList();
	Entry entry;
	Entry entryA;
	Entry entryB;

	moveFront(A);
	moveFront(B);

	if (length(A) == 0) {
		while (index(B) != -1) {
			entryB = get(B);
			entry = newEntry(entryB-&gt;col, isAdd * (entryB-&gt;data));
			append(sum, entry);
			moveNext(B);
		}
		return sum;
	}
	if (length(B) == 0) {
		while (index(A) != -1) {
			entryA = get(A);
			entry = newEntry(entryA-&gt;col, entryA-&gt;data);
			append(sum, entry);
			moveNext(A);
		}
		return sum;
	}

	double total = 0;
	while (index(A) != -1 &amp;&amp; index(B) != -1) {
		entryA = get(A);
		entryB = get(B);
		if (entryA-&gt;col &lt; entryB-&gt;col) {
			entry = newEntry(entryA-&gt;col, entryA-&gt;data);
			append(sum, entry);
			moveNext(A);
		} else if (entryA-&gt;col &gt; entryB-&gt;col) {
			entry = newEntry(entryB-&gt;col, isAdd * (entryB-&gt;data));
			append(sum, entry);
			moveNext(B);
		} else {
			total = entryA-&gt;data + isAdd * (entryB-&gt;data);
			if (total != 0) {
				entry = newEntry(entryA-&gt;col, total);
				append(sum, entry);
			}
			moveNext(A);
			moveNext(B);
		}
	}

	while (index(A) != -1) {
		entryA = get(A);
		entry = newEntry(entryA-&gt;col, entryA-&gt;data);
		append(sum, entry);
		moveNext(A);
	}

	while (index(B) != -1) {
		entryB = get(B);
		entry = newEntry(entryB-&gt;col, isAdd * (entryB-&gt;data));
		append(sum, entry);
		moveNext(B);
	}
	return sum;
}

// sum()
// Returns a reference to a new Matrix object representing A+B.
// pre: size(A)==size(B)
Matrix sum(Matrix A, Matrix B) {
</font><a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-1.html#2" target="1"><img src="./tm_2_13.gif" alt="other" border="0" align="left"></a>

	if (size(A) != size(B)) {
		printf("Matrix Error: calling sum() on matricies of different sizes.\n");
		exit(EXIT_FAILURE);
	}
	Matrix RH = B;
	int isDifferent = 1;
	if (equals(A, B) == 1) {
		RH = copy(B);
		isDifferent = 0;
	}
	Matrix C = newMatrix(size(A));
	for (int i = 1; i &lt; size(RH) + 1; i++) {
		freeList(&amp;(C-&gt;row[i]));
		C-&gt;row[i] = sumDiff(A-&gt;row[i], RH-&gt;row[i], 1);
		C-&gt;nnz += length(C-&gt;row[i]);
	}
	if (!isDifferent) {
		freeMatrix(&amp;RH);
	}
	return C;
}

// diff()
// Returns a reference to a new Matrix object representing A-B.
// pre: size(A)==size(B)
Matrix diff(Matrix A, Matrix B) {
	if (size(A) != size(B)) {
		printf("Matrix Error: calling diff() on matricies of different sizes.\n");
		exit(EXIT_FAILURE);
	}

	Matrix RH = B;
	int isDifferent = 1;
	if (equals(A, B) == 1) {
		RH = copy(B);
		isDifferent = 0;
	}

	Matrix C = newMatrix(size(A));
	for (int i = 1; i &lt; size(RH) + 1; i++) {
		freeList(&amp;(C-&gt;row[i]));
		C-&gt;row[i] = sumDiff(A-&gt;row[i], RH-&gt;row[i], -1);
		C-&gt;nnz += length(C-&gt;row[i]);
	}
	if (!isDifferent) {
		freeMatrix(&amp;RH);
	}
	return C;
</font>}

// helper function for Matrix product
<a name="6"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-1.html#6" target="1"><img src="./tm_1_5.gif" alt="other" border="0" align="left"></a>

double DotProd(List A, List B) {
	double sum = 0;
	if (length(A) == 0 || length(B) == 0) {
		return sum;
	}
	moveFront(A);
	moveFront(B);
	Entry entryA;
	Entry entryB;

	while (index(A) != -1 &amp;&amp; index(B) != -1) {
		entryA = get(A);
		entryB = get(B);

		if (entryA-&gt;col == entryB-&gt;col) {
			sum += entryA-&gt;data * entryB-&gt;data;
			moveNext(A);
			moveNext(B);
			continue;
		} else if (entryA-&gt;col &lt; entryB-&gt;col) {
			moveNext(A);
		} else {
</font>			moveNext(B);
		}
	}
<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-1.html#4" target="1"><img src="./tm_4_7.gif" alt="other" border="0" align="left"></a>

	return sum;
}

// product()
// Returns a reference to a new Matrix object representing AB
// pre: size(A)==size(B)
Matrix product(Matrix A, Matrix B) {
	if (size(A) != size(B)) {
		printf("Matrix Error: calling diff() on matricies of different sizes.\n");
		exit(EXIT_FAILURE);
	}
	double data;
	Entry entry;

	Matrix C = newMatrix(size(A));
	Matrix BT = transpose(B);
	for (int i = 1; i &lt; size(BT) + 1; i++) {
		if (length(BT-&gt;row[i]) != 0) {
			for (int j = 1; j &lt; size(A) + 1; j++) {
				if (length(A-&gt;row[j]) != 0) {
					data = DotProd(A-&gt;row[j], BT-&gt;row[i]);
					if (data != 0) {
						entry = newEntry(i, data);
						append(C-&gt;row[j], entry);
						C-&gt;nnz++;
					}
				}
			}
		}
	}
	freeMatrix(&amp;BT);
	return C;
}

// helper function for printMatrix
void printList(FILE *out, List L) {
</font><a name="9"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-1.html#9" target="1"><img src="./tm_4_2.gif" alt="other" border="0" align="left"></a>

	if (L == NULL) {
		printf("List Error: calling printList() on NULL List reference\n");
		exit(EXIT_FAILURE);
	}
	moveFront(L);
	Entry entry;
	while (index(L) != -1) {
		entry = get(L);
		fprintf(out, "(%d, %.1f) ", entry-&gt;col, entry-&gt;data);
		moveNext(L);
	}
	fprintf(out, "\n");
}

// printMatrix()
// Prints a string representation of Matrix M to filestream out. Zero rows
// are not printed. Each non-zero row is represented as one line consisting
// of the row number, followed by a colon, a space, then a space separated
// list of pairs "(col, val)" giving the column numbers and non-zero values
// in that row. The double val will be rounded to 1 decimal point.
void printMatrix(FILE* out, Matrix M) {
</font><a name="10"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-1.html#10" target="1"><img src="./tm_0_2.gif" alt="other" border="0" align="left"></a>

	for (int i = 1; i &lt; size(M) + 1; i++) {
		if (length(M-&gt;row[i]) != 0) {
			fprintf(out, "%d: ", i);
			printList(out, M-&gt;row[i]);
</font>		}
	}
}
</pre>



</body></html>