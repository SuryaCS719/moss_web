
<!-- saved from url=(0062)http://moss.stanford.edu/results/9/8328711968819/match1-1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/aaychen/pa4/Matrix.c</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/fall23/itphung/pa4/Matrix.c<p></p><pre>/***
 * Isabella Phung
 * itphung
 * 2023 Fall CSE 101 PA4
 * Matrix.c
 * Implementation file for Matrix ADT
 ***/

#include "Matrix.h"
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;

// private Entry type
typedef struct EntryObj *Entry;

// private EntryObj type
typedef struct EntryObj {
  int col;
  double data;
} EntryObj;

// private MatrixObj type
typedef struct MatrixObj {
  int size;
  int nnz;
  List *row;
} MatrixObj;

// newEntry()
// Returns a reference to a new Entry obj with column and data
Entry newEntry(int col, double data) {
  Entry E = malloc(sizeof(EntryObj));
  assert(E != NULL);
  E-&gt;col = col;
  E-&gt;data = data;
  return E;
}

// freeEntry()
// Frees heap memory associated with *pE, sets *pE to NULL.
void freeEntry(Entry *pE) {
  if (pE != NULL &amp;&amp; *pE != NULL) { // checks if Entry is Null
    free(*pE);
<a name="8"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-0.html#8" target="0"><img src="./tm_3_3.gif" alt="other" border="0" align="left"></a>

    *pE = NULL; // dereferences pM and pointer to null
  }
}

// newMatrix()
// Returns a reference to a new nXn Matrix object in the zero state.
Matrix newMatrix(int n) {
  Matrix M = malloc(sizeof(MatrixObj));
  assert(M != NULL);
  M-&gt;size = n;
  M-&gt;row = calloc(n + 1, sizeof(List *));
  for (int i = 1; i &lt; n + 1; i++) {
    M-&gt;row[i] = newList();
  }
  M-&gt;nnz = 0;
  return M;
}

// makeZero()
// Re-sets M to the zero Matrix state.
</font><a name="7"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-0.html#7" target="0"><img src="./tm_2_4.gif" alt="other" border="0" align="left"></a>

void makeZero(Matrix M) {
  if (M == NULL) {
    printf("Matrix Error: calling makeZero() on NULL Matrix.\n");
    exit(EXIT_FAILURE);
  }
  Entry entry;
  for (int i = 1; i &lt; size(M) + 1; i++) {
    moveFront(M-&gt;row[i]);
    while (index(M-&gt;row[i]) != -1) {
      entry = get(M-&gt;row[i]);
      freeEntry(&amp;entry);
      moveNext(M-&gt;row[i]);
    }
    clear(M-&gt;row[i]);
  }
  M-&gt;nnz = 0;
}

// freeMatrix()
// Frees heap memory associated with *pM, sets *pM to NULL.
</font><a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-0.html#3" target="0"><img src="./tm_3_13.gif" alt="other" border="0" align="left"></a>

void freeMatrix(Matrix *pM) {
  if (pM != NULL &amp;&amp; *pM != NULL) { // checks if Matrix is empty
    makeZero(*pM);
    for (int i = 1; i &lt; size(*pM) + 1; i++) {
      freeList(&amp;((*pM)-&gt;row[i]));
    }
    free((*pM)-&gt;row);
    (*pM)-&gt;row = NULL;
    free(*pM);
    *pM = NULL; // dereferences pM and pointer to null
  }
}

// Access functions

// size()
// Return the size of square Matrix M.
int size(Matrix M) {
  if (M == NULL) {
    printf("Matrix Error: calling size() on NULL Matrix.\n");
    exit(EXIT_FAILURE);
  }
  return M-&gt;size;
}

// NNZ()
// Return the number of non-zero elements in M.
int NNZ(Matrix M) {
  if (M == NULL) {
    printf("Matrix Error: calling NNZ() on NULL Matrix.\n");
    exit(EXIT_FAILURE);
  }
  return M-&gt;nnz;
}

// equals()
// Return true (1) if matrices A and B are equal, false (0) otherwise.
int equals(Matrix A, Matrix B) {
  // if sizes don't match, skip checks and return false
  if (A-&gt;size != B-&gt;size || A-&gt;nnz != B-&gt;nnz) {
    return 0;
  }

  if (A == NULL || B == NULL) {
    printf("Matrix Error: calling equals() on NULL Matrix.\n");
    exit(EXIT_FAILURE);
  }

  // checks all columns and entries for equality
  Entry entryA;
  Entry entryB;
  for (int i = 1; i &lt; size(A) + 1; i++) {
    moveFront(A-&gt;row[i]);
    moveFront(B-&gt;row[i]);
    while (index(A-&gt;row[i]) != -1 &amp;&amp; index(B-&gt;row[i]) != -1) {
      entryA = get(A-&gt;row[i]);
      entryB = get(B-&gt;row[i]);
      if (entryA-&gt;col != entryB-&gt;col || entryA-&gt;data != entryB-&gt;data) {
        return 0;
</font>      }
      moveNext(A-&gt;row[i]);
      moveNext(B-&gt;row[i]);
    }
  }
  return 1;
}

// Manipulation procedures
// printList()
// private function prints out a row of a Matrix
<a name="9"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-0.html#9" target="0"><img src="./tm_4_2.gif" alt="other" border="0" align="left"></a>

void printList(FILE *out, List L) {
  if (L == NULL) {
    printf("List Error: calling printList() on NULL List reference\n");
    exit(EXIT_FAILURE);
  }

  moveFront(L);
  Entry entry;
  while (index(L) != -1) {
    entry = get(L);
    fprintf(out, "(%d, %.1f) ", entry-&gt;col, entry-&gt;data);
    moveNext(L);
  }

  fprintf(out, "\n");
}

// changeEntry()
// Changes the ith row, jth column of M to the value x.
// Pre: 1&lt;=i&lt;=size(M), 1&lt;=j&lt;=size(M)
void changeEntry(Matrix M, int i, int j, double x) {
</font><a name="11"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-0.html#11" target="0"><img src="./tm_1_1.gif" alt="other" border="0" align="left"></a>

  if (M == NULL) {
    printf("Matrix Error: calling changeEntry() on NULL Matrix.\n");
    exit(EXIT_FAILURE);
  }
  if (i &lt; 1 || i &gt; size(M)) {
    printf("Matrix Error when calling changeEntry(): row value needs to be "
</font>           "1&lt;=i&lt;=size(M).\n");
    exit(EXIT_FAILURE);
  }
  if (j &lt; 1 || j &gt; size(M)) {
    printf("Matrix Error when calling changeEntry(): column value needs to be "
           "1&lt;=j&lt;=size(M).\n");
<a name="5"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-0.html#5" target="0"><img src="./tm_0_6.gif" alt="other" border="0" align="left"></a>

    exit(EXIT_FAILURE);
  }
  // first check if entry already exists
  List rowi = M-&gt;row[i];
  moveFront(rowi);
  Entry entry;
  Entry n;

  while (index(rowi) != -1) {
    entry = get(rowi);
    if (entry-&gt;col == j) { // if entry exists
      if (x == 0) { // if we're changing an existing val to 0, delete entry
        // printf("deleting existing val\n");
        M-&gt;nnz--;
        freeEntry(&amp;entry);
        delete (rowi);
        return;
      } else { // if we're changing an existing val
        entry-&gt;data = x;
        // printf("changing existing val\n");
        return;
      }
    }
    if (entry-&gt;col &gt; j) {
      if (x != 0) { // if no existing val
        M-&gt;nnz++;
        // printf("insertBefore reached\n");
        n = newEntry(j, x);
        insertBefore(rowi, n);
      }
      return;
    }
    moveNext(rowi);
  }
  // if we reached end of List, and data isn't 0, append to end
  if (x != 0) {
    n = newEntry(j, x);
    append(rowi, n);
    M-&gt;nnz++;
</font>  }
}

// Helper functions
// DotProd()
// calculates dot product of two given lists
<a name="6"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-0.html#6" target="0"><img src="./tm_1_5.gif" alt="other" border="0" align="left"></a>

double DotProd(List A, List B) {
  double sum = 0;
  if (length(A) == 0 || length(B) == 0) { // if either lists empty
    return sum;
  }
  moveFront(A);
  moveFront(B);
  Entry entryA;
  Entry entryB;

  // neither A or B are empty
  while (index(A) != -1 &amp;&amp; index(B) != -1) {
    entryA = get(A);
    entryB = get(B);

    if (entryA-&gt;col == entryB-&gt;col) {
      sum += entryA-&gt;data * entryB-&gt;data;
      moveNext(A);
      moveNext(B);
      continue;
    } else if (entryA-&gt;col &lt; entryB-&gt;col) {
      moveNext(A);
    } else {
</font><a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-0.html#0" target="0"><img src="./tm_0_15.gif" alt="other" border="0" align="left"></a>

      moveNext(B);
    }
  }
  return sum;
}

// sumDiff()
// adds and subtracts lists
// int isAdd is either 1 or -1
List sumDiff(List A, List B, int isAdd) {
  List sum = newList();
  Entry entry;
  Entry entryA;
  Entry entryB;

  moveFront(A);
  moveFront(B);

  // if either lists are empty,
  // copy contents of other list into sum
  if (length(A) == 0) {
    while (index(B) != -1) {
      entryB = get(B);
      entry = newEntry(entryB-&gt;col, isAdd * (entryB-&gt;data));
      append(sum, entry);
      moveNext(B);
    }
    return sum;
  }

  if (length(B) == 0) {
    while (index(A) != -1) {
      entryA = get(A);
      entry = newEntry(entryA-&gt;col, entryA-&gt;data);
      append(sum, entry);
      moveNext(A);
    }
    return sum;
  }

  // neither lists are empty
  double total = 0;
  while (index(A) != -1 &amp;&amp; index(B) != -1) {
    entryA = get(A);
    entryB = get(B);

    if (entryA-&gt;col &lt; entryB-&gt;col) {
      entry = newEntry(entryA-&gt;col, entryA-&gt;data);
      append(sum, entry);
      moveNext(A);
    } else if (entryA-&gt;col &gt; entryB-&gt;col) {
      entry = newEntry(entryB-&gt;col, isAdd * (entryB-&gt;data));
      append(sum, entry);
      moveNext(B);
    } else {
      total = entryA-&gt;data + isAdd * (entryB-&gt;data);
      if (total != 0) { // only append to sum if total isn't 0
        entry = newEntry(entryA-&gt;col, total);
        append(sum, entry);
      }
      moveNext(A);
      moveNext(B);
    }
  }

  // if we finished with extra remaining entries
  // at the end of any lists, append to sum
  while (index(A) != -1) {
    entryA = get(A);
    entry = newEntry(entryA-&gt;col, entryA-&gt;data);
    append(sum, entry);
    moveNext(A);
  }

  while (index(B) != -1) {
    entryB = get(B);
    entry = newEntry(entryB-&gt;col, isAdd * (entryB-&gt;data));
    append(sum, entry);
    moveNext(B);
  }

  return sum;
}

// Matrix Arithmetic operations

// copy()
// Returns a reference to a new Matrix object having the same entries as A.
Matrix copy(Matrix A) {
</font><a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-0.html#1" target="0"><img src="./tm_1_14.gif" alt="other" border="0" align="left"></a>

  Matrix B = newMatrix(size(A));
  Entry n;
  Entry entry;
  List rowi;
  for (int i = 1; i &lt; size(B) + 1; i++) {
    rowi = A-&gt;row[i];
    moveFront(rowi);
    while (index(rowi) != -1) {
      entry = get(rowi);
      n = newEntry(entry-&gt;col, entry-&gt;data);
      append(B-&gt;row[i], n);
      moveNext(rowi);
    }
  }
  B-&gt;nnz = A-&gt;nnz;
  return B;
}

// transpose()
// Returns a reference to a new Matrix object representing the transpose
// of A.
Matrix transpose(Matrix A) {
  Matrix B = newMatrix(size(A));
  Entry entry;
  Entry n;
  List rowi;
  for (int i = 1; i &lt; size(B) + 1; i++) {
    rowi = A-&gt;row[i];
    moveFront(rowi);
    while (index(rowi) != -1) {
      if (index(rowi) != -1) {
        entry = get(rowi);
        n = newEntry(i, entry-&gt;data);
        append(B-&gt;row[entry-&gt;col], n);
        moveNext(rowi);
      }
    }
  }
  B-&gt;nnz = A-&gt;nnz;
  return B;
}

// scalarMult()
// Returns a reference to a new Matrix object representing xA.
Matrix scalarMult(double x, Matrix A) {
  Matrix B = newMatrix(size(A));
  Entry entry;
  Entry n;
  List rowi;
  for (int i = 1; i &lt; size(B) + 1; i++) {
    rowi = A-&gt;row[i];
    moveFront(rowi);
    while (index(rowi) != -1) {
      entry = get(rowi);
      n = newEntry(entry-&gt;col, x * (entry-&gt;data));
      append(B-&gt;row[i], n);
      moveNext(rowi);
    }
  }
  B-&gt;nnz = A-&gt;nnz;
  return B;
</font>}

// sum()
// Returns a reference to a new Matrix object representing A+B.
// pre: size(A)==size(B)
Matrix sum(Matrix A, Matrix B) {
<a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-0.html#2" target="0"><img src="./tm_2_13.gif" alt="other" border="0" align="left"></a>

  if (size(A) != size(B)) {
    printf("Matrix Error: calling sum() on matricies of different sizes.\n");
    exit(EXIT_FAILURE);
  }
  Matrix RH = B;
  int isDifferent = 1;
  // if we're adding identical matricies, make a copy
  // prevents cursor overlap
  if (equals(A, B) == 1) {
    RH = copy(B);
    isDifferent = 0;
  }
  Matrix C = newMatrix(size(A));
  for (int i = 1; i &lt; size(RH) + 1; i++) {
    freeList(&amp;(C-&gt;row[i]));
    C-&gt;row[i] = sumDiff(A-&gt;row[i], RH-&gt;row[i], 1);
    C-&gt;nnz += length(C-&gt;row[i]);
  }
  if (!isDifferent) {
    freeMatrix(&amp;RH);
  }
  return C;
}

// diff()
// Returns a reference to a new Matrix object representing A-B.
// pre: size(A)==size(B)
Matrix diff(Matrix A, Matrix B) {
  if (size(A) != size(B)) {
    printf("Matrix Error: calling diff() on matricies of different sizes.\n");
    exit(EXIT_FAILURE);
  }

  Matrix RH = B;
  int isDifferent = 1;
  // if we're adding identical matricies, make a copy
  // prevents cursor overlap
  if (equals(A, B) == 1) {
    RH = copy(B);
    isDifferent = 0;
  }

  Matrix C = newMatrix(size(A));
  for (int i = 1; i &lt; size(RH) + 1; i++) {
    freeList(&amp;(C-&gt;row[i]));
    C-&gt;row[i] = sumDiff(A-&gt;row[i], RH-&gt;row[i], -1);
    C-&gt;nnz += length(C-&gt;row[i]);
  }
  if (!isDifferent) {
    freeMatrix(&amp;RH);
  }
  return C;
</font><a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-0.html#4" target="0"><img src="./tm_4_7.gif" alt="other" border="0" align="left"></a>

}

// product()
// Returns a reference to a new Matrix object representing AB
// pre: size(A)==size(B)
Matrix product(Matrix A, Matrix B) {
  if (size(A) != size(B)) {
    printf("Matrix Error: calling diff() on matricies of different sizes.\n");
    exit(EXIT_FAILURE);
  }
  double data;
  Entry entry;

  Matrix C = newMatrix(size(A));
  Matrix BT = transpose(B);
  for (int i = 1; i &lt; size(BT) + 1; i++) {
    if (length(BT-&gt;row[i]) != 0) {
      for (int j = 1; j &lt; size(A) + 1; j++) {
        if (length(A-&gt;row[j]) != 0) {
          data = DotProd(A-&gt;row[j], BT-&gt;row[i]);
          if (data != 0) { // only appends data if not 0
            entry = newEntry(i, data);
            append(C-&gt;row[j], entry);
            C-&gt;nnz++;
          }
        }
      }
    }
  }
  freeMatrix(&amp;BT);
  return C;
}

// printMatrix()
// Prints a string representation of Matrix M to filestream out. Zero rows
// are not printed.  Each non-zero row is represented as one line consisting
// of the row number, followed by a colon, a space, then a space separated
// list of pairs "(col, val)" giving the column numbers and non-zero values
// in that row. The double val will be rounded to 1 decimal point.
void printMatrix(FILE *out, Matrix M) {
</font><a name="10"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/9/8328711968819/match1-0.html#10" target="0"><img src="./tm_0_2.gif" alt="other" border="0" align="left"></a>

  for (int i = 1; i &lt; size(M) + 1; i++) {
    if (length(M-&gt;row[i]) != 0) {
      fprintf(out, "%d: ", i);
      printList(out, M-&gt;row[i]);
</font>    }
  }
}
</pre>



</body></html>