
<!-- saved from url=(0064)http://moss.stanford.edu/results/9/8116476182799/match1-1.html#0 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/prpoddar/pa4/Matrix.c</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter25/fmarti39/pa4/Matrix.c<p></p><pre>/********************************************************************************* 
* Francisco Martinez fmarti39
* Matrix.c
* PA4-Matrix ADT
*********************************************************************************/ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include "Matrix.h"
#include "List.h"

<a name="7"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-0.html#7" target="0"><img src="./tm_2_3.gif" alt="other" border="0" align="left"></a>

typedef struct EntryObj {
   int col;
   double val;
} EntryObj;

typedef struct MatrixObj {
   int size;
   int NNZ;
   List* rows;
} MatrixObj;

// public Matrix type
typedef struct EntryObj *Entry;

// Entry constructor
Entry newEntry(int col, double val) {
   Entry E = malloc(sizeof(EntryObj));
   E-&gt;col = col;
   E-&gt;val = val;
</font>   return E;
}

// Entry destructor
void freeEntry(Entry* pE) {
   if (pE != NULL &amp;&amp; *pE != NULL) {
      free(*pE);
      *pE = NULL;
   }
}

// newMatrix()
// Returns a reference to a new nXn Matrix object in the zero state.
Matrix newMatrix(int n) {
   Matrix M = malloc(sizeof(MatrixObj));
   M-&gt;size = n;
   M-&gt;NNZ = 0;
   M-&gt;rows = calloc(n+1, sizeof(List));
   for (int i = 1; i &lt;= n; i++) {
      M-&gt;rows[i] = newList();
   }
   return M;
}

// freeMatrix()
// Frees heap memory associated with *pM, sets *pM to NULL.
void freeMatrix(Matrix* pM) {
   if (pM != NULL &amp;&amp; *pM != NULL) {
      makeZero(*pM);
      for (int i = 1; i &lt;= (*pM)-&gt;size; i++) {
         freeList(&amp;((*pM)-&gt;rows[i]));
      }
      free((*pM)-&gt;rows);
      free(*pM);
      *pM = NULL;
   }
}

// Access functions -----------------------------------------------------------

// Access functions
// size()
// Return the size of square Matrix M.
int size(Matrix M) {
   return M-&gt;size;
}

// NNZ()
// Return the number of non-zero elements in M.
int NNZ(Matrix M) {
   return M-&gt;NNZ;
}

// equals()
// Return true (1) if matrices A and B are equal, false (0) otherwise.
int equals(Matrix A, Matrix B) {
    if (A == NULL || B == NULL) {
<a name="9"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-0.html#9" target="0"><img src="./tm_4_2.gif" alt="other" border="0" align="left"></a>

        fprintf(stderr, "Matrix | equals() | Calling equals() on one or more NULL Matrices.");
        exit(EXIT_FAILURE);
    }
    if (size(A) != size(B)) {
        return 0;
    }
    for (int i = 1; i &lt;= size(A); i++) {
        if (length(A-&gt;rows[i]) != length(B-&gt;rows[i])) {
</font>            return 0;
        }
<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-0.html#1" target="0"><img src="./tm_1_9.gif" alt="other" border="0" align="left"></a>

        moveFront(A-&gt;rows[i]);
        moveFront(B-&gt;rows[i]);
        while (index(A-&gt;rows[i]) &gt; 0) {
            if (((Entry)get(A-&gt;rows[i]))-&gt;col != ((Entry)get(B-&gt;rows[i]))-&gt;col) {
                return 0;
            }
            if (((Entry)get(A-&gt;rows[i]))-&gt;val != ((Entry)get(B-&gt;rows[i]))-&gt;val) {
                return 0;
            }
            moveNext(A-&gt;rows[i]);
            moveNext(B-&gt;rows[i]);
        }
    }
    return 1;
}

// Manipulation procedures -----------------------------------------------------

// Manipulation procedures
// makeZero()
// Re-sets M to the zero Matrix state.
void makeZero(Matrix M) {
   for (int i = 1; i &lt;= size(M); i++) {
      List row = M-&gt;rows[i];
      if (row != NULL) {
        clear(row);
      }
   }
   M-&gt;NNZ = 0;
}

// changeEntry()
// Changes the ith row, jth column of M to the value x.
// Pre: 1&lt;=i&lt;=size(M), 1&lt;=j&lt;=size(M)
void changeEntry(Matrix M, int i, int j, double x) {
   if (M == NULL) {
</font>      fprintf(stderr, "EXIT nothing is in changeEntry");
      exit(EXIT_FAILURE);
   }
   if (i &lt; 1 || i &gt; M-&gt;size || j &lt; 1 || j &gt; M-&gt;size) {
      fprintf(stderr, "EXIT Out of Bounds\n");
      exit(EXIT_FAILURE);
   }

   List L = M-&gt;rows[i];
   moveFront(L);
<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-0.html#4" target="0"><img src="./tm_4_6.gif" alt="other" border="0" align="left"></a>

   while (index(L) &gt;= 0) {
      Entry E = (Entry) get(L);
      if (E-&gt;col == j) {
         if (x == 0.0) {
            delete(L);
            M-&gt;NNZ--;
            freeEntry(&amp;E);
            return;
         } else {
            E-&gt;val = x;
            return;
         }
      } else if (E-&gt;col &gt; j) {
         if (x != 0.0) {
            insertBefore(L, newEntry(j, x));
            M-&gt;NNZ++;
            return;
         } else {
            return;
         }
      }
      moveNext(L);
   }

   if (x != 0.0) {
      append(L, newEntry(j, x));
      M-&gt;NNZ++;
   }
}

// Matrix Arithmetic operations --------------------------------------------------

// copy()
// Returns a reference to a new Matrix object having the same entries as A.
Matrix copy(Matrix A) {
   Matrix B = newMatrix(A-&gt;size);
   for (int i = 1; i &lt;= A-&gt;size; i++) {
</font>      List row = A-&gt;rows[i];
      moveFront(row);
      while (index(row) != -1) {
         Entry entry = (Entry) get(row);
         changeEntry(B, i, entry-&gt;col, entry-&gt;val);
         moveNext(row);
      }
   }
   return B;
}

// transpose()
// Returns a reference to a new Matrix object representing the transpose
// of A.
Matrix transpose(Matrix A) {
   Matrix B = newMatrix(A-&gt;size);
   for (int i = 1; i &lt;= A-&gt;size; i++) {
      List row = A-&gt;rows[i];
      moveFront(row);
      while (index(row) != -1) {
         Entry entry = (Entry) get(row);
         changeEntry(B, entry-&gt;col, i, entry-&gt;val);
         moveNext(row);
      }
   }
   return B;
}

// scalarMult()
// Returns a reference to a new Matrix object representing xA.
Matrix scalarMult(double x, Matrix A) {
   Matrix B = newMatrix(A-&gt;size);
   for (int i = 1; i &lt;= A-&gt;size; i++) {
<a name="8"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-0.html#8" target="0"><img src="./tm_3_2.gif" alt="other" border="0" align="left"></a>

      List row = A-&gt;rows[i];
      moveFront(row);
      while (index(row) != -1) {
         Entry entry = (Entry) get(row);
         changeEntry(B, i, entry-&gt;col, x * entry-&gt;val);
         moveNext(row);
      }
   }
   return B;
}

// sum()
// Returns a reference to a new Matrix object representing A+B.
// pre: size(A)==size(B)
Matrix sum(Matrix A, Matrix B) {
</font>    if (A == NULL || B == NULL) {
        fprintf(stderr, "ERROR nothing in sum");
        exit(EXIT_FAILURE);
    }
<a name="5"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-0.html#5" target="0"><img src="./tm_0_5.gif" alt="other" border="0" align="left"></a>

    if (size(A) != size(B)) {
        fprintf(stderr, "ERROR comopiled wrong.");
        exit(EXIT_FAILURE);
    }
    if (A == B) {
        return scalarMult(2, A);
    }
    Matrix C = newMatrix(A-&gt;size);
    List sL;
    for (int i = 1; i &lt;= C-&gt;size; i++) {
        sL = C-&gt;rows[i];
        moveFront(A-&gt;rows[i]);
        moveFront(B-&gt;rows[i]);
        while (index(A-&gt;rows[i]) &gt;= 0 &amp;&amp; index(B-&gt;rows[i]) &gt;= 0) {
</font><a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-0.html#2" target="0"><img src="./tm_2_9.gif" alt="other" border="0" align="left"></a>

            Entry aE = (Entry)get(A-&gt;rows[i]);
            Entry bE = (Entry)get(B-&gt;rows[i]);
            if (aE-&gt;col &lt; bE-&gt;col) {
                append(sL, newEntry(aE-&gt;col, aE-&gt;val));
                C-&gt;NNZ++;
                moveNext(A-&gt;rows[i]);
            }
            else if (aE-&gt;col &gt; bE-&gt;col) {
                append(sL, newEntry(bE-&gt;col, bE-&gt;val));
                C-&gt;NNZ++;
                moveNext(B-&gt;rows[i]);
            }
            else {
                if (aE-&gt;val + bE-&gt;val != 0) {
                    append(sL, newEntry(aE-&gt;col, aE-&gt;val + bE-&gt;val));
                    C-&gt;NNZ++;
                }
                moveNext(A-&gt;rows[i]);
                moveNext(B-&gt;rows[i]);
            }
        }
         while (index(A-&gt;rows[i]) &gt;= 0) {
</font>            Entry aE = (Entry)get(A-&gt;rows[i]);
<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-0.html#3" target="0"><img src="./tm_3_8.gif" alt="other" border="0" align="left"></a>

            append(sL, newEntry(aE-&gt;col, aE-&gt;val));
            C-&gt;NNZ++;
            moveNext(A-&gt;rows[i]);
         }
         while (index(B-&gt;rows[i]) &gt;= 0) { 
            Entry bE = (Entry)get(B-&gt;rows[i]);
            append(sL, newEntry(bE-&gt;col, bE-&gt;val));
            C-&gt;NNZ++;
            moveNext(B-&gt;rows[i]);
        }
    }
    return C;
}

// diff()
// Returns a reference to a new Matrix object representing A-B.
// pre: size(A)==size(B)
Matrix diff(Matrix A, Matrix B) {
    if (A-&gt;size != B-&gt;size) {
        fprintf(stderr, "Error: matrices must have the same size.\n");
        exit(EXIT_FAILURE);
    }
    return sum(A, scalarMult(-1.0, B));
}

double vectorDot(List P, List Q) {
    double dot_prod = 0.0;
    moveFront(P);
    moveFront(Q);
    while (index(P) &gt;= 0 &amp;&amp; index(Q) &gt;= 0) {
</font>        Entry eP = (Entry)get(P);
        Entry eQ = (Entry)get(Q);
        if (eP-&gt;col == eQ-&gt;col) {
            dot_prod += eP-&gt;val * eQ-&gt;val;
            moveNext(P);
            moveNext(Q);
        }
        else if (eP-&gt;col &lt; eQ-&gt;col) {
            moveNext(P);
        }
        else if (eP-&gt;col &gt; eQ-&gt;col) {
            moveNext(Q);
        }
    }
    return dot_prod;
}

Matrix product(Matrix A, Matrix B) {
    if (A == NULL || B == NULL) {
        fprintf(stderr, "Called on wrong ERROR product");
<a name="6"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-0.html#6" target="0"><img src="./tm_1_4.gif" alt="other" border="0" align="left"></a>

        exit(EXIT_FAILURE);
    }
    if (A-&gt;size != B-&gt;size) {
        fprintf(stderr, "calling Product on wrong sized Matrices");
        exit(EXIT_FAILURE);
    }
    Matrix P = newMatrix(A-&gt;size);
    if (A-&gt;NNZ == 0 || B-&gt;NNZ == 0) {
        return P;
    }
    Matrix BT = transpose(B);
    for (int i = 1; i &lt;= A-&gt;size; i++) {
        List Prow = A-&gt;rows[i];
</font>        if (length(Prow) &gt; 0) {
<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-0.html#0" target="0"><img src="./tm_0_10.gif" alt="other" border="0" align="left"></a>

            for (int j = 1; j &lt;= BT-&gt;size; j++) {
                List Qrow = BT-&gt;rows[j];
                if (length(Qrow) &gt; 0) {
                    double dp = vectorDot(Prow, Qrow);
                    if (dp != 0) {
                        Entry e = newEntry(j, dp);
                        append(P-&gt;rows[i], e);
                        P-&gt;NNZ++;        
                    }
                }
            }
        }
    }
    freeMatrix(&amp;BT);
    return P;
}

// printMatrix()
// Prints a string representation of Matrix M to filestream out. Zero rows
// are not printed. Each non-zero row is represented as one line consisting
// of the row number, followed by a colon, a space, then a space separated
// list of pairs "(col, val)" giving the column numbers and non-zero values
// in that row. The double val will be rounded to 1 decimal point.
void printMatrix(FILE* out, Matrix M) {
   if (out == NULL || M == NULL) {
      printf("Error: printMatrix() called with NULL parameters\n");
      exit(EXIT_FAILURE);;
   }
   for (int i = 1; i &lt;= size(M); i++) {
      if (length(M-&gt;rows[i]) &gt; 0) {
         fprintf(out, "%d: ", i);
         for (moveFront(M-&gt;rows[i]); index(M-&gt;rows[i]) &gt;= 0; moveNext(M-&gt;rows[i])) {
            Entry e = get(M-&gt;rows[i]);
            fprintf(out, "(%d, %.1f) ", e-&gt;col, e-&gt;val);
         }
         fprintf(out, "\n");
</font>      }
   }
}
</pre>



</body></html>