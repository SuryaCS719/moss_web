
<!-- saved from url=(0064)http://moss.stanford.edu/results/9/8116476182799/match1-0.html#3 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/winter25/prpoddar/pa4/Matrix.c</title>
<script id="simplify-jobs-page-script" src="chrome-extension://pbanhockgagggenencehbnadejlgchfc/js/pageScript.bundle.js"></script></head>
<body bgcolor="white">
<hr>
/winter25/prpoddar/pa4/Matrix.c<p></p><pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include "Matrix.h"
#include "List.h"

// Private type representing a single matrix entry
<a name="7"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-1.html#7" target="1"><img src="./tm_2_3.gif" alt="other" border="0" align="left"></a>

typedef struct EntryObj {
   int col;
   double val;
} EntryObj;

// Private Matrix type definition
typedef struct MatrixObj {
   int size;
   int NNZ;
   List* rows;
} MatrixObj;

// Public Entry type
typedef struct EntryObj *Entry;

// Constructor for creating a new entry
Entry newEntry(int col, double val) {
   Entry E = malloc(sizeof(EntryObj));
   E-&gt;col = col;
   E-&gt;val = val;
</font>   return E;
}

// Destructor for freeing an entry
void freeEntry(Entry* pE) {
   if (pE != NULL &amp;&amp; *pE != NULL) {
      free(*pE);
      *pE = NULL;
   }
}

// Constructor for creating a new matrix
Matrix newMatrix(int n) {
   Matrix M = malloc(sizeof(MatrixObj));
   M-&gt;size = n;
   M-&gt;NNZ = 0;
   M-&gt;rows = calloc(n+1, sizeof(List));
   for (int i = 1; i &lt;= n; i++) {
      M-&gt;rows[i] = newList();
   }
   return M;
}

// Destructor for freeing a matrix
void freeMatrix(Matrix* pM) {
   if (pM != NULL &amp;&amp; *pM != NULL) {
      makeZero(*pM);
      for (int i = 1; i &lt;= (*pM)-&gt;size; i++) {
         freeList(&amp;((*pM)-&gt;rows[i]));
      }
      free((*pM)-&gt;rows);
      free(*pM);
      *pM = NULL;
   }
}

// Accessor functions --------------------------------------------------------

// Returns the size of the square matrix M
int size(Matrix M) {
   return M-&gt;size;
}

// Returns the count of non-zero elements in matrix M
int NNZ(Matrix M) {
   return M-&gt;NNZ;
}

// Checks if matrices A and B are identical
int equals(Matrix A, Matrix B) {
    if (A == NULL || B == NULL) {
<a name="9"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-1.html#9" target="1"><img src="./tm_4_2.gif" alt="other" border="0" align="left"></a>

        fprintf(stderr, "Matrix | equals() | One or both matrices are NULL.");
        exit(EXIT_FAILURE);
    }
    if (size(A) != size(B)) {
        return 0;
    }
    for (int i = 1; i &lt;= size(A); i++) {
        if (length(A-&gt;rows[i]) != length(B-&gt;rows[i])) {
</font>            return 0;
        }
<a name="1"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-1.html#1" target="1"><img src="./tm_1_9.gif" alt="other" border="0" align="left"></a>

        moveFront(A-&gt;rows[i]);
        moveFront(B-&gt;rows[i]);
        while (index(A-&gt;rows[i]) &gt; 0) {
            if (((Entry)get(A-&gt;rows[i]))-&gt;col != ((Entry)get(B-&gt;rows[i]))-&gt;col) {
                return 0;
            }
            if (((Entry)get(A-&gt;rows[i]))-&gt;val != ((Entry)get(B-&gt;rows[i]))-&gt;val) {
                return 0;
            }
            moveNext(A-&gt;rows[i]);
            moveNext(B-&gt;rows[i]);
        }
    }
    return 1;
}

// Manipulation functions ----------------------------------------------------

// Resets matrix M to the zero matrix
void makeZero(Matrix M) {
   for (int i = 1; i &lt;= size(M); i++) {
      List row = M-&gt;rows[i];
      if (row != NULL) {
        clear(row);
      }
   }
   M-&gt;NNZ = 0;
}

// Updates the (i, j) entry of matrix M with value x
// Precondition: 1&lt;=i&lt;=size(M), 1&lt;=j&lt;=size(M)
void changeEntry(Matrix M, int i, int j, double x) {
   if (M == NULL) {
</font>      fprintf(stderr, "Matrix | changeEntry() | Calling on a NULL Matrix.");
      exit(EXIT_FAILURE);
   }
   if (i &lt; 1 || i &gt; M-&gt;size || j &lt; 1 || j &gt; M-&gt;size) {
      fprintf(stderr, "Matrix Error: changeEntry() with invalid indices.\n");
      exit(EXIT_FAILURE);
   }

   List L = M-&gt;rows[i];
   moveFront(L);
<a name="4"></a><font color="#FF00FF"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-1.html#4" target="1"><img src="./tm_4_6.gif" alt="other" border="0" align="left"></a>

   while (index(L) &gt;= 0) {
      Entry E = (Entry) get(L);
      if (E-&gt;col == j) {
         if (x == 0.0) {
            delete(L);
            M-&gt;NNZ--;
            freeEntry(&amp;E);
            return;
         } else {
            E-&gt;val = x;
            return;
         }
      } else if (E-&gt;col &gt; j) {
         if (x != 0.0) {
            insertBefore(L, newEntry(j, x));
            M-&gt;NNZ++;
            return;
         } else {
            return;
         }
      }
      moveNext(L);
   }

   if (x != 0.0) {
      append(L, newEntry(j, x));
      M-&gt;NNZ++;
   }
}

// Matrix arithmetic operations ------------------------------------------------

Matrix copy(Matrix A) {
   Matrix B = newMatrix(A-&gt;size);
   for (int i = 1; i &lt;= A-&gt;size; i++) {
</font>      List row = A-&gt;rows[i];
      moveFront(row);
      while (index(row) != -1) {
         Entry entry = (Entry) get(row);
         changeEntry(B, i, entry-&gt;col, entry-&gt;val);
         moveNext(row);
      }
   }
   return B;
}

Matrix transpose(Matrix A) {
   Matrix B = newMatrix(A-&gt;size);
   for (int i = 1; i &lt;= A-&gt;size; i++) {
      List row = A-&gt;rows[i];
      moveFront(row);
      while (index(row) != -1) {
         Entry entry = (Entry) get(row);
         changeEntry(B, entry-&gt;col, i, entry-&gt;val);
         moveNext(row);
      }
   }
   return B;
}

Matrix scalarMult(double x, Matrix A) {
   Matrix B = newMatrix(A-&gt;size);
   for (int i = 1; i &lt;= A-&gt;size; i++) {
<a name="8"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-1.html#8" target="1"><img src="./tm_3_2.gif" alt="other" border="0" align="left"></a>

      List row = A-&gt;rows[i];
      moveFront(row);
      while (index(row) != -1) {
         Entry entry = (Entry) get(row);
         changeEntry(B, i, entry-&gt;col, x * entry-&gt;val);
         moveNext(row);
      }
   }
   return B;
}

// Computes the sum of matrices A and B
// If A and B are NULL or have different sizes, an error is thrown
// If A and B are identical, returns a matrix of 2A (doubling A)
Matrix sum(Matrix A, Matrix B) {
</font>    if (A == NULL || B == NULL) {
        fprintf(stderr, "Matrix | sum() | One or both matrices are NULL.");
        exit(EXIT_FAILURE);
    }
<a name="5"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-1.html#5" target="1"><img src="./tm_0_5.gif" alt="other" border="0" align="left"></a>

    if (size(A) != size(B)) {
        fprintf(stderr, "Matrix | sum() | Matrices of differing sizes cannot be added.");
        exit(EXIT_FAILURE);
    }
    if (A == B) {
        return scalarMult(2, A);
    }
    Matrix C = newMatrix(A-&gt;size);
    List sL;
    for (int i = 1; i &lt;= C-&gt;size; i++) {
        sL = C-&gt;rows[i];
        moveFront(A-&gt;rows[i]);
        moveFront(B-&gt;rows[i]);
        while (index(A-&gt;rows[i]) &gt;= 0 &amp;&amp; index(B-&gt;rows[i]) &gt;= 0) {
</font><a name="2"></a><font color="#0000FF"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-1.html#2" target="1"><img src="./tm_2_9.gif" alt="other" border="0" align="left"></a>

            Entry aE = (Entry)get(A-&gt;rows[i]);
            Entry bE = (Entry)get(B-&gt;rows[i]);
            if (aE-&gt;col &lt; bE-&gt;col) {
                append(sL, newEntry(aE-&gt;col, aE-&gt;val));
                C-&gt;NNZ++;
                moveNext(A-&gt;rows[i]);
            }
            else if (aE-&gt;col &gt; bE-&gt;col) {
                append(sL, newEntry(bE-&gt;col, bE-&gt;val));
                C-&gt;NNZ++;
                moveNext(B-&gt;rows[i]);
            }
            else {
                if (aE-&gt;val + bE-&gt;val != 0) {
                    append(sL, newEntry(aE-&gt;col, aE-&gt;val + bE-&gt;val));
                    C-&gt;NNZ++;
                }
                moveNext(A-&gt;rows[i]);
                moveNext(B-&gt;rows[i]);
            }
        }
        while (index(A-&gt;rows[i]) &gt;= 0) {
</font>            Entry aE = (Entry)get(A-&gt;rows[i]);
<a name="3"></a><font color="#00FFFF"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-1.html#3" target="1"><img src="./tm_3_8.gif" alt="other" border="0" align="left"></a>

            append(sL, newEntry(aE-&gt;col, aE-&gt;val));
            C-&gt;NNZ++;
            moveNext(A-&gt;rows[i]);
        }
        while (index(B-&gt;rows[i]) &gt;= 0) {
            Entry bE = (Entry)get(B-&gt;rows[i]);
            append(sL, newEntry(bE-&gt;col, bE-&gt;val));
            C-&gt;NNZ++;
            moveNext(B-&gt;rows[i]);
        }
    }
    return C;
}

Matrix diff(Matrix A, Matrix B) {
    if (A-&gt;size != B-&gt;size) {
        fprintf(stderr, "Matrix | diff() | Matrices must be the same size to compute difference.");
        exit(EXIT_FAILURE);
    }
    return sum(A, scalarMult(-1.0, B));
}

double vectorDot(List P, List Q) {
    double dot_prod = 0.0;
    moveFront(P);
    moveFront(Q);
    while (index(P) &gt;= 0 &amp;&amp; index(Q) &gt;= 0) {
</font>        Entry eP = (Entry)get(P);
        Entry eQ = (Entry)get(Q);
        if (eP-&gt;col == eQ-&gt;col) {
            dot_prod += eP-&gt;val * eQ-&gt;val;
            moveNext(P);
            moveNext(Q);
        }
        else if (eP-&gt;col &lt; eQ-&gt;col) {
            moveNext(P);
        }
        else {
            moveNext(Q);
        }
    }
    return dot_prod;
}

Matrix product(Matrix A, Matrix B) {
    if (A == NULL || B == NULL) {
        fprintf(stderr, "Matrix | product() | One or both matrices are NULL.");
<a name="6"></a><font color="#00FF00"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-1.html#6" target="1"><img src="./tm_1_4.gif" alt="other" border="0" align="left"></a>

        exit(EXIT_FAILURE);
    }
    if (A-&gt;size != B-&gt;size) {
        fprintf(stderr, "Matrix | product() | Matrices must have identical sizes to compute product.");
        exit(EXIT_FAILURE);
    }
    Matrix P = newMatrix(A-&gt;size);
    if (A-&gt;NNZ == 0 || B-&gt;NNZ == 0) {
        return P;
    }
    Matrix BT = transpose(B);
    for (int i = 1; i &lt;= A-&gt;size; i++) {
        List Prow = A-&gt;rows[i];
</font>        if (length(Prow) &gt; 0) {
<a name="0"></a><font color="#FF0000"><a href="http://moss.stanford.edu/results/9/8116476182799/match1-1.html#0" target="1"><img src="./tm_0_10.gif" alt="other" border="0" align="left"></a>

            for (int j = 1; j &lt;= BT-&gt;size; j++) {
                List Qrow = BT-&gt;rows[j];
                if (length(Qrow) &gt; 0) {
                    double dp = vectorDot(Prow, Qrow);
                    if (dp != 0) {
                        Entry e = newEntry(j, dp);
                        append(P-&gt;rows[i], e);
                        P-&gt;NNZ++;
                    }
                }
            }
        }
    }
    freeMatrix(&amp;BT);
    return P;
}

void printMatrix(FILE* out, Matrix M) {
   if (out == NULL || M == NULL) {
      printf("Error: printMatrix() called with NULL parameters\n");
      exit(EXIT_FAILURE);;
   }
   for (int i = 1; i &lt;= size(M); i++) {
      if (length(M-&gt;rows[i]) &gt; 0) {
         fprintf(out, "%d: ", i);
         for (moveFront(M-&gt;rows[i]); index(M-&gt;rows[i]) &gt;= 0; moveNext(M-&gt;rows[i])) {
            Entry e = get(M-&gt;rows[i]);
            fprintf(out, "(%d, %.1f) ", e-&gt;col, e-&gt;val);
         }
         fprintf(out, "\n");
</font>      }
   }
}

</pre>



</body></html>